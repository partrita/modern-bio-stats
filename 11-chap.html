<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>13&nbsp; 이미지 분석 (Image Analysis) – Modern Statistics for Modern Biology</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./12-chap.html" rel="next">
<link href="./10-chap.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-ed96de9b727972fe78a7b5d16c58bf87.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-45c1b2e5a2b0567ccfb99e4dfc03f650.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="msmb.css">
</head>

<body class="nav-sidebar docked quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./11-chap.html"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">이미지 분석 (Image Analysis)</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Modern Statistics for Modern Biology</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">홈</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./00-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">서문 (Preface)</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">이산 데이터를 위한 생성 모델</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">매개변수가 핵심입니다.</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">고품질 그래픽 (High-Quality Graphics)</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">유한 혼합 모델 (Finite Mixture Models)</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">군집화 (Clustering)</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">가설 검정 (Hypothesis Testing)</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">다변량 분석 (Multivariate Analysis)</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./08-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">고처리량 카운트 데이터 (High-Throughput Count Data)</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./09-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">이질적 데이터의 다변량 분석 (Multivariate Analysis for Heterogeneous Data)</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./10-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">네트워크와 트리 (Networks and Trees)</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./11-chap.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">이미지 분석 (Image Analysis)</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./12-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">지도 학습 (Supervised Learning)</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./13-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">실험 설계 (Design of Experiments)</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./14-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">부록: 통계 개념 및 방법 목록 (Appendix: Statistical Concepts and Methods)</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./15-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">헌사 (Dedication)</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./16-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">참고문헌 (References)</span></span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#이-장의-목표" id="toc-이-장의-목표" class="nav-link active" data-scroll-target="#이-장의-목표"><span class="header-section-number">13.1</span> 11.1 이 장의 목표</a></li>
  <li><a href="#이미지-로드" id="toc-이미지-로드" class="nav-link" data-scroll-target="#이미지-로드"><span class="header-section-number">13.2</span> 11.2 이미지 로드</a></li>
  <li><a href="#이미지-표시" id="toc-이미지-표시" class="nav-link" data-scroll-target="#이미지-표시"><span class="header-section-number">13.3</span> 11.3 이미지 표시</a></li>
  <li><a href="#r에서-이미지는-어떻게-저장되나요" id="toc-r에서-이미지는-어떻게-저장되나요" class="nav-link" data-scroll-target="#r에서-이미지는-어떻게-저장되나요"><span class="header-section-number">13.4</span> 11.4 R에서 이미지는 어떻게 저장되나요?</a></li>
  <li><a href="#이미지-파일-쓰기" id="toc-이미지-파일-쓰기" class="nav-link" data-scroll-target="#이미지-파일-쓰기"><span class="header-section-number">13.5</span> 11.5 이미지 파일 쓰기</a></li>
  <li><a href="#이미지-조작" id="toc-이미지-조작" class="nav-link" data-scroll-target="#이미지-조작"><span class="header-section-number">13.6</span> 11.6 이미지 조작</a></li>
  <li><a href="#공간-변환" id="toc-공간-변환" class="nav-link" data-scroll-target="#공간-변환"><span class="header-section-number">13.7</span> 11.7 공간 변환</a></li>
  <li><a href="#선형-필터" id="toc-선형-필터" class="nav-link" data-scroll-target="#선형-필터"><span class="header-section-number">13.8</span> 11.8 선형 필터</a>
  <ul class="collapse">
  <li><a href="#막간-이미지의-강도-스케일" id="toc-막간-이미지의-강도-스케일" class="nav-link" data-scroll-target="#막간-이미지의-강도-스케일"><span class="header-section-number">13.8.1</span> 11.8.1 막간: 이미지의 강도 스케일</a></li>
  <li><a href="#평활화를-통한-노이즈-감소" id="toc-평활화를-통한-노이즈-감소" class="nav-link" data-scroll-target="#평활화를-통한-노이즈-감소"><span class="header-section-number">13.8.2</span> 11.8.2 평활화를 통한 노이즈 감소</a></li>
  </ul></li>
  <li><a href="#적응형-임계값-처리" id="toc-적응형-임계값-처리" class="nav-link" data-scroll-target="#적응형-임계값-처리"><span class="header-section-number">13.9</span> 11.9 적응형 임계값 처리</a></li>
  <li><a href="#이진-이미지에-대한-형태학적-연산" id="toc-이진-이미지에-대한-형태학적-연산" class="nav-link" data-scroll-target="#이진-이미지에-대한-형태학적-연산"><span class="header-section-number">13.10</span> 11.10 이진 이미지에 대한 형태학적 연산</a></li>
  <li><a href="#이진-이미지를-객체로-분할" id="toc-이진-이미지를-객체로-분할" class="nav-link" data-scroll-target="#이진-이미지를-객체로-분할"><span class="header-section-number">13.11</span> 11.11 이진 이미지를 객체로 분할</a></li>
  <li><a href="#보로노이-테셀레이션" id="toc-보로노이-테셀레이션" class="nav-link" data-scroll-target="#보로노이-테셀레이션"><span class="header-section-number">13.12</span> 11.12 보로노이 테셀레이션</a></li>
  <li><a href="#세포체-분할" id="toc-세포체-분할" class="nav-link" data-scroll-target="#세포체-분할"><span class="header-section-number">13.13</span> 11.13 세포체 분할</a></li>
  <li><a href="#특징-추출" id="toc-특징-추출" class="nav-link" data-scroll-target="#특징-추출"><span class="header-section-number">13.14</span> 11.14 특징 추출</a></li>
  <li><a href="#공간-통계-점-과정" id="toc-공간-통계-점-과정" class="nav-link" data-scroll-target="#공간-통계-점-과정"><span class="header-section-number">13.15</span> 11.15 공간 통계: 점 과정</a>
  <ul class="collapse">
  <li><a href="#사례-연구-면역-세포와-암세포의-상호작용" id="toc-사례-연구-면역-세포와-암세포의-상호작용" class="nav-link" data-scroll-target="#사례-연구-면역-세포와-암세포의-상호작용"><span class="header-section-number">13.15.1</span> 11.15.1 사례 연구: 면역 세포와 암세포의 상호작용</a></li>
  <li><a href="#볼록-껍질-convex-hull" id="toc-볼록-껍질-convex-hull" class="nav-link" data-scroll-target="#볼록-껍질-convex-hull"><span class="header-section-number">13.15.2</span> 11.15.2 볼록 껍질 (Convex hull)</a></li>
  <li><a href="#점-과정의-공간을-정의하는-다른-방법들" id="toc-점-과정의-공간을-정의하는-다른-방법들" class="nav-link" data-scroll-target="#점-과정의-공간을-정의하는-다른-방법들"><span class="header-section-number">13.15.3</span> 11.15.3 점 과정의 공간을 정의하는 다른 방법들</a></li>
  </ul></li>
  <li><a href="#차-효과-강도" id="toc-차-효과-강도" class="nav-link" data-scroll-target="#차-효과-강도"><span class="header-section-number">13.16</span> 11.16 1차 효과: 강도</a>
  <ul class="collapse">
  <li><a href="#포아송-과정-poisson-process" id="toc-포아송-과정-poisson-process" class="nav-link" data-scroll-target="#포아송-과정-poisson-process"><span class="header-section-number">13.16.1</span> 11.16.1 포아송 과정 (Poisson Process)</a></li>
  <li><a href="#강도-추정하기" id="toc-강도-추정하기" class="nav-link" data-scroll-target="#강도-추정하기"><span class="header-section-number">13.16.2</span> 11.16.2 강도 추정하기</a></li>
  </ul></li>
  <li><a href="#차-효과-공간적-의존성" id="toc-차-효과-공간적-의존성" class="nav-link" data-scroll-target="#차-효과-공간적-의존성"><span class="header-section-number">13.17</span> 11.17 2차 효과: 공간적 의존성</a>
  <ul class="collapse">
  <li><a href="#ripley의-k-함수" id="toc-ripley의-k-함수" class="nav-link" data-scroll-target="#ripley의-k-함수"><span class="header-section-number">13.17.1</span> 11.17.1 Ripley의 (K) 함수</a></li>
  </ul></li>
  <li><a href="#이-장의-요약" id="toc-이-장의-요약" class="nav-link" data-scroll-target="#이-장의-요약"><span class="header-section-number">13.18</span> 11.18 이 장의 요약</a></li>
  <li><a href="#더-읽을거리" id="toc-더-읽을거리" class="nav-link" data-scroll-target="#더-읽을거리"><span class="header-section-number">13.19</span> 11.19 더 읽을거리</a></li>
  <li><a href="#연습-문제" id="toc-연습-문제" class="nav-link" data-scroll-target="#연습-문제"><span class="header-section-number">13.20</span> 11.20 연습 문제</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">이미지 분석 (Image Analysis)</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p><img src="imgs/chap13-colorLabelscellbodies.png" class="img-fluid"></p>
<p>이미지는 풍부한 데이터 소스입니다. 이 장에서 우리는 이미지에서 어떻게 정량적 정보를 추출할 수 있는지, 그리고 데이터를 요약하고 이해하기 위해 통계적 방법을 어떻게 사용할 수 있는지 살펴볼 것입니다. 이 장의 목표는 이미지 데이터로 작업을 시작하는 것이 쉽다는 것을 보여주는 것입니다. 기본적인 R 환경을 다룰 수 있다면 이미지 작업을 시작할 준비가 된 것입니다. 그렇긴 하지만, 이 장이 이미지 분석에 대한 일반적인 입문서는 아닙니다. 이 분야는 광범위하며 신호 처리, 정보 이론, 수학, 공학 및 컴퓨터 과학의 많은 영역을 다루고 있으며, 체계적인 개요를 제시하는 훌륭한 책들이 많이 있습니다.</p>
<p>우리는 주로 일련의 2차원 이미지, 특히 세포 이미지를 공부할 것입니다. 세포의 위치와 모양을 식별하는 방법과 식별된 모양 및 패턴의 특성(예: 크기, 강도, 색상 분포 및 상대적 위치)을 정량적으로 측정하는 방법을 배울 것입니다. 이러한 정보는 후속 분석에 사용될 수 있습니다. 예를 들어 서로 다른 조건(예: 서로 다른 약물의 효과 하에 있거나 분화 및 성장 단계가 다른 경우) 사이의 세포를 비교할 수 있습니다. 또는 이미지의 객체들이 서로 어떻게 연관되어 있는지 측정할 수 있습니다. 예를 들어 객체들이 함께 모이거나 서로 밀어내는 것을 선호하는지, 아니면 이웃한 객체들 사이에 특정 특성이 공유되는 경향이 있는지(세포 간 통신을 나타냄) 등을 측정할 수 있습니다. 유전학의 언어로 말하자면, 이미지를 복잡한 표현형이나 다변량 양적 형질로 사용할 수 있다는 뜻입니다.</p>
<p>여기서 우리는 2차원 이상의 이미지 분석은 다루지 않을 것입니다. 3D 분할(segmentation) 및 등록(registration)이나 시간적 추적(temporal tracking)은 고려하지 않을 것입니다. 이것들은 정교한 작업이며, 이 장의 범위 내에서 우리가 조립할 수 있는 것보다 전문화된 소프트웨어가 아마도 더 나은 성능을 보일 것입니다.</p>
<p>고처리량 이미징 데이터와 유전체학의 다른 고처리량 데이터 사이에는 유사점이 있습니다. 예를 들어 염색 효율의 변화, 조명 또는 기타 여러 요인으로 인해 배치 효과(batch effects)가 작용하는 경향이 있습니다. 실험 설계와 분석 선택에서 적절한 예방 조치를 취해야 합니다. 원칙적으로 이미지의 강도 값은 물리적 단위(예: 복사 에너지 또는 형광체 농도)로 보정될 수 있습니다. 하지만 생물학적 이미징 실무에서 이것이 항상 수행되는 것은 아니며, 아마도 필요하지 않을 수도 있습니다. 다소 달성하기 쉽고 분명히 가치 있는 것은 이미지의 공간적 차원에 대한 보정, 즉 픽셀 단위와 미터법 거리 사이의 변환 계수입니다.</p>
<section id="이-장의-목표" class="level2" data-number="13.1">
<h2 data-number="13.1" class="anchored" data-anchor-id="이-장의-목표"><span class="header-section-number">13.1</span> 11.1 이 장의 목표</h2>
<p>이 장에서 우리는 다음을 수행할 것입니다:</p>
<ul>
<li><p>R에서 이미지를 읽고, 쓰고, 조작하는 방법을 배웁니다.</p></li>
<li><p>이미지에 필터와 변환을 적용하는 방법을 이해합니다.</p></li>
<li><p>이러한 기술을 결합하여 분할(segmentation) 및 특징 추출(feature extraction)을 수행합니다. 세포 분할을 예로 사용할 것입니다.</p></li>
<li><p>공간 분포와 의존성을 분석하기 위해 통계적 방법을 사용하는 방법을 배웁니다.</p></li>
<li><p>공간 점 과정(spatial point process)에 대한 가장 기본적인 분포인 균질 포아송 과정(homogeneous Poisson process)에 대해 알아봅니다.</p></li>
<li><p>여러분의 데이터가 그 기본 가정에 부합하는지, 아니면 덩어리짐(clumping)이나 배제(exclusion)의 증거를 보이는지 인식합니다.</p></li>
</ul>
</section>
<section id="이미지-로드" class="level2" data-number="13.2">
<h2 data-number="13.2" class="anchored" data-anchor-id="이미지-로드"><span class="header-section-number">13.2</span> 11.2 이미지 로드</h2>
<p>R에서 이미지를 처리하는 데 유용한 툴킷은 바이오컨덕터 패키지인 <strong><a href="https://bioconductor.org/packages/EBImage/">EBImage</a></strong> (<a href="16-chap.html#ref-EBImage">Pau et al.&nbsp;2010</a>)입니다. 기본 기능을 시연하기 위해 간단한 사진을 읽어 들이는 것으로 시작합니다.</p>
<pre><code>library("EBImage")
imagefile = system.file("images", "mosquito.png", package = "MSMB")
mosq = readImage(imagefile)</code></pre>
<p><strong><a href="https://bioconductor.org/packages/EBImage/">EBImage</a></strong>는 현재 세 가지 이미지 파일 형식인 <code>jpeg</code>, <code>png</code>, <code>tiff</code>를 지원합니다. 위에서 우리는 <strong><a href="https://bioconductor.org/packages/MSMB/">MSMB</a></strong> 패키지의 샘플 이미지를 로드했습니다. 자신의 데이터로 작업할 때는 그 패키지가 필요하지 않으며, <code>readImage</code> 함수에 파일 이름을 제공하기만 하면 됩니다. 이 장의 뒷부분에서 보게 되겠지만, <code>readImage</code>는 한 번에 여러 이미지를 읽을 수 있으며, 이들은 모두 단일 이미지 데이터 객체로 조립됩니다. 이것이 작동하려면 이미지들이 동일한 차원과 색상 모드를 가져야 합니다.</p>
<p>질문 11.1</p>
<p><strong>RBioFormats</strong> 패키지(GitHub에서 사용 가능: <a href="https://github.com/aoles/RBioFormats" class="uri">https://github.com/aoles/RBioFormats</a>)는 더 많은 이미지 파일 형식을 읽고 쓰는 기능을 제공합니다. 얼마나 많은 서로 다른 파일 형식이 지원되나요?</p>
<p>해결책</p>
<p><strong>RBioFormats</strong> 패키지의 <code>read.image</code> 함수 매뉴얼 페이지(이는 <code>EBImage::readImage</code>와는 다름에 유의)와 The Open Microscopy Environment 웹사이트의 Bio-Formats 프로젝트 온라인 문서(<a href="http://www.openmicroscopy.org/site/support/bio-formats5.5/supported-formats.html" class="uri">http://www.openmicroscopy.org/site/support/bio-formats5.5/supported-formats.html</a>)를 참조하세요.</p>
</section>
<section id="이미지-표시" class="level2" data-number="13.3">
<h2 data-number="13.3" class="anchored" data-anchor-id="이미지-표시"><span class="header-section-number">13.3</span> 11.3 이미지 표시</h2>
<p>방금 읽어 들인 이미지를 시각화해 봅시다. 기본 함수는 <code>EBImage::display</code>입니다.</p>
<pre><code>EBImage::display(mosq)</code></pre>
<p>위의 명령은 웹 브라우저 창(<code>getOption("browser")</code>에 의해 설정됨)에서 이미지를 엽니다. 마우스나 키보드 단축키를 사용하여 이미지를 확대하거나 축소하고, 팬(pan) 이동을 하거나 여러 이미지 프레임을 순환하며 볼 수 있습니다.</p>
<p>또는 <code>method = "raster"</code> 인수를 사용하여 <code>display</code>를 호출함으로써 R의 내장 플로팅 기능을 사용하여 이미지를 표시할 수도 있습니다. 그러면 이미지는 현재 장치로 출력됩니다. 이런 방식으로 이미지 데이터를 다른 플로팅 기능과 결합하여 예를 들어 텍스트 레이블을 추가할 수 있습니다.</p>
<pre><code>EBImage::display(mosq)
text(x = 85, y = 800, label = "A mosquito", adj = 0, col = "orange", cex = 1.5)</code></pre>
<p><a href="11-chap_files/figure- html/fig-mosquito-1.jpeg" title="그림 11.1: 조지아주 디케이터 교외에서 사체로 발견된 모기 (출처: CDC / Janice Haney Carr)."><img src="11-chap_files/figure-html/fig-mosquito-1.jpeg" class="img-fluid"></a></p>
<p>그림 11.1: 조지아주 디케이터 교외에서 사체로 발견된 모기 (출처: CDC / Janice Haney Carr).</p>
<p>결과 플롯은 그림 11.1에 나와 있습니다. 평소와 같이 R 장치에 표시된 그래픽은 <strong><a href="https://cran.r-project.org/web/packages/base/">base</a></strong> R 함수인 <code>dev.print</code>나 <code>dev.copy</code>를 사용하여 저장할 수 있습니다.</p>
<p>컬러 이미지를 읽고 볼 수도 있습니다(그림 11.2 참조).</p>
<pre><code>imagefile = system.file("images", "hiv.png", package = "MSMB")
hivc = readImage(imagefile)


EBImage::display(hivc, method = "raster")</code></pre>
<p><a href="11-chap_files/figure-html/fig- hiv-1.jpeg" title="그림 11.2: 배양된 림프구에서 싹이 트고 있는 HIV-1 비리온의 주사 전자 현미경 사진 (출처: CDC / C. Goldsmith, P. Feorino, E.L. Palmer, W.R. McManus)."><img src="11-chap_files/figure-html/fig-hiv-1.jpeg" class="img-fluid"></a></p>
<p>그림 11.2: 배양된 림프구에서 싹이 트고 있는 HIV-1 비리온의 주사 전자 현미경 사진 (출처: CDC / C. Goldsmith, P. Feorino, E.L. Palmer, W.R. McManus).</p>
<p>또한 이미지에 여러 프레임이 있는 경우, <code>all = TRUE</code> 인수를 지정하여 그리드 배열로 한 번에 모두 표시할 수 있습니다(그림 11.3).</p>
<pre><code>nuc = readImage(system.file("images", "nuclei.tif", package = "EBImage"))
EBImage::display(1 - nuc, all = TRUE)</code></pre>
<p><a href="11-chap_files/figure-html/fig-image-oneminus-1.png &quot;그림 11.3: EBImage 패키지에 포함된 세포 핵 이미지 4개를 타일 형식으로 표시한 모습.&quot;"><img src="11-chap_files/figure-html/fig-image- oneminus-1.png" class="img-fluid"></a></p>
<p>그림 11.3: <strong><a href="https://bioconductor.org/packages/EBImage/">EBImage</a></strong> 패키지에 포함된 세포 핵 이미지 4개를 타일 형식으로 표시한 모습.</p>
<p>또는 예를 들어 두 번째 프레임과 같이 단일 프레임만 볼 수도 있습니다.</p>
<pre><code>EBImage::display(1 - nuc, frame = 2)</code></pre>
</section>
<section id="r에서-이미지는-어떻게-저장되나요" class="level2" data-number="13.4">
<h2 data-number="13.4" class="anchored" data-anchor-id="r에서-이미지는-어떻게-저장되나요"><span class="header-section-number">13.4</span> 11.4 R에서 이미지는 어떻게 저장되나요?</h2>
<p>먼저 이미지 객체의 클래스를 식별하여 무슨 일이 일어나고 있는지 살펴봅시다.</p>
<pre><code>class(mosq)


[1] "Image"
attr(,"package")
[1] "EBImage"</code></pre>
<p>이 객체가 <em>Image</em> 클래스를 가지고 있음을 알 수 있습니다. 이것은 기본 R 클래스 중 하나가 아니라 <strong><a href="https://bioconductor.org/packages/EBImage/">EBImage</a></strong> 패키지에 의해 정의된 것입니다. 도움말 브라우저를 통하거나 <code>class?Image</code>를 입력하여 이 클래스에 대해 더 자세히 알아볼 수 있습니다. 이 클래스는 기본 R 클래스인 <em>array</em> 에서 파생되었으므로, R 배열로 할 수 있는 모든 작업을 <em>Image</em> 객체로도 할 수 있습니다. 게다가 몇 가지 추가적인 기능과 동작들을 가지고 있습니다1.</p>
<p>1 R의 용어로 추가적인 기능은 <strong>슬롯(slots)</strong>이라고 불리고 동작들은 메서드(methods)라고 불립니다. 메서드는 함수의 일종입니다.</p>
<p>질문 11.3</p>
<p><em>Image</em> 객체의 슬롯이 무엇인지, 그리고 어떤 메서드를 적용할 수 있는지 어떻게 알 수 있나요?</p>
<p>해결책</p>
<p>클래스 정의는 간단합니다. <code>showClass("Image")</code>로 접근할 수 있습니다. R 함수 호출을 통해 <em>Image</em> 클래스에 적용 가능한 모든 메서드를 찾는 것은 번거로운 일입니다. 가장 좋은 방법은 클래스의 매뉴얼 페이지를 참조하여 저자가 언급하기로 선택한 메서드를 확인하는 것입니다.</p>
<p>이미지의 차원은 일반적인 배열과 마찬가지로 <code>dim</code> 메서드를 사용하여 추출할 수 있습니다.</p>
<pre><code>dim(mosq)


[1] 1400  952</code></pre>
<p><code>hist</code> 메서드는 배열에 대한 일반적인 <code>hist</code> 함수에 비해 재정의되었습니다2. 이는 서로 다르며 아마도 더 유용한 기본값을 사용합니다(그림 11.4).</p>
<p>2 객체 지향 용어로는 오버로드(overloaded)라고 합니다.</p>
<pre><code>hist(mosq)</code></pre>
<p><a href="11-chap_files/figure- html/fig-mosqhist-1.png" title="그림 11.4: mosq의 픽셀 강도 히스토그램. 범위가 0과 1 사이임에 주목하세요."><img src="11-chap_files/figure-html/fig-mosqhist-1.png" class="img-fluid"></a></p>
<p>그림 11.4: <code>mosq</code>의 픽셀 강도 히스토그램. 범위가 0과 1 사이임에 주목하세요.</p>
<p>데이터 행렬에 R <em>array</em> 로 직접 접근하고 싶다면, 접근자 함수 <code>imageData</code>를 사용할 수 있습니다.</p>
<pre><code>imageData(mosq)[1:3, 1:6]


          [,1]      [,2]      [,3]      [,4]      [,5]      [,6]
[1,] 0.1960784 0.1960784 0.1960784 0.1960784 0.1960784 0.1960784
[2,] 0.1960784 0.1960784 0.1960784 0.1960784 0.1960784 0.1960784
[3,] 0.1960784 0.1960784 0.2000000 0.2039216 0.2000000 0.1960784</code></pre>
<p>단순히 객체의 이름을 입력하면 <em>Image</em> 객체에 대한 유용한 요약 정보가 출력됩니다.</p>
<pre><code>mosq


Image 
  colorMode    : Grayscale 
  storage.mode : double 
  dim          : 1400 952 
  frames.total : 1 
  frames.render: 1 

imageData(object)[1:5,1:6]
          [,1]      [,2]      [,3]      [,4]      [,5]      [,6]
[1,] 0.1960784 0.1960784 0.1960784 0.1960784 0.1960784 0.1960784
[2,] 0.1960784 0.1960784 0.1960784 0.1960784 0.1960784 0.1960784
[3,] 0.1960784 0.1960784 0.2000000 0.2039216 0.2000000 0.1960784
[4,] 0.1960784 0.1960784 0.2039216 0.2078431 0.2000000 0.1960784
[5,] 0.1960784 0.2000000 0.2117647 0.2156863 0.2000000 0.1921569</code></pre>
<p>이제 컬러 이미지를 살펴봅시다.</p>
<pre><code>hivc


Image 
  colorMode    : Color 
  storage.mode : double 
  dim          : 1400 930 3 
  frames.total : 3 
  frames.render: 1 

imageData(object)[1:5,1:6,1]
     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    0    0    0    0    0    0
[2,]    0    0    0    0    0    0
[3,]    0    0    0    0    0    0
[4,]    0    0    0    0    0    0
[5,]    0    0    0    0    0    0</code></pre>
<p>두 이미지는 <code>colorMode</code> 속성에서 차이가 납니다. <code>mosq</code>는 <code>Grayscale</code>이고 <code>hivc</code>는 <code>Color</code>입니다. 이 속성의 요점은 무엇일까요? 이미지 스택(stacks)을 다룰 때 편리하다는 것이 밝혀졌습니다. 만약 <code>colorMode</code>가 <code>Grayscale</code>이라면, 배열의 세 번째 이상의 모든 차원은 예를 들어 서로 다른 (z)-위치, 시점, 반복 실험 등에 해당하는 별개의 이미지 프레임으로 간주됩니다. 반면에 <code>colorMode</code>가 <code>Color</code>라면, 세 번째 차원은 서로 다른 색상 채널을 갖는 것으로 간주되며, 네 번째 이상의 차원만이 –존재한다면– 여러 이미지 프레임을 위해 사용됩니다. <code>hivc</code>에는 사진의 빨간색, 녹색, 파란색 강도에 해당하는 세 개의 색상 채널이 있습니다. 하지만 이것이 반드시 그럴 필요는 없으며, 색상 채널의 수는 얼마든지 될 수 있습니다.</p>
<p>질문 11.4</p>
<p>R이 데이터 <code>nuc</code>를 어떻게 저장하는지 설명하세요.</p>
<p>해결책</p>
<pre><code>nuc


Image 
  colorMode    : Grayscale 
  storage.mode : double 
  dim          : 510 510 4 
  frames.total : 4 
  frames.render: 4 

imageData(object)[1:5,1:6,1]
           [,1]       [,2]       [,3]       [,4]       [,5]       [,6]
[1,] 0.06274510 0.07450980 0.07058824 0.08235294 0.10588235 0.09803922
[2,] 0.06274510 0.05882353 0.07843137 0.09019608 0.09019608 0.10588235
[3,] 0.06666667 0.06666667 0.08235294 0.07843137 0.09411765 0.09411765
[4,] 0.06666667 0.06666667 0.07058824 0.08627451 0.08627451 0.09803922
[5,] 0.05882353 0.06666667 0.07058824 0.08235294 0.09411765 0.10588235


dim(imageData(nuc))


[1] 510 510   4</code></pre>
<p>우리는 총 4개의 프레임을 가지고 있음을 알 수 있으며, 이는 4개의 개별 이미지(<code>frames.render</code>)에 해당합니다.</p>
</section>
<section id="이미지-파일-쓰기" class="level2" data-number="13.5">
<h2 data-number="13.5" class="anchored" data-anchor-id="이미지-파일-쓰기"><span class="header-section-number">13.5</span> 11.5 이미지 파일 쓰기</h2>
<p>이전 섹션에서 보았던 배열 표현 그대로 이미지를 디스크에 저장하는 것은 불필요하게 큰 파일 크기를 초래할 수 있습니다. 저장 공간 소비를 줄이기 위해 압축 알고리즘을 사용하는 것이 일반적입니다. 이미지 압축 3에는 크게 두 가지 유형이 있습니다:</p>
<p>3 유추하자면 영화와 음악도 마찬가지입니다.</p>
<ul>
<li><p>무손실 압축(Lossless compression): 압축된 파일로부터 원래의 이미지 데이터를 정확하게 재구성할 수 있습니다. 무손실 압축의 간단한 원리는 다음과 같습니다: (1) 픽셀을 표현하는 데 필요한 것보다 많은 비트를 소비하지 않습니다(예: <code>mosq</code> 이미지의 픽셀은 256단계의 회색조 범위를 가지며 이는 8비트로 표현될 수 있지만, <code>mosq</code>는 이를 64비트 수치 형식으로 저장합니다 4). (2) 패턴을 식별하고(앞서 출력된 <code>mosq</code>와 <code>hivc</code>의 픽셀 값에서 본 것과 같은), 이를 훨씬 짧은 규칙으로 대신 표현합니다.</p></li>
<li><p>손실 압축(Lossy compression): 어차피 인간 관찰자가 알아채지 못할 것 같은 세부 사항들을 버림으로써 무손실 압축에 비해 추가적인 절감을 이뤄냅니다.</p></li>
</ul>
<p>4 비록 이것이 메모리 측면에서는 어느 정도 낭비일 수 있지만, R의 나머지 작동 방식과 더 호환되며 현대 컴퓨터 하드웨어에서 제한 요인이 되는 경우는 드뭅니다.</p>
<p>무손실 압축을 사용하는 저장 형식의 예로는 PNG 5가 있고, 손실 압축의 예로는 JPEG 6 형식이 있습니다. JPEG는 여러분의 휴가 사진에는 좋지만, 과학적 이미지는 무손실 형식으로 저장하는 것이 좋은 습관입니다.</p>
<p>우리는 PNG 형식의 파일에서 이미지 <code>hivc</code>를 읽었으므로, 이제 이를 JPEG 파일로 써봅시다. 손실 정도는 1(최악)에서 100(최선) 사이의 값을 갖는 <em>quality</em> 매개변수로 지정됩니다.</p>
<pre><code>output_file = file.path(tempdir(), "hivc.jpeg")
writeImage(hivc, output_file, quality = 85)</code></pre>
<p>유사하게, 우리는 이미지를 <code>TIFF</code> 파일로 쓸 수도 있었고 여러 압축 알고리즘 중에서 선택할 수 있었습니다(<code>writeImage</code>와 <code>writeTiff</code> 함수의 매뉴얼 페이지 참조). <strong>RBioFormats</strong> 패키지를 사용하면 더 많은 이미지 파일 형식으로 쓸 수 있습니다.</p>
<p>질문 11.5</p>
<p>R의 메모리에서 <code>hivc</code> 객체의 크기는 얼마인가요? JPEG 파일의 크기는요? 3가지 색상의 1600만 화소(Megapixel) 이미지가 차지할 것으로 예상되는 RAM 용량은 얼마인가요?</p>
<p>해결책</p>
<pre><code>object.size(hivc) |&gt; format(units = "Mb")


[1] "29.8 Mb"


(object.size(hivc) / prod(dim(hivc))) |&gt; format() |&gt; paste("per pixel")


[1] "8 bytes per pixel"


file.info( output_file )$size


[1] 294904


16 * 3 * 8


[1] 384</code></pre>
<p>5 https://en.wikipedia.org/wiki/Portable_Network_Graphics 6 https://en.wikipedia.org/wiki/JPEG</p>
</section>
<section id="이미지-조작" class="level2" data-number="13.6">
<h2 data-number="13.6" class="anchored" data-anchor-id="이미지-조작"><span class="header-section-number">13.6</span> 11.6 이미지 조작</h2>
<p>이제 이미지가 R에서 숫자 배열로 저장된다는 것을 알았으므로, 이미지를 조작하는 방법이 명확해졌습니다 – 간단한 대수학입니다! 예를 들어, 그림 11.5a에 다시 표시된 원래 이미지를 가져와서 이미지에 -1을 곱함으로써 밝은 영역을 어둡게, 어두운 영역을 밝게 뒤집을 수 있습니다 (그림 11.5b).</p>
<pre><code>mosqinv = normalize(-mosq)</code></pre>
<p>질문 11.6</p>
<p><code>normalize</code> 함수는 무엇을 하나요?</p>
<p>우리는 또한 곱셈을 통해 대비를 조정할 수 있고 (그림 11.5c), 거듭제곱 변환을 통해 감마 인자를 조정할 수 있습니다 (그림 11.5d).</p>
<pre><code>mosqcont = mosq * 3
mosqexp = mosq ^ (1/3)</code></pre>
<p><a href="11-chap_files/figure- html/fig-manip1-1.jpeg" title="그림 11.5 (a):"><img src="11-chap_files/figure-html/fig-manip1-1.jpeg" class="img-fluid"></a></p>
<ol type="a">
<li></li>
</ol>
<p><a href="11-chap_files/figure- html/fig-manip1-2.jpeg" title="그림 11.5 (b):"><img src="11-chap_files/figure-html/fig-manip1-2.jpeg" class="img-fluid"></a></p>
<ol start="2" type="a">
<li></li>
</ol>
<p><a href="11-chap_files/figure- html/fig-manip1-3.jpeg" title="그림 11.5 (c):"><img src="11-chap_files/figure-html/fig-manip1-3.jpeg" class="img-fluid"></a></p>
<ol start="3" type="a">
<li></li>
</ol>
<p><a href="11-chap_files/figure- html/fig-manip1-4.jpeg" title="그림 11.5 (d):"><img src="11-chap_files/figure-html/fig-manip1-4.jpeg" class="img-fluid"></a></p>
<ol start="4" type="a">
<li></li>
</ol>
<p>그림 11.5: 원래의 모기 이미지 (a)와 세 가지 서로 다른 이미지 변환: (b) 뺄셈, (c) 곱셈, (d) 거듭제곱 변환.</p>
<p>더 나아가, 우리는 행렬 연산을 통해 이미지를 자르고(crop), 임계값 처리(threshold)하고, 전치(transpose)할 수 있습니다 (그림 11.6).</p>
<pre><code>mosqcrop   = mosq[100:438, 112:550]
mosqthresh = mosq &gt; 0.5
mosqtransp = transpose(mosq)</code></pre>
<p><a href="11-chap_files/figure- html/fig-manip5-1.png" title="그림 11.6 (a):"><img src="11-chap_files/figure-html/fig-manip5-1.png" class="img-fluid"></a></p>
<ol type="a">
<li></li>
</ol>
<p><a href="11-chap_files/figure- html/fig-manip5-2.png" title="그림 11.6 (b):"><img src="11-chap_files/figure-html/fig-manip5-2.png" class="img-fluid"></a></p>
<ol start="2" type="a">
<li></li>
</ol>
<p><a href="11-chap_files/figure- html/fig-manip5-3.png" title="그림 11.6 (c):"><img src="11-chap_files/figure-html/fig-manip5-3.png" class="img-fluid"></a></p>
<ol start="3" type="a">
<li></li>
</ol>
<p>그림 11.6: 세 가지 추가 이미지 변환: (a) 자르기, (b) 임계값 처리, (c) 전치.</p>
<p>질문 11.7</p>
<p>임계값 처리의 결과인 <code>mosqthresh</code>는 어떤 데이터 유형인가요?</p>
<p>해결책</p>
<p>픽셀이 R의 <em>logical</em> 유형 배열로 표현된 이진 값을 가지는 <em>Image</em> 객체입니다. 콘솔에 객체 이름을 입력하여 확인할 수 있습니다.</p>
<pre><code>mosqthresh


Image 
  colorMode    : Grayscale 
  storage.mode : logical 
  dim          : 1400 952 
  frames.total : 1 
  frames.render: 1 

imageData(object)[1:5,1:6]
      [,1]  [,2]  [,3]  [,4]  [,5]  [,6]
[1,] FALSE FALSE FALSE FALSE FALSE FALSE
[2,] FALSE FALSE FALSE FALSE FALSE FALSE
[3,] FALSE FALSE FALSE FALSE FALSE FALSE
[4,] FALSE FALSE FALSE FALSE FALSE FALSE
[5,] FALSE FALSE FALSE FALSE FALSE FALSE</code></pre>
<p>질문 11.8</p>
<p>위와 같이 <code>transpose</code> 함수를 사용하는 대신, R의 <strong><a href="https://cran.r-project.org/web/packages/base/">base</a></strong> 함수 <code>t</code>를 사용할 수도 있을까요?</p>
<p>해결책</p>
<p>이 경우 <code>t(mosq)</code>와 <code>transpose(mosq)</code>의 값은 동일하지만, <code>transpose</code>는 컬러 및 다중 프레임 이미지에서도 작동하므로 더 선호됩니다.</p>
</section>
<section id="공간-변환" class="level2" data-number="13.7">
<h2 data-number="13.7" class="anchored" data-anchor-id="공간-변환"><span class="header-section-number">13.7</span> 11.7 공간 변환</h2>
<p>우리는 방금 공간 변환의 한 유형인 전치를 보았지만, 그 외에도 많은 변환이 있습니다. 여기에 몇 가지 예시가 있습니다:</p>
<pre><code>mosqrot   = EBImage::rotate(mosq, angle = 30)
mosqshift = EBImage::translate(mosq, v = c(100, 170))
mosqflip  = flip(mosq)
mosqflop  = flop(mosq)</code></pre>
<p><a href="11-chap_files/figure- html/fig-flipflop-1.jpeg" title="그림 11.7 (a):"><img src="11-chap_files/figure-html/fig-flipflop-1.jpeg" class="img-fluid"></a></p>
<ol type="a">
<li></li>
</ol>
<p><a href="11-chap_files/figure- html/fig-flipflop-2.jpeg" title="그림 11.7 (b):"><img src="11-chap_files/figure-html/fig-flipflop-2.jpeg" class="img-fluid"></a></p>
<ol start="2" type="a">
<li></li>
</ol>
<p><a href="11-chap_files/figure- html/fig-flipflop-3.jpeg" title="그림 11.7 (c):"><img src="11-chap_files/figure-html/fig-flipflop-3.jpeg" class="img-fluid"></a></p>
<ol start="3" type="a">
<li></li>
</ol>
<p><a href="11-chap_files/figure- html/fig-flipflop-4.jpeg" title="그림 11.7 (d):"><img src="11-chap_files/figure-html/fig-flipflop-4.jpeg" class="img-fluid"></a></p>
<ol start="4" type="a">
<li></li>
</ol>
<p>그림 11.7: 공간 변환: (a) 회전, (b) 이동, (c) 중앙 수평축에 대한 반전(<code>flip</code>), (d) 중앙 수직축에 대한 반전(<code>flop</code>).</p>
<p>위 코드에서 <code>rotate</code> 7 함수는 주어진 각도만큼 이미지를 시계 방향으로 회전시키고, <code>translate</code>는 지정된 2차원 벡터만큼 이미지를 이동시킵니다(이미지 영역 밖으로 나가는 픽셀은 잘려나가고, 이미지 영역으로 들어오는 픽셀은 0으로 설정됩니다). <code>flip</code>과 <code>flop</code> 함수는 각각 이미지를 중앙 수평축과 수직축을 기준으로 반사시킵니다. 이러한 연산들의 결과가 그림 11.7에 나와 있습니다.</p>
<p>7 나중에 첨부할 <strong><a href="https://cran.r-project.org/web/packages/spatstat/">spatstat</a></strong> 패키지의 동일한 이름의 함수와 혼동을 피하기 위해 여기서는 네임스페이스 수식어 <code>EBImage::</code>를 붙여 호출합니다.</p>
</section>
<section id="선형-필터" class="level2" data-number="13.8">
<h2 data-number="13.8" class="anchored" data-anchor-id="선형-필터"><span class="header-section-number">13.8</span> 11.8 선형 필터</h2>
<p>이제 세포 생물학 분야의 응용으로 넘어가 봅시다. Laufer, Fischer 및 동료들에 의해 연구된 인간 암세포 이미지를 로드합니다 (<a href="16-chap.html#ref-Laufer:NatMeth:2013">Laufer et al.&nbsp;2013</a>). 이들은 그림 11.8에 나와 있습니다.</p>
<pre><code>imagefiles = system.file("images", c("image-DAPI.tif", "image-FITC.tif", "image-Cy3.tif"), package = "MSMB")
cells = readImage(imagefiles)</code></pre>
<p><a href="11-chap_files/figure- html/fig-LauferCells-1.png" title="그림 11.8: 인간 대장암 세포(HCT116). 네 개의 이미지는 동일한 세포들을 보여줍니다: 가장 왼쪽 이미지는 세포 DNA의 DAPI 염색에 대응하고, 두 번째는 알파-튜불린에 대한 면역 염색, 세 번째는 액틴에 대응합니다. 이들은 회색조 이미지로 표시됩니다. 가장 오른쪽 이미지는 세 이미지를 RGB 이미지의 색상 채널(빨강: 액틴, 초록: 알파-튜불린, 파랑: DNA)로 겹쳐서 얻은 것입니다."><img src="11-chap_files/figure-html/fig-LauferCells-1.png" class="img-fluid"></a></p>
<p>그림 11.8: 인간 대장암 세포(HCT116). 네 개의 이미지는 동일한 세포들을 보여줍니다: 가장 왼쪽 이미지는 세포 DNA의 DAPI 염색에 대응하고, 두 번째는 알파-튜불린에 대한 면역 염색, 세 번째는 액틴에 대응합니다. 이들은 회색조 이미지로 표시됩니다. 가장 오른쪽 이미지는 세 이미지를 RGB 이미지의 색상 채널(빨강: 액틴, 초록: 알파-튜불린, 파랑: DNA)로 겹쳐서 얻은 것입니다.</p>
<p><em>Image</em> 객체 <code>cells</code>는 340 () 490 () 3 크기의 3차원 배열이며, 마지막 차원은 3개의 개별 회색조 프레임이 있음을 나타냅니다. 우리의 목표는 이제 이 이미지들에서 개별 세포들을 계산적으로 식별하고 정량적으로 특성화하는 것입니다. 그 자체로는 소박한 목표일 수 있지만, Laufer 등은 2,048 () 2,048 픽셀 크기의 이미지를 690,000개 이상 보유하고 있었습니다. 우리는 그중 작은 영역이 잘려진 3개를 보고 있는 것입니다. 일단 우리가 명시된 목표를 달성하는 방법을 알게 된다면, 우리는 이러한 방대한 이미지 컬렉션에 우리의 능력을 적용할 수 있으며, 그것은 더 이상 소박한 목표가 아닙니다!</p>
<section id="막간-이미지의-강도-스케일" class="level3" data-number="13.8.1">
<h3 data-number="13.8.1" class="anchored" data-anchor-id="막간-이미지의-강도-스케일"><span class="header-section-number">13.8.1</span> 11.8.1 막간: 이미지의 강도 스케일</h3>
<p>하지만 실제 작업을 시작하기 전에, 약간 지루한 데이터 변환 문제를 다루어야 합니다. 물론 이는 흔한 일입니다. 이미지의 동적 범위(최솟값과 최댓값)를 조사해 봅시다.</p>
<pre><code>apply(cells, 3, range)


      image-DAPI  image-FITC   image-Cy3
[1,] 0.001586938 0.002899214 0.001663233
[2,] 0.031204700 0.062485695 0.055710689</code></pre>
<p>최댓값들이 1보다 훨씬 작은 숫자임을 알 수 있습니다. 그 이유는 <code>readImage</code> 함수가 <code>TIFF</code> 이미지가 각 픽셀을 표현하기 위해 16비트 정수를 사용함을 인식하고, 데이터를 –R의 수치형 변수에서 흔히 그렇듯이– 배정밀도 부동 소수점 수 배열로 반환하기 때문입니다. 이때 정수 값(이론적 범위는 0에서 (2^{16}-1=65535)까지)은 부동 소수점 표현의 가수(mantissa)에 저장되고 지수는 이론적 범위가 구간 ([0,1])에 매핑되도록 선택됩니다. 하지만 이 이미지들을 생성하는 데 사용된 스캐너는 하위 11비트 또는 12비트만을 사용했으며, 이것이 이미지의 최댓값이 작은 이유입니다. 우리는 이 데이터를 다음과 같이 대략 ([0,1]) 범위를 덮도록 재조정할 수 있습니다 8.</p>
<p>8 <code>normalize</code> 함수는 이미지의 스케일 조정에 대해 더 유연한 인터페이스를 제공합니다.</p>
<pre><code>cells[,,1]   = 32 * cells[,,1]
cells[,,2:3] = 16 * cells[,,2:3]
apply(cells, 3, range)


     image-DAPI image-FITC  image-Cy3
[1,] 0.05078202 0.04638743 0.02661173
[2,] 0.99855039 0.99977111 0.89137102</code></pre>
<p>이러한 2의 배수 곱셈은 저장된 데이터의 기저 정밀도에는 아무런 영향을 주지 않는다는 점을 기억합시다.</p>
</section>
<section id="평활화를-통한-노이즈-감소" class="level3" data-number="13.8.2">
<h3 data-number="13.8.2" class="anchored" data-anchor-id="평활화를-통한-노이즈-감소"><span class="header-section-number">13.8.2</span> 11.8.2 평활화를 통한 노이즈 감소</h3>
<p>이제 이미지를 분석할 준비가 되었습니다. 우리의 첫 번째 목표는 개별 세포를 식별하기 위해 이미지를 분할하는 것이므로, 평활화(smoothing)를 통해 이미지에서 국소적인 아티팩트나 노이즈를 제거하는 것으로 시작할 수 있습니다. 직관적인 접근 방식은 각 픽셀 주변에 선택된 크기의 창(window)을 정의하고 그 창 안의 값들을 평균 내는 것입니다. 이 절차를 모든 픽셀에 적용한 후, 새로운 평활화된 이미지가 얻어집니다. 수학적으로 우리는 이를 다음과 같이 표현할 수 있습니다.</p>
<p>[ f^*(x,y) = <em>{s=-a}^{a}</em>{t=-a}^{a} f(x+s, y+t), ]</p>
<p>여기서 (f(x,y))는 좌표 (x), (y)에서의 픽셀 값이고, (a)는 각 방향으로 (2a+1)인 창의 크기를 결정합니다. (N=(2a+1)^2)은 평균을 낸 픽셀의 수이며, (f^*)는 새로운 평활화된 이미지입니다.</p>
<p>더 일반적으로, 이동 평균을 가중 평균으로 대체할 수 있으며, 가중치 함수 (w)를 사용합니다. (w)는 대개 창의 중간 지점((s=t=0))에서 가장 높은 가중치를 갖고 가장자리로 갈수록 감소합니다.</p>
<p>[ (w * f)(x,y) = <em>{s=-}^{+} </em>{t=-}^{+} w(s,t), f(x+s, y+s) ]</p>
<p>표기상의 편의를 위해 합산 범위를 (-)에서 ()까지로 두었지만, 실제로는 (w)가 유한한 수의 0이 아닌 값만을 가지므로 합은 유한합니다. 사실 우리는 가중치 함수 (w)를 또 다른 이미지로 생각할 수 있으며, 이 연산을 두 이미지 (f)와 (w)의 <strong>컨벌루션(convolution)</strong>이라고도 부르며 기호 (*)로 나타냅니다. <strong><a href="https://bioconductor.org/packages/EBImage/">EBImage</a></strong>에서 2차원 컨벌루션은 <code>filter2</code> 함수에 의해 구현되며, 보조 함수 <code>makeBrush</code>를 사용하여 가중치 함수 (w)를 생성할 수 있습니다.</p>
<pre><code>w = makeBrush(size = 51, shape = "gaussian", sigma = 7)
nucSmooth = filter2(getFrame(cells, 1), w)</code></pre>
<p><a href="11-chap_files/figure- html/fig-nucSmooth-1.png" title="그림 11.9: nucSmooth, 이미지 객체 cells의 DNA 채널을 평활화한 버전(원래 버전은 그림 11.8의 가장 왼쪽 패널에 나와 있습니다)."><img src="11-chap_files/figure-html/fig-nucSmooth-1.png" class="img-fluid"></a></p>
<p>그림 11.9: <code>nucSmooth</code>, 이미지 객체 <code>cells</code>의 DNA 채널을 평활화한 버전(원래 버전은 그림 11.8의 가장 왼쪽 패널에 나와 있습니다).</p>
<p>질문 11.9</p>
<p>가중치 행렬 <code>w</code>는 어떻게 생겼나요?</p>
<p>해결책</p>
<p>그림 11.10을 참조하세요.</p>
<pre><code>library("tibble")
library("ggplot2")
tibble(w = w[(nrow(w)+1)/2, ]) |&gt;
  ggplot(aes(y = w, x = seq(along = w))) + geom_point()</code></pre>
<p><a href="11-chap_files/figure- html/fig-image-filter2-1.png" title="그림 11.10: 가중치 행렬 w의 중간 행, w[26, ]."><img src="11-chap_files/figure-html/fig-image-filter2-1.png" class="img-fluid"></a></p>
<p>그림 11.10: 가중치 행렬 <code>w</code>의 중간 행, <code>w[</code>26<code>, ]</code>.</p>
<p>사실 <code>filter2</code> 함수는 식 11.2에 명시된 합산을 직접 수행하지 않습니다. 대신, 수학적으로 동일하면서도 계산적으로 더 효율적인 방식인 고속 푸리에 변환(Fast Fourier Transformation)을 사용합니다.</p>
<p>식 11.2의 컨벌루션은 임의의 두 이미지 (f_1, f_2)와 숫자 (c_1, c_2)에 대해 (w<em>(c_1f_1+c_2f_2)= c_1w</em>f_1 + c_2w*f_2)가 성립한다는 의미에서 <strong>선형(linear)</strong> 연산입니다. 선형 필터의 근간이 되는 아름답고 강력한 이론이 있습니다 (<a href="16-chap.html#ref-FoundationSignalProcessing">Vetterli, Kovačević, and Goyal 2014</a>).</p>
<p>계속 진행하기 위해, 이제 그림 11.9에서 시연을 위해 보여주었던 것보다 작은 평활화 대역폭을 사용합니다. DNA 채널에는 1픽셀, 액틴과 튜불린에는 3픽셀의 <code>sigma</code>를 사용합시다.</p>
<pre><code>cellsSmooth = Image(dim = dim(cells))
sigma = c(1, 3, 3)
for(i in seq_along(sigma))
  cellsSmooth[,,i] = filter2( cells[,,i],
         filter = makeBrush(size = 51, shape = "gaussian",
                            sigma = sigma[i]) )</code></pre>
<p>평활화된 이미지는 픽셀 노이즈가 감소하면서도 여전히 필요한 해상도를 유지합니다.</p>
</section>
</section>
<section id="적응형-임계값-처리" class="level2" data-number="13.9">
<h2 data-number="13.9" class="anchored" data-anchor-id="적응형-임계값-처리"><span class="header-section-number">13.9</span> 11.9 적응형 임계값 처리</h2>
<p>적응형 임계값 처리(adaptive thresholding)의 아이디어는, 그림 11.6b에서 했던 것과 같은 단순한 임계값 처리와 비교할 때, 이미지의 서로 다른 영역에서 임계값이 달라질 수 있도록 허용하는 것입니다. 이런 방식으로, 예를 들어 불균일한 조명이나 근처의 밝은 물체에서 새어 나오는 신호로 인해 발생하는 기저 배경 신호의 공간적 의존성을 예상할 수 있습니다. 사실 우리는 이미 그림 11.3의 오른쪽 하단 이미지에서 불균일한 배경의 예시를 보았습니다.</p>
<p>우리의 대장암 이미지(그림 11.8)에는 그러한 아티팩트가 없지만, 시연을 위해 중간이 가장 높고 측면으로 갈수록 떨어지는 2차원 벨 함수 <code>illuminationGradient</code>를 이미지에 곱하여 불균일한 조명을 시뮬레이션해 봅시다 (그림 11.11).</p>
<pre><code>py = seq(-1, +1, length.out = dim(cellsSmooth)[1])
px = seq(-1, +1, length.out = dim(cellsSmooth)[2])
illuminationGradient = Image(outer(py, px, function(x, y) exp(-(x^2 + y^2))))
nucBadlyIlluminated = cellsSmooth[,,1] * illuminationGradient</code></pre>
<p>우리는 이제 우리가 탐지하고자 하는 핵보다는 크지만 조명 아티팩트의 길이 스케일보다는 작은 21픽셀 크기의 평활화 창 <code>disc</code>를 정의합니다. 이를 사용하여 <code>localBackground</code> 이미지(그림 11.11 (c))와 임계값 처리된 이미지 <code>nucBadThresh</code>를 계산합니다.</p>
<pre><code>disc = makeBrush(21, "disc")
disc = disc / sum(disc)
localBackground = filter2(nucBadlyIlluminated, disc)
offset = 0.02
nucBadThresh = (nucBadlyIlluminated - localBackground &gt; offset)</code></pre>
<p><a href="11-chap_files/figure- html/fig-illumination-1.png" title="그림 11.11 (a):"><img src="11-chap_files/figure-html/fig-illumination-1.png" class="img-fluid"></a></p>
<ol type="a">
<li></li>
</ol>
<p><a href="11-chap_files/figure- html/fig-illumination-2.png" title="그림 11.11 (b):"><img src="11-chap_files/figure-html/fig-illumination-2.png" class="img-fluid"></a></p>
<ol start="2" type="a">
<li></li>
</ol>
<p><a href="11-chap_files/figure- html/fig-illumination-3.png" title="그림 11.11 (c):"><img src="11-chap_files/figure-html/fig-illumination-3.png" class="img-fluid"></a></p>
<ol start="3" type="a">
<li></li>
</ol>
<p><a href="11-chap_files/figure- html/fig-illumination-4.png" title="그림 11.11 (d):"><img src="11-chap_files/figure-html/fig-illumination-4.png" class="img-fluid"></a></p>
<ol start="4" type="a">
<li></li>
</ol>
<p>그림 11.11: a: <code>illuminationGradient</code>, 중앙에서 최댓값을 갖고 측면으로 갈수록 떨어지는 함수이며, 이미지에서 때때로 보이는 불균일한 조명을 시뮬레이션합니다. (b) <code>nucBadlyIlluminated</code>, <code>cellsSmooth</code>의 DNA 채널에 <code>illuminationGradient</code>를 곱한 결과 이미지. (c) <code>localBackground</code>, 탐지할 객체보다 큰 대역폭을 가진 선형 필터를 적용한 결과. (d) <code>nucBadThresh</code>, 적응형 임계값 처리 결과. 신호 강도의 감소에도 불구하고 이미지 주변부의 핵들이 상당히 잘 식별되었습니다.</p>
<p>이것이 효과가 있을 수 있음을 확인했으므로, 다음 단계들을 위해 실제(인위적으로 성능이 저하되지 않은) 이미지에 대해 동일한 작업을 다시 수행해 봅시다.</p>
<pre><code>nucThresh = (cellsSmooth[,,1] - filter2(cellsSmooth[,,1], disc) &gt; offset)</code></pre>
<p>각 픽셀의 강도를 국소 이웃에서 결정된 배경과 비교함으로써, 우리는 객체들이 이미지에 상대적으로 드문드문 분포되어 있어 이웃의 신호 분포가 배경에 의해 지배된다고 가정합니다. 우리 이미지의 핵들에 대해서는 이 가정이 타당하지만, 다른 상황에서는 다른 가정을 세워야 할 수도 있습니다. 우리가 여기서 수행한 적응형 임계값 처리는 선형 필터인 <code>filter2</code>를 사용하므로 (가중) 국소 평균화에 해당합니다. 비록 계산 비용은 더 많이 들지만, 중앙값(median)이나 낮은 분위수와 같은 다른 분포 요약 수치들이 더 선호되는 경향이 있습니다. 국소 중앙값 필터링을 위해 <strong><a href="https://bioconductor.org/packages/EBimage/">EBimage</a></strong>는 <code>medianFilter</code> 함수를 제공합니다.</p>
</section>
<section id="이진-이미지에-대한-형태학적-연산" class="level2" data-number="13.10">
<h2 data-number="13.10" class="anchored" data-anchor-id="이진-이미지에-대한-형태학적-연산"><span class="header-section-number">13.10</span> 11.10 이진 이미지에 대한 형태학적 연산</h2>
<p>임계값 처리된 이미지 <code>nucThresh</code>(그림 11.12a에 표시됨)는 아직 만족스럽지 않습니다. 핵의 경계가 약간 울퉁불퉁하고 단일 픽셀 수준의 노이즈가 있습니다. 이러한 방해 요소들을 제거하는 효과적이고 간단한 방법이 일련의 형태학적 연산(morphological operations)에 의해 제공됩니다 (<a href="16-chap.html#ref-MathematicalMorphology">Serra 1983</a>).</p>
<p>이진 이미지(예를 들어 배경과 전경 픽셀을 나타내는 0과 1의 값을 가짐)와 이른바 구조화 요소(structuring element)라고도 불리는 이진 마스크(mask) 9가 주어졌을 때, 이러한 연산들은 다음과 같이 작동합니다.</p>
<p>9 마스크의 예로는 주어진 반지름을 가진 원, 또는 더 정확하게는 중심 픽셀로부터 특정 거리 내에 있는 픽셀들의 집합이 있습니다.</p>
<ul>
<li><p><code>erode</code>(침식): 모든 전경 픽셀에 대해 그 주변에 마스크를 놓고, 만약 마스크 아래의 픽셀 중 하나라도 배경에 해당하면 해당 전경 픽셀들을 모두 배경으로 설정합니다.</p></li>
<li><p><code>dilate</code>(팽창): 모든 배경 픽셀에 대해 그 주변에 마스크를 놓고, 만약 마스크 아래의 픽셀 중 하나라도 전경에 해당하면 해당 배경 픽셀들을 모두 전경으로 설정합니다.</p></li>
<li><p><code>open</code>(열기): <code>erode</code>를 수행한 후 이어서 <code>dilate</code>를 수행합니다.</p></li>
</ul>
<p>우리는 이러한 연산들을 필터로 생각할 수도 있지만, 11.8절의 선형 필터와 대조적으로 이들은 이진 이미지에서만 작동하며 선형성이 없습니다.</p>
<p>우리의 이미지에 형태학적 열기 연산을 적용해 봅시다.</p>
<pre><code>nucOpened = EBImage::opening(nucThresh, kern = makeBrush(5, shape = "disc"))</code></pre>
<p>이 결과는 미묘하며, 그림 11.12에서 차이점을 찾으려면 이미지를 확대해 보아야 할 것입니다. 하지만 이 연산은 이진 이미지에서 우리 응용 목적상 바람직하지 않은 일부 픽셀 수준의 특징들을 평활화하는 데 성공합니다.</p>
</section>
<section id="이진-이미지를-객체로-분할" class="level2" data-number="13.11">
<h2 data-number="13.11" class="anchored" data-anchor-id="이진-이미지를-객체로-분할"><span class="header-section-number">13.11</span> 11.11 이진 이미지를 객체로 분할</h2>
<p>이진 이미지 <code>nucOpened</code>는 이미지를 전경과 배경 픽셀로 분할한 것이지, 개별 핵으로 분할한 것은 아닙니다. 우리는 한 단계 더 나아가 연결된 픽셀 세트로 정의된 개별 객체들을 추출할 수 있습니다. <strong><a href="https://bioconductor.org/packages/EBImage/">EBImage</a></strong>에는 이 목적을 위한 편리한 함수인 <code>bwlabel</code>이 있습니다.</p>
<pre><code>nucSeed = bwlabel(nucOpened)
table(nucSeed)


nucSeed
     0      1      2      3      4      5      6      7      8      9     10 
155408    511    330    120    468    222    121    125    159    116    520 
    11     12     13     14     15     16     17     18     19     20     21 
   115    184    179    116    183    187    303    226    164    309    194 
    22     23     24     25     26     27     28     29     30     31     32 
   148    345    287    203    379    371    208    222    320    443    409 
    33     34     35     36     37     38     39     40     41     42     43 
   493    256    169    225    376    214    228    341    269    119    315 </code></pre>
<p>이 함수는 0이 배경을 나타내고 1부터 43까지의 숫자가 식별된 서로 다른 객체들을 인덱싱하는 정수 값 이미지 <code>nucSeed</code>를 반환합니다.</p>
<p>질문 11.10</p>
<p>위 테이블의 숫자들은 무엇을 의미하나요?</p>
<p>해결책</p>
<p>이들은 각 객체의 면적(픽셀 단위)에 해당합니다. 우리는 우리가 예상하는 것과 비교하여 너무 크거나 작은 객체들을 제거하는 데 이 정보를 사용할 수 있습니다.</p>
<p>그러한 이미지들을 시각화하기 위해, (회색조) 정수 이미지를 각 객체마다 임의로 선택된 서로 다른 색상을 사용하여 컬러 이미지로 변환해 주는 <code>colorLabels</code> 함수가 편리합니다.</p>
<pre><code>EBImage::display(colorLabels(nucSeed))</code></pre>
<p>이것은 그림 11.12의 중간 패널에 나와 있습니다. 결과는 이미 고무적이지만, 두 가지 유형의 오류를 발견할 수 있습니다:</p>
<ul>
<li><p>일부 인접한 객체들이 제대로 분리되지 않았습니다.</p></li>
<li><p>일부 객체들이 구멍을 포함하고 있습니다.</p></li>
</ul>
<p>사실 우리는 11.9절에서 평활화 창 크기와 <code>offset</code> 매개변수를 조절하여 이러한 오류의 발생 빈도를 바꿀 수 있습니다: 오프셋을 높이면 두 인접한 객체가 닿아서 <code>bwlabel</code>에 의해 하나의 객체로 간주될 확률이 줄어들지만, 반면에 구멍이 더 많이 그리고 더 크게 생기게 됩니다. 반대로 낮추는 것도 마찬가지입니다.</p>
<p>분할(Segmentation)은 광범위한 문헌, 소프트웨어 도구 (<a href="16-chap.html#ref-schindelin2012fiji">Schindelin et al.&nbsp;2012</a>; <a href="16-chap.html#ref-chaumont2012icy">Chaumont et al.&nbsp;2012</a>; <a href="16-chap.html#ref-carpenter2006cellprofiler">Carpenter et al.&nbsp;2006</a>; <a href="16-chap.html#ref-held2010cellcognition">Held et al.&nbsp;2010</a>), 그리고 이미지 분석 및 기계 학습 커뮤니티의 실무 경험이 축적된 풍부하고 다양한 연구 및 공학 분야입니다. 주어진 작업에 적합한 접근 방식이 무엇인지는 데이터와 기저의 질문에 크게 좌우되며, 모든 경우에 최선인 유일한 방법은 없습니다. 일반적으로 분석을 평가하기 위한 “실측 자료(ground truth)”나 “표준(gold standards)”을 얻는 것조차 어려우며 – 적은 수의 선택된 이미지에 대한 수동 주석 처리에 의존하는 것도 드문 일이 아닙니다. 비록 당혹스러울 정도로 많은 선택지들이 있지만, 시작하는 것은 쉽습니다. 우리는 단순한 해결책으로 시작하는 것을 두려워할 필요가 없으며, 이를 점진적으로 개선해 나갈 수 있습니다. 식별될 객체들의 예상되는 모양, 크기 및 객체 간의 관계에 대한 사전 지식을 더 많이 포함할 수 있는 방법들을 통해 대개 개선을 얻을 수 있습니다.</p>
<p>고처리량 이미지의 통계 분석을 위해, 우리는 너무 많은 매개변수나 가정에 의존하지 않으면서 아마도 최적은 아닐지라도 신속하고 충분히 좋은 결과를 내는 단순한 방법에 만족하기로 선택할 수도 있습니다 (<a href="16-chap.html#ref-PhenoRipper">Rajaram et al.&nbsp;2012</a>). 이러한 정신으로 우리가 가진 것을 가지고 계속 진행해 봅시다. 우리는 모든 핵 염색 영역을 확실히 커버하되 핵 사이의 일부 영역도 커버하는 관대한 전경 마스크를 생성합니다. 이를 위해 단순히 덜 엄격한 두 번째 적 적응형 임계값 처리를 적용합니다.</p>
<pre><code>nucMask = cellsSmooth[,,1] - filter2(cellsSmooth[,,1], disc) &gt; 0</code></pre>
<p>그리고 전경 픽셀로 둘러싸인 구멍들을 채워주는 또 다른 형태학적 연산인 <code>fillHull</code>을 적용합니다.</p>
<pre><code>nucMask = fillHull(nucMask)</code></pre>
<p><code>nucSeed</code>를 개선하기 위해, 이제 우리는 <code>nucMask</code>에 의해 정의된 마스크를 채울 때까지 식별된 객체들을 _전파(propagate)_시킬 수 있습니다. 마스크가 연결된 부분에서의 핵 사이의 경계는 다음 섹션에서 설명할 보로노이 테셀레이션(Voronoi tessellation)에 의해 그려질 수 있으며, 이는 <code>propagate</code> 함수에 구현되어 있습니다.</p>
<pre><code>nuclei = propagate(cellsSmooth[,,1], nucSeed, mask = nucMask)</code></pre>
<p>그 결과는 그림 11.12의 가장 오른쪽 패널에 표시되어 있습니다.</p>
<p><a href="11-chap_files/figure- html/fig-morphop-1.png" title="그림 11.12 (a):"><img src="11-chap_files/figure-html/fig-morphop-1.png" class="img-fluid"></a></p>
<ol type="a">
<li></li>
</ol>
<p><a href="11-chap_files/figure- html/fig-morphop-2.png" title="그림 11.12 (b):"><img src="11-chap_files/figure-html/fig-morphop-2.png" class="img-fluid"></a></p>
<ol start="2" type="a">
<li></li>
</ol>
<p><a href="11-chap_files/figure- html/fig-morphop-3.png" title="그림 11.12 (c):"><img src="11-chap_files/figure-html/fig-morphop-3.png" class="img-fluid"></a></p>
<ol start="3" type="a">
<li></li>
</ol>
<p><a href="11-chap_files/figure- html/fig-morphop-4.png" title="그림 11.12 (d):"><img src="11-chap_files/figure-html/fig-morphop-4.png" class="img-fluid"></a></p>
<ol start="4" type="a">
<li></li>
</ol>
<p><a href="11-chap_files/figure- html/fig-morphop-5.png" title="그림 11.12 (e):"><img src="11-chap_files/figure-html/fig-morphop-5.png" class="img-fluid"></a></p>
<ol start="5" type="a">
<li></li>
</ol>
<p>그림 11.12: 핵 분할의 서로 다른 단계들. (a-e): <code>nucThresh</code>, <code>nucOpened</code>, <code>nucSeed</code>, <code>nucMask</code>, <code>nuclei</code>.</p>
</section>
<section id="보로노이-테셀레이션" class="level2" data-number="13.12">
<h2 data-number="13.12" class="anchored" data-anchor-id="보로노이-테셀레이션"><span class="header-section-number">13.12</span> 11.12 보로노이 테셀레이션</h2>
<p>보로노이 테셀레이션(Voronoi tessellation)은 일련의 시드(seed) 점들(또는 영역들)이 있고 시드들 사이에 놓인 공간을 각 공간 상의 점이 가장 가까운 시드에 할당되도록 분할하고 싶을 때 유용합니다. 이것은 직관적이고 강력한 아이디어이므로, 이 섹션에서 이에 대해 잠시 곁가지로 다뤄보겠습니다. 기본적인 예시를 고려해 봅시다. 우리는 <code>nuclei</code> 이미지를 시드로 사용합니다. <code>propagate</code> 함수를 호출하려면 다른 이미지도 지정해야 합니다: 지금은 단순히 모든 값이 0인 이미지(<code>zeros</code>)를 제공하고, <code>lambda</code> 매개변수를 큰 양수값으로 설정합니다(이 선택들에 대해서는 나중에 다시 다룰 것입니다).</p>
<pre><code>zeros        = Image(dim = dim(nuclei))
voronoiExamp = propagate(seeds = nuclei, x = zeros, lambda = 100)
voronoiPaint = paintObjects(voronoiExamp, 1 - nucOpened)</code></pre>
<p><a href="11-chap_files/figure- html/fig-voronoiPaint-1.png" title="그림 11.13: 핵(검은색 영역으로 표시됨)을 시드로 사용한 보로노이 분할 예시이며 회색 선으로 표시됩니다."><img src="11-chap_files/figure-html/fig-voronoiPaint-1.png" class="img-fluid"></a></p>
<p>그림 11.13: 핵(검은색 영역으로 표시됨)을 시드로 사용한 보로노이 분할 예시이며 회색 선으로 표시됩니다.</p>
<p>질문 11.11</p>
<p>테셀레이션에서 분할 요소를 어떻게 선택하나요?</p>
<p>해결책</p>
<p>위의 <code>propagate</code> 호출 결과인 <code>voronoiExamp</code>는 단순히 값이 서로 다른 분할들을 나타내는 정수 이미지입니다.</p>
<pre><code>head(table(voronoiExamp))


voronoiExamp
   1    2    3    4    5    6 
5645 4735  370 5964 3333 1377 


ind = which(voronoiExamp == 13, arr.ind = TRUE)
head(ind, 3)


     row col
[1,] 112 100
[2,] 113 100
[3,] 114 100</code></pre>
<p>그 결과는 그림 11.13에 나와 있습니다. 이것은 흥미로워 보이지만, 아마도 그림 11.12의 <code>nuclei</code> 이미지만큼 유용하지는 않을 것입니다. 우리는 보로노이 테셀레이션의 기본 정의에서 두 가지 일반화가 가능하다는 점에 주목합니다:</p>
<ul>
<li><p>기본적으로 우리가 분할하는 공간은 전체 직사각형 이미지 영역이지만 – 사실 우리는 어떤 임의의 하위 공간으로도 자신을 제한할 수 있습니다. 이는 각 점으로부터 다음 시드까지의 최단 거리를 단순한 평면이 아니라, (가로지를 수 없는) 호수와 강이 산재한 지형에서 모든 경로가 육지 위에 남아 있어야 하는 조건 하에서 찾는 것과 비슷합니다. <code>propagate</code>는 <code>mask</code> 매개변수를 통해 이러한 일반화를 가능하게 합니다.</p></li>
<li><p>기본적으로 우리는 공간을 평평하다고 생각하지만 – 사실 공간은 언덕과 협곡을 가질 수 있으며, 따라서 지형 상의 두 점 사이의 거리는 그들의 (x)- 및 (y)-위치뿐만 아니라 그 사이에 놓인 (z)-방향의 오르막과 내리막인 “고도”에도 의존합니다. 여러분은 <code>propagate</code>의 <code>x</code> 인수를 통해 그러한 지형을 지정할 수 있습니다.</p></li>
</ul>
<p>수학적으로 말하자면, 우리는 단순한 기본 사례(위에 유클리드 메트릭이 있는 평평한 직사각형 또는 이미지) 대신, 특수한 형태와 메트릭을 가진 리만 다양체(Riemann manifold) 위에서 보로노이 분할을 수행하는 것입니다. 이미지의 열과 행 좌표에 대해 (x)와 (y) 표기법을 사용하고 고도에 대해 (z)를 사용합시다. 좌표 ((x, y, z))와 ((x+x, y+y, z+z))로 정의되는 인접한 두 점 사이의 거리 (s)는 일반적인 2D 이미지 상의 유클리드 메트릭인</p>
<p>[ s^2 = x^2 + y^2 ]</p>
<p>이 아니라 대신 다음과 같이 얻어집니다.</p>
<p>[ s^2 = , ]</p>
<p>여기서 매개변수 ()는 ()인 실수입니다. 이를 이해하기 위해 몇 가지 중요한 경우를 살펴봅시다:</p>
[
<span class="math display">\[\begin{aligned} \lambda=1:&amp;  \quad \text{d}s^2 = \text{d}x^2 + \text{d}y^2 + \text{d}z^2\\
\lambda=0:&amp; \quad \text{d}s^2 = 2\, \text{d}z^2\\
\lambda\to\infty:&amp;  \quad \text{d}s^2 = 2 \left( \text{d}x^2 + \text{d}y^2 \right)\\
\end{aligned} \tag{11.5}\]\]</span>
<p>()인 경우 메트릭은 등방성 유클리드 메트릭이 됩니다. 즉, (z)-방향의 이동이 (x)- 또는 (y)-방향과 똑같이 “비싸거나” “멀게” 느껴집니다. 극한의 경우인 ()에서는 오직 (z)-이동만이 중요하며, 옆으로의 이동((x)- 또는 (y)-방향)은 거리에 기여하지 않습니다. 다른 극한의 경우인 ()에서는 오직 옆으로의 이동만이 중요하며, (z)-방향의 이동은 “공짜”입니다. 더 멀리 떨어진 점들 사이의 거리는 그들 사이의 최단 경로를 따라 (s)를 합산하여 얻어집니다. 매개변수 ()는 옆으로의 이동((x)와 (y)축을 따라)과 수직 이동 사이의 상대적 가중치를 제어하는 편리한 수단 역할을 합니다. 직관적으로 여러분이 그러한 지형의 등산객이라고 상상한다면, ()를 선택함으로써 여러분은 산을 돌아가는 대신 산을 넘기 위해 얼마나 많은 오르내림을 감수할지 지정할 수 있습니다. 우리가 이 섹션의 시작 부분에서 <code>propagate</code>를 호출할 때 <code>lambda = 100</code>을 사용했을 때, 이 값은 사실상 무한대였으므로 식 11.5의 세 번째 경계 사례에 해당했습니다.</p>
<p>세포 분할을 목적으로 이러한 아이디어들은 Thouis Jones 등 (<a href="16-chap.html#ref-jones2005voronoi">Jones, Carpenter, and Golland 2005</a>; <a href="16-chap.html#ref-carpenter2006cellprofiler">Carpenter et al.&nbsp;2006</a>)에 의해 제시되었으며, 그들은 또한 <code>propagate</code>에서 사용되는 효율적인 알고리즘을 작성했습니다.</p>
<p>태스크</p>
<p>서로 다른 ()들을 사용했을 때의 효과를 시험해 보세요.</p>
</section>
<section id="세포체-분할" class="level2" data-number="13.13">
<h2 data-number="13.13" class="anchored" data-anchor-id="세포체-분할"><span class="header-section-number">13.13</span> 11.13 세포체 분할</h2>
<p><a href="11-chap_files/figure-html/fig-histcellbody-1-1.png &quot;그림 11.14: 로그를 취한 후 cellsSmooth의 액틴 채널 히스토그램.&quot;"><img src="11-chap_files/figure-html/fig- histcellbody-1-1.png" class="img-fluid"></a></p>
<p>그림 11.14: 로그를 취한 후 <code>cellsSmooth</code>의 액틴 채널 히스토그램.</p>
<p><a href="11-chap_files/figure-html/fig-histcellbody-2-1.png &quot;그림 11.15: 그림 11.14를 확대한 모습.&quot;"><img src="11-chap_files/figure-html/fig- histcellbody-2-1.png" class="img-fluid"></a></p>
<p>그림 11.15: 그림 11.14를 확대한 모습.</p>
<p>이미지에서 세포질 영역의 마스크를 결정하기 위해, 이번에는 데이터에 혼합 모델을 적합시켜서 찾은 전역 임계값을 사용하는 다른 방식의 임계값 처리를 살펴봅시다. 히스토그램은 액틴 이미지의 픽셀 강도 분포를 보여줍니다. 우리는 로그 스케일에서 데이터를 살펴보며, 그림 11.15에서는 데이터의 대부분이 놓인 영역을 확대합니다.</p>
<p>hist(log(cellsSmooth[,,3]) ) hist(log(cellsSmooth[,,3]), xlim = -c(3.6, 3.1), breaks = 300)</p>
<p>수많은 이미지에 대한 이러한 히스토그램들을 살펴보면서, 우리는 분할 목적으로 다음과 같은 모델을 세울 수 있습니다: <em>Image</em> <code>cells</code>의 세포질 채널 신호는 두 분포의 혼합물이며, 로그-정규(log-Normal) 배경과, 명시되지는 않았지만 다소 평평하고 대부분 겹치지 않는 또 다른 분포를 가진 전경으로 구성됩니다 10. 더욱이 픽셀의 대다수는 배경에서 옵니다. 그러면 우리는 (패키지 <strong><a href="https://bioconductor.org/packages/genefilter/">genefilter</a></strong>에 구현된) half range mode와, 모드(mode)의 왼쪽에 놓인 값들의 제곱평균제곱근(root mean square)으로부터 로그-정규 성분의 위치와 너비 매개변수에 대한 강건한 추정치를 찾을 수 있습니다.</p>
<p>10 이것은 우리가 <a href="04-chap.html">4장</a>에서 보았던 혼합 모델 아이디어의 응용입니다.</p>
<pre><code>library("genefilter")
bgPars = function(x) {
  x    = log(x)
  loc  = half.range.mode( x )
  left = (x - loc)[ x &lt; loc ]
  wid  = sqrt( mean(left^2) )
  c(loc = loc, wid = wid, thr = loc + 6*wid)
}
cellBg = apply(cellsSmooth, MARGIN = 3, FUN = bgPars)
cellBg


           [,1]        [,2]        [,3]
loc -2.90176965 -2.94427499 -3.52191681
wid  0.00635322  0.01121337  0.01528207
thr -2.86365033 -2.87699477 -3.43022437</code></pre>
<p>이 함수는 위치 <code>loc</code>에 6배의 너비 <code>wid</code>를 더한 값을 임계값으로 정의합니다 11.</p>
<p>11 여기서 숫자 6의 선택은 임의적입니다(ad hoc). 우리는 두 혼합 성분의 가중치를 추정하고 혼합 모델에 따른 사후 확률에 기초하여 각 픽셀을 전경 또는 배경으로 할당함으로써 임계값 선택을 더 객관적으로 만들 수 있습니다. 더 고급 분할 방법들은 이것이 실제로는 분류 문제라는 사실을 사용하며, 전경과 배경 영역을 분리하기 위해 추가적인 특징들과 더 복잡한 분류기들을 포함합니다 (예: (<a href="16-chap.html#ref-ilastik:NatMeth:2019">Berg et al.&nbsp;2019</a>)).</p>
<p>hist(log(cellsSmooth[,,3]), xlim = -c(3.6, 3.1), breaks = 300) abline(v = cellBg[c(“loc”, “thr”), 3], col = c(“brown”, “red”))</p>
<p><a href="11-chap_files/figure-html/fig-histcellbody-3-1.png &quot;그림 11.16: 그림 11.15와 같지만, loc와 thr이 수직선으로 표시되었습니다.&quot;"><img src="11-chap_files/figure-html/fig- histcellbody-3-1.png" class="img-fluid"></a></p>
<p>그림 11.16: 그림 11.15와 같지만, <code>loc</code>와 <code>thr</code>이 수직선으로 표시되었습니다.</p>
<p>우리는 이제 액틴 또는 튜불린 이미지에서 임계값 위에 있거나, 이미 이미지 <code>nuclei</code>에서 핵으로 분류된 모든 픽셀들의 합집합으로 <code>cytoplasmMask</code>를 정의할 수 있습니다.</p>
<p>cytoplasmMask = (cellsSmooth[,,2] &gt; exp(cellBg[“thr”, 2])) | nuclei | (cellsSmooth[,,3] &gt; exp(cellBg[“thr”, 3]))</p>
<p>그 결과는 그림 11.17의 왼쪽 패널에 나와 있습니다. 세포체(cellular bodies)를 정의하기 위해, 이제 우리는 11.12절의 보로노이 테셀레이션 기반 전파 알고리즘을 사용하여 이 마스크 내에서 핵 분할을 간단히 확장할 수 있습니다. 이 방법은 각 핵마다 정확히 하나의 세포체가 있도록 보장하며, 세포의 모양이 콤팩트하게 유지되는 것과 이미지의 액틴 및 ()-튜불린 강도 신호를 따르는 것 사이에서 타협이 이루어지도록 세포체의 윤곽을 그립니다. <code>propagate</code> 알고리즘의 용어로 말하자면, 세포 모양은 거리 메트릭 11.4의 (x)와 (y) 성분에 의해 콤팩트하게 유지되고, 액틴 신호는 (z) 성분을 위해 사용됩니다. ()가 이들 사이의 상충 관계를 제어합니다.</p>
<pre><code>cellbodies = propagate(x = cellsSmooth[,,3], seeds = nuclei,
                       lambda = 1.0e-2, mask = cytoplasmMask)</code></pre>
<p><code>colorLabel</code> 플롯에 대한 대안적인 표현으로서, 우리는 또한 <code>paintObjects</code> 함수를 사용하여 원래 이미지 위에 핵과 세포체의 분할을 표시할 수 있습니다. 아래에서 계산된 이미지 <code>nucSegOnNuc</code>, <code>nucSegOnAll</code>, <code>cellSegOnAll</code>은 그림 11.17의 중간부터 오른쪽 패널에 나와 있습니다.</p>
<pre><code>cellsColor = EBImage::rgbImage(red   = cells[,,3],
                               green = cells[,,2],
                               blue  = cells[,,1])
nucSegOnNuc  = paintObjects(nuclei, tgt = EBImage::toRGB(cells[,,1]), col = "#ffff00")
nucSegOnAll  = paintObjects(nuclei,     tgt = cellsColor,    col = "#ffff00")
cellSegOnAll = paintObjects(cellbodies, tgt = nucSegOnNuc,   col = "#ff0080")</code></pre>
<p><a href="11-chap_files/figure- html/fig-cellbodies-1.png" title="그림 11.17 (a):"><img src="11-chap_files/figure-html/fig-cellbodies-1.png" class="img-fluid"></a></p>
<ol type="a">
<li></li>
</ol>
<p><a href="11-chap_files/figure- html/fig-cellbodies-2.png" title="그림 11.17 (b):"><img src="11-chap_files/figure-html/fig-cellbodies-2.png" class="img-fluid"></a></p>
<ol start="2" type="a">
<li></li>
</ol>
<p><a href="11-chap_files/figure- html/fig-cellbodies-3.png" title="그림 11.17 (c):"><img src="11-chap_files/figure-html/fig-cellbodies-3.png" class="img-fluid"></a></p>
<ol start="3" type="a">
<li></li>
</ol>
<p><a href="11-chap_files/figure- html/fig-cellbodies-4.png" title="그림 11.17 (d):"><img src="11-chap_files/figure-html/fig-cellbodies-4.png" class="img-fluid"></a></p>
<ol start="4" type="a">
<li></li>
</ol>
<p><a href="11-chap_files/figure- html/fig-cellbodies-5.png" title="그림 11.17 (e):"><img src="11-chap_files/figure-html/fig-cellbodies-5.png" class="img-fluid"></a></p>
<ol start="5" type="a">
<li></li>
</ol>
<p>그림 11.17: 세포체 분할 단계들. (a-d): <code>cytoplasmMask</code>, <code>cellbodies</code> (파랑: DAPI, 빨강: 액틴, 초록: 알파-튜불린), <code>nucSegOnNuc</code>, <code>nucSegOnAll</code>, <code>cellSegOnAll</code>.</p>
</section>
<section id="특징-추출" class="level2" data-number="13.14">
<h2 data-number="13.14" class="anchored" data-anchor-id="특징-추출"><span class="header-section-number">13.14</span> 11.14 특징 추출</h2>
<p>이제 원래의 이미지 데이터 <code>cells</code>와 함께 분할 결과인 <code>nuclei</code> 및 <code>cellbodies</code>를 확보했으므로, 각 세포에 대해 다양한 서술자(descriptors) 또는 특징(features)을 계산할 수 있습니다. 우리는 이미 11.11절의 시작 부분에서 기본 R 함수 <code>table</code>을 사용하여 객체의 총 수와 크기를 결정하는 방법을 보았습니다. 이제 이를 더 발전시켜서, 분할된 핵에서의 DAPI 신호(<code>cells[,,1]</code>)의 평균 강도, 분할된 핵에서의 평균 액틴 강도(<code>cells[,,3]</code>), 그리고 세포체에서의 평균 액틴 강도를 계산해 봅시다.</p>
<pre><code>meanNucInt       = tapply(cells[,,1], nuclei, mean)
meanActIntInNuc  = tapply(cells[,,3], nuclei, mean)
meanActIntInCell = tapply(cells[,,3], cellbodies, mean)</code></pre>
<p>우리는 특징들을 쌍별 산점도로 시각화할 수 있습니다 (그림 11.18). 각 특징이 독립적인 정보를 담고 있긴 하지만, 서로 상관관계가 있음을 볼 수 있습니다.</p>
<pre><code>library("GGally")
ggpairs(tibble(meanNucInt, meanActIntInNuc, meanActIntInCell))</code></pre>
<p><a href="11-chap_files/figure- html/fig-pairsint-1.png" title="그림 11.18: 세포별 강도 서술자의 쌍별 산점도."><img src="11-chap_files/figure-html/fig-pairsint-1.png" class="img-fluid"></a></p>
<p>그림 11.18: 세포별 강도 서술자의 쌍별 산점도.</p>
<p>조금만 더 노력하면, 우리는 더 정교한 요약 통계량들도 계산할 수 있습니다 – 예를 들어, 세포체 면적에 대한 핵 면적의 비율, 또는 세포 구조의 다소 추상적인 척도로서 각 세포체에서의 서로 다른 형광 신호들의 엔트로피, 상호 정보량(mutual information) 및 상관관계 등입니다. 그러한 척도들은 예를 들어 약물에 의해 유도된 미묘한 세포 구조의 변화를 탐지하는 데 사용될 수 있습니다.</p>
<p>위의 <code>tapply</code> 표현식처럼 기본 R 관용구를 사용하여 이러한 계산들을 수행하는 것은 쉽고 직관적이지만, <strong><a href="https://bioconductor.org/packages/EBImage/">EBImage</a></strong> 패키지는 문헌에서 흔히 사용되어 온 방대한 특징 컬렉션을 효율적으로 계산해 주는 <code>computeFeatures</code> 함수도 제공합니다 (선구적인 참고 문헌은 Boland와 Murphy. (<a href="16-chap.html#ref-BolandMurphy">2001</a>)입니다). 이 함수에 대한 자세한 내용은 매뉴얼 페이지에 설명되어 있으며, 예시 응용 사례는 <strong><a href="https://bioconductor.org/packages/HD2013SGI/">HD2013SGI</a></strong> 비네트에 정리되어 있습니다. 아래에서는 핵 분할(<code>nuclei</code>)을 사용하여 DAPI 채널로부터, 그리고 세포체 분할(<code>cytoplasmRegions</code>)을 사용하여 액틴과 튜불린 채널로부터 각 세포의 강도, 모양 및 텍스처에 대한 특징들을 계산합니다.</p>
<pre><code>F1 = computeFeatures(nuclei,     cells[,,1], xname = "nuc",  refnames = "nuc")
F2 = computeFeatures(cellbodies, cells[,,2], xname = "cell", refnames = "tub")
F3 = computeFeatures(cellbodies, cells[,,3], xname = "cell", refnames = "act")
dim(F1)


[1] 43 89</code></pre>
<p><code>F1</code>은 43개 행(각 세포마다 하나씩)과 89개 열(계산된 특징마다 하나씩)을 가진 행렬입니다.</p>
<pre><code>F1[1:3, 1:5]


  nuc.0.m.cx nuc.0.m.cy nuc.0.m.majoraxis nuc.0.m.eccentricity nuc.0.m.theta
1   119.5523   17.46895          44.86819            0.8372059     -1.314789
2   143.4511   15.83709          26.15009            0.6627672     -1.213444
3   336.5401   11.48175          18.97424            0.8564444      1.470913</code></pre>
<p>열 이름은 특징의 유형뿐만 아니라, 그것이 계산된 색상 채널과 분할 마스크를 인코딩합니다. 우리는 이제 <a href="05-chap.html">5장</a>, <a href="07-chap.html">7장</a>, <a href="09-chap.html">9장</a>에서 보았던 다변량 분석 방법들을 다음과 같은 수많은 작업에 사용할 수 있습니다.</p>
<ul>
<li><p>세포 하위 모집단 탐지 (군집화)</p></li>
<li><p>세포를 사전 정의된 세포 유형이나 표현형으로 분류 (분류)</p></li>
<li><p>서로 다른 생물학적 조건에 해당하는 이미지들 사이에서 하위 모집단이나 세포 유형의 절대적 또는 상대적 빈도가 다른지 확인</p></li>
</ul>
<p>이러한 “일반적인” 기계 학습 작업 외에도, 우리는 세포의 공간적 위치도 알고 있으며, 이하에서는 우리의 분석에서 이를 활용하는 몇 가지 방법들을 탐구해 볼 것입니다.</p>
<p>태스크</p>
<p>탐색적 다변량 방법인 PCA, 히트맵을 사용하여 행렬 <code>F1</code>, <code>F2</code>, <code>F3</code>를 시각화하세요. “이상치” 세포들의 특별한 점은 무엇인가요?</p>
</section>
<section id="공간-통계-점-과정" class="level2" data-number="13.15">
<h2 data-number="13.15" class="anchored" data-anchor-id="공간-통계-점-과정"><span class="header-section-number">13.15</span> 11.15 공간 통계: 점 과정</h2>
<p>이전 섹션들에서 우리는 이미지로부터 세포의 위치와 다양한 모양 및 형태학적 특징들을 추출하는 방법들을 보았습니다. 이제는 위치의 공간적 분포를 탐구해 볼 것입니다. 흥미로운 작업 데이터를 확보하기 위해, 데이터셋을 바꾸어 유방암 림프절 생검 데이터를 살펴보겠습니다.</p>
<section id="사례-연구-면역-세포와-암세포의-상호작용" class="level3" data-number="13.15.1">
<h3 data-number="13.15.1" class="anchored" data-anchor-id="사례-연구-면역-세포와-암세포의-상호작용"><span class="header-section-number">13.15.1</span> 11.15.1 사례 연구: 면역 세포와 암세포의 상호작용</h3>
<p>림프절은 림프(lymph)라 불리는 체액을 위한 면역학적 필터 역할을 합니다. 항원은 혈액 순환계로 돌아가기 전에 림프절에서 림프로부터 걸러집니다. 림프절은 몸 전체에서 발견되며, 주로 T 세포, B 세포, 수지상 세포(dendritic cells) 및 대식세포(macrophages)로 구성됩니다. 림프절은 우리 조직 대부분의 액체를 배출합니다. 유방의 림프관은 보통 겨드랑이 밑의 나머지 림프절을 거치기 전에 하나의 림프절로 먼저 배출됩니다. 그 첫 번째 림프절을 <strong>감시(sentinel)</strong> 림프절이라고 부릅니다. 비장과 유사한 방식으로, 항원을 포획하는 대식세포와 수지상 세포는 이러한 이물질들을 T 세포와 B 세포에 제시함으로써 면역 반응을 개시합니다.</p>
<p>T 림프구는 대개 기능적 및 표현형적으로 다른 두 가지 주요 하위 집합으로 나뉩니다.</p>
<ul>
<li><p>CD4+ T 세포, 또는 보조 T 세포(T helper cells): 이들은 면역 조절의 적절한 조정자입니다. 보조 T 세포의 주요 기능은 감염과 싸우기 위해 다른 백혈구들을 활성화하는 특수 인자들을 분비함으로써 면역 반응을 증강하거나 강화하는 것입니다.</p></li>
<li><p>CD8+ T 세포, 또는 독성/억제 T 세포(T killer/suppressor cells): 이 세포들은 특정 종양 세포, 바이러스에 감염된 세포, 그리고 때때로 기생충을 직접 죽이는 데 중요합니다. CD8+ T 세포는 면역 반응의 하향 조절(down-regulation)에도 중요합니다.</p></li>
</ul>
<p>두 유형의 T 세포 모두 몸 전체에서 발견될 수 있습니다. 이들은 종종 활성화가 일어나는 장소로서 이차 림프 기관(림프절과 비장)에 의존합니다.</p>
<p>수지상 세포 또는 CD1a 세포는 항원을 처리하여 펩타이드를 T 세포에 제시하는 항원 제시 세포입니다.</p>
<p><a href="imgs/SixPanelsLymphsmall.jpg &quot;그림 11.19: 비대해진 림프절의 생검 결과, 캡슐은 온전하고 정맥동(sinuses)은 폐쇄된 것이 밝혀졌습니다 (왼쪽 상단 패널, 헤마톡실린 및 에오신 염색, 원래 배율 (\times) 100). 침윤물은 소림프구, 대식세포 및 형질세포의 혼합물로 구성되었습니다 (오른쪽 상단 패널, 헤마톡실린 및 에오신, 원래 배율 (\times) 400). 침윤물은 CD3 양성 T 세포(CD4 및 CD8 양성 세포 모두 포함)와 CD20 양성 B 세포의 혼합물이었습니다. 수많은 대식세포 또한 CD4 양성임이 확인되었습니다. (출처: Hurley et al., Diagnostic Pathology (2008) 3:13)&quot;"><img src="imgs/SixPanelsLymphsmall.jpg" class="img-fluid"></a></p>
<p>그림 11.19: 비대해진 림프절의 생검 결과, 캡슐은 온전하고 정맥동(sinuses)은 폐쇄된 것이 밝혀졌습니다 (왼쪽 상단 패널, 헤마톡실린 및 에오신 염색, 원래 배율 () 100). 침윤물은 소림프구, 대식세포 및 형질세포의 혼합물로 구성되었습니다 (오른쪽 상단 패널, 헤마톡실린 및 에오신, 원래 배율 () 400). 침윤물은 CD3 양성 T 세포(CD4 및 CD8 양성 세포 모두 포함)와 CD20 양성 B 세포의 혼합물이었습니다. 수많은 대식세포 또한 CD4 양성임이 확인되었습니다. (출처: Hurley et al., Diagnostic Pathology (2008) 3:13)</p>
<p><a href="imgs/testscan_1_2_RGB99-4525D.jpg &quot;그림 11.20: 염색된 림프절; 이 이미지는 brcalymphnode의 공간 데이터의 기초가 됩니다.&quot;"><img src="imgs/testscan_1_2_RGB99-4525D.jpg" class="img-fluid"></a></p>
<p>그림 11.20: 염색된 림프절; 이 이미지는 <code>brcalymphnode</code>의 공간 데이터의 기초가 됩니다.</p>
<p>우리는 Setiadi 등 (<a href="16-chap.html#ref-Setiadi2010">2010</a>)의 데이터를 살펴볼 것입니다. 그림 11.20에 표시된 이미지를 분할 방법인 <em>GemIdent</em> (<a href="16-chap.html#ref-Holmes2009">Holmes, Kapelner, and Lee 2009</a>)를 사용하여 분할한 후, 저자들은 이미지 내의 모든 세포의 좌표와 유형을 얻었습니다. 우리는 이러한 유형의 데이터를 <strong>마크된 점 과정(marked point process)</strong>이라고 부르며, 이는 3개의 열을 가진 단순한 표로 간주될 수 있습니다.</p>
<pre><code>library("readr")
library("dplyr")
cellclasses = c("T_cells", "Tumor", "DCs", "other_cells")
brcalymphnode = lapply(cellclasses, function(k) {
    read_csv(file.path("..", "data", sprintf("99_4525D-%s.txt", k)))
    |&gt; transmute(x = globalX, y = globalY, class = k)
}) |&gt; bind_rows() |&gt; mutate(class = factor(class))

brcalymphnode


# A tibble: 209,462 × 3
       x     y class  
   &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt;  
 1  6355 10382 T_cells
 2  6356 10850 T_cells
 3  6357 11070 T_cells
 4  6357 11082 T_cells
 5  6358 10600 T_cells
 6  6361 10301 T_cells
 7  6369 10309 T_cells
 8  6374 10395 T_cells
 9  6377 10448 T_cells
10  6379 10279 T_cells
# ℹ 209,452 more rows


table(brcalymphnode$class)


        DCs other_cells     T_cells       Tumor 
        878       77081      103681       27822 </code></pre>
<p>우리는 10만 개 이상의 T 세포, 약 2만 8천 개의 종양 세포, 그리고 수백 개의 수지상 세포가 있음을 알 수 있습니다. 세포들의 (x)- 및 (y)-위치를 플롯해 봅시다 (그림 11.21).</p>
<pre><code>ggplot(filter(brcalymphnode, class %in% c("T_cells", "Tumor")),
   aes(x = x, y = y, col = class)) + geom_point(shape = ".") +
   facet_grid( . ~ class) + guides(col = "none")</code></pre>
<p><a href="11-chap_files/figure- html/fig-brcalntcells-1.png" title="그림 11.21: brcalymphnode의 T 세포와 종양 세포의 x 및 y 위치 산점도. 위치는 그림 11.20의 고해상도 버전으로부터 분할 알고리즘에 의해 얻어졌습니다. T 세포 플롯의 일부 직사각형 영역들이 의심스러울 정도로 비어 있는데, 이는 전체 합성 이미지 내의 해당 이미지 타일들이 유실되었거나 분석되지 않았기 때문일 수 있습니다."><img src="11-chap_files/figure-html/fig-brcalntcells-1.png" class="img-fluid"></a></p>
<p>그림 11.21: <code>brcalymphnode</code>의 T 세포와 종양 세포의 (x) 및 (y) 위치 산점도. 위치는 그림 11.20의 고해상도 버전으로부터 분할 알고리즘에 의해 얻어졌습니다. T 세포 플롯의 일부 직사각형 영역들이 의심스러울 정도로 비어 있는데, 이는 전체 합성 이미지 내의 해당 이미지 타일들이 유실되었거나 분석되지 않았기 때문일 수 있습니다.</p>
<p>질문 11.12</p>
<p>그림 11.20과 11.21을 비교해 보세요. 왜 (y)축이 서로 반전되어 있나요?</p>
<p>해결책</p>
<p>그림 11.20은 이미지 데이터의 관례를 따라 이미지의 왼쪽 상단 모서리를 원점으로 하는 반면, 그림 11.21은 하단 왼쪽을 원점으로 하는 데카르트 좌표계의 관례를 따릅니다.</p>
<p><strong><a href="https://cran.r-project.org/web/packages/spatstat/">spatstat</a></strong> 패키지의 기능을 사용하려면, <code>brcalymphnode</code>의 데이터를 <em>ppp</em> 클래스의 객체로 변환하는 것이 편리합니다. 우리는 동명의 함수를 호출하여 이 작업을 수행합니다.</p>
<pre><code>library("spatstat")


ln = with(brcalymphnode, ppp(x = x, y = y, marks = class, 
                             xrange = range(x), yrange = range(y)))
ln


Marked planar point pattern: 209462 points
Multitype, with levels = DCs, other_cells, T_cells, Tumor 
window: rectangle = [3839, 17276] x [6713, 23006] units</code></pre>
<p><em>ppp</em> 객체들은 <strong>공간 점 과정(spatial point process)</strong> 의 실현물들을 캡처하도록 설계되었습니다. 즉, 수학적 공간 내에 위치한 일련의 고립된 점들의 집합입니다. 우리의 경우 위에서 보듯이, 공간은 (x)- 및 (y)-좌표의 범위를 포함하는 2차원 직사각형입니다. 또한 점들은 특정 속성들로 <strong>마크(marked)</strong>될 수 있습니다. <code>ln</code>에서 마크는 단순히 <em>factor</em> 변수인 <code>class</code>입니다. 더 일반적으로 마크는 여러 속성, 시간 또는 정량적 데이터가 될 수도 있습니다. 마크된 점 과정과 이미지 사이에는 유사점이 있지만, 점 과정의 경우 점들이 공간 내 어디에나 놓일 수 있는 반면, 이미지에서는 픽셀들이 규칙적이고 직사각형인 방식으로 공간을 덮는다는 점이 다릅니다.</p>
</section>
<section id="볼록-껍질-convex-hull" class="level3" data-number="13.15.2">
<h3 data-number="13.15.2" class="anchored" data-anchor-id="볼록-껍질-convex-hull"><span class="header-section-number">13.15.2</span> 11.15.2 볼록 껍질 (Convex hull)</h3>
<p>위에서 우리는 (암묵적으로) 점 과정이 직사각형 내에 놓이도록 제한했습니다. 사실, 데이터 생성 과정은 조직 절편의 모양에 의해 더 제한됩니다. 우리는 점들의 볼록 껍질(convex hull)로부터 더 타이트한 영역을 계산하고 이를 근사할 수 있습니다 12.</p>
<p>12 <code>str(cvxhull)</code>을 사용하여 이 S3 객체의 내부 구조를 살펴볼 수 있습니다.</p>
<p>cvxhull = convexhull.xy(cbind(ln<span class="math inline">\(x, ln\)</span>y)) ggplot(as_tibble(cvxhull$bdry[[1]]), aes(x = x, y = y)) + geom_polygon(fill = NA, col = “black”) + geom_point() + coord_fixed()</p>
<p><a href="11-chap_files/figure- html/fig-convhull-1.png" title="그림 11.22: ln의 점들의 볼록 껍질을 설명하는 다각형."><img src="11-chap_files/figure-html/fig-convhull-1.png" class="img-fluid"></a></p>
<p>그림 11.22: <code>ln</code>의 점들의 볼록 껍질을 설명하는 다각형.</p>
<p>그림 11.22에서 다각형을 볼 수 있으며, 이제 이 다각형과 함께 <code>ppp</code>를 다시 호출합니다.</p>
<pre><code>ln = with(brcalymphnode, ppp(x = x, y = y, marks = class, 
                             poly = cvxhull$bdry[[1]]))
ln


Marked planar point pattern: 209462 points
Multitype, with levels = DCs, other_cells, T_cells, Tumor 
window: polygonal boundary
enclosing rectangle: [3839, 17276] x [6713, 23006] units</code></pre>
</section>
<section id="점-과정의-공간을-정의하는-다른-방법들" class="level3" data-number="13.15.3">
<h3 data-number="13.15.3" class="anchored" data-anchor-id="점-과정의-공간을-정의하는-다른-방법들"><span class="header-section-number">13.15.3</span> 11.15.3 점 과정의 공간을 정의하는 다른 방법들</h3>
<p>점 과정이 고려되는 공간을 정의하기 위해 반드시 볼록 껍질을 사용할 필요는 없습니다. 대안으로, 이전 지식에 기초하여 공간을 정의하는 이미지 마스크를 <code>ppp</code>에 제공할 수 있습니다. 또는 샘플링된 점들에 대해 밀도 추정을 사용하여, 산발적인 이상치들을 무시하고 충분히 높은 점 밀도를 가진 영역만을 식별할 수도 있습니다. 이러한 선택들은 공간 점 과정을 고려할 때 분석가의 몫입니다.</p>
</section>
</section>
<section id="차-효과-강도" class="level2" data-number="13.16">
<h2 data-number="13.16" class="anchored" data-anchor-id="차-효과-강도"><span class="header-section-number">13.16</span> 11.16 1차 효과: 강도</h2>
<p>공간 통계의 가장 기본적인 질문 중 하나는 인접한 점들이 “군집(clustering)”을 이루고 있는지, 즉 점들이 “우연히” 예상되는 것보다 서로 더 가까운지, 아니면 반대로 서로를 밀어내는 것처럼 보이는지 하는 것입니다. 이러한 유형의 질문을 던질 수 있는 많은 예시가 있습니다. 예를 들어:</p>
<ul>
<li><p>도시 내의 범죄 패턴,</p></li>
<li><p>국가 내의 질병 패턴,</p></li>
<li><p>한 지역의 토양 측정값.</p></li>
</ul>
<p>대개 그러한 패턴이 존재하는 이유를 찾는 것은 어렵지 않습니다: 좋은 동네와 나쁜 동네, 생활 방식이나 환경적 노출의 국소적 변동, 토양의 공통된 지질학적 역사 등이 있습니다. 때로는 관찰된 사건들이 서로를 끌어당기거나 밀어내는 메커니즘이 존재할 수도 있습니다 – 동네의 소위 “깨진 유리창”이나, 많은 세포 유형들이 다른 세포들 근처에 붙어 있으려는 경향 등이 있습니다.</p>
<p>세포 예시는 공간적 군집화(또는 안티-군집화)가 객체의 속성(또는 공간 점 과정의 용어로 마크)에 따라 달라질 수 있음을 강조합니다. 또한 답변이 고려되는 길이 스케일에 따라 달라질 수 있다는 점도 강조합니다. 비록 세포들이 서로를 끌어당기더라도, 세포는 유한한 크기를 가지며 동일한 공간을 차지할 수 없습니다. 따라서 세포들 사이에는 최소한의 거리가 존재할 것이며, 그 스케일에서 세포들은 본질적으로 서로를 밀어내지만, 더 먼 거리에서는 서로를 끌어당깁니다.</p>
<p>이러한 질문들을 더 정량적으로 다루기 위해, 우리는 “우연히” 무엇을 기대할지에 대한 확률 모델을 정의해야 합니다. 어떤 점 (p=(x,y)) 주변의 면적이 (a)인 원 안에 놓인 점들의 수를 세어 봅시다. 이를 (N(p, a))라고 부릅시다 13. (N)의 평균과 공분산은 1차 및 2차 속성을 제공합니다. 1차 속성은 과정의 <strong>강도(intensity)</strong>입니다.</p>
<p>13 평소와 같이, 우리는 무작위 변수에 대해 대문자 (N(p, a)) 표기법을 사용하고, 그 실현물 또는 샘플에 대해 소문자 (n(p, a))를 사용합니다.</p>
<p>[ (p) = _{a} . ]</p>
<p>여기서 우리는 국소적 강도 ((p))를 정의하기 위해 무한소 미적분학을 사용했습니다. 시계열에서와 마찬가지로, 정상 과정(stationary process)이란 영역 전체에서 균일성을 갖는 과정입니다. 즉, ((p) = )입니다. 그러면 영역 (A)에서의 강도는 면적에 비례합니다: (E[N(, A)] = A). 나중에 우리는 공간적 공분산과 같은 더 높은 차수의 통계량들도 살펴볼 것입니다.</p>
<p>[ (p_1, p_2) = _{a } . ]</p>
<p>만약 과정이 정상적이라면, 이것은 오직 두 점의 상대적 위치(두 점 사이의 벡터)에만 의존할 것입니다. 만약 이것이 오직 거리에만 의존한다면, 즉 벡터의 방향이 아니라 길이에만 의존한다면, 이를 2차 등방성(second order isotropic)이라고 부릅니다.</p>
<p><a href="imgs/Rain-Drops-small.jpg" title="그림 11.23: 바닥에 떨어지는 빗방울은 포아송 과정으로 모델링됩니다. 특정 지점에 떨어지는 빗방울의 수는 오직 비율 (\lambda)(와 그 지점의 크기)에만 의존하며, 다른 지점에서 일어나는 일에는 의존하지 않습니다."><img src="imgs/Rain-Drops-small.jpg" class="img-fluid"></a></p>
<p>그림 11.23: 바닥에 떨어지는 빗방울은 포아송 과정으로 모델링됩니다. 특정 지점에 떨어지는 빗방울의 수는 오직 비율 ()(와 그 지점의 크기)에만 의존하며, 다른 지점에서 일어나는 일에는 의존하지 않습니다.</p>
<section id="포아송-과정-poisson-process" class="level3" data-number="13.16.1">
<h3 data-number="13.16.1" class="anchored" data-anchor-id="포아송-과정-poisson-process"><span class="header-section-number">13.16.1</span> 11.16.1 포아송 과정 (Poisson Process)</h3>
<p>가장 단순한 공간 과정은 포아송 과정입니다. 우리는 이를 우리의 데이터와 비교하기 위한 귀무 모델로 사용할 것입니다. 이는 강도 ()를 가진 정상 과정이며, 겹치지 않는 공간 영역에서의 사건 발생들 사이에는 더 이상의 의존성이 없습니다. 더욱이, 면적 (A)인 영역 내의 점들의 수는 비율 (A)를 가진 포아송 분포를 따릅니다.</p>
</section>
<section id="강도-추정하기" class="level3" data-number="13.16.2">
<h3 data-number="13.16.2" class="anchored" data-anchor-id="강도-추정하기"><span class="header-section-number">13.16.2</span> 11.16.2 강도 추정하기</h3>
<p>강도를 추정하려면, 영역을 ((p))의 잠재적인 국소적 변동을 볼 수 있을 만큼 작으면서도 충분한 수의 점들을 포함할 수 있을 만큼 큰 하위 영역들로 나눕니다. 이는 2D 밀도 추정과 유사하며, 딱딱한 영역 경계 대신 매끄러운 커널 함수 (K)를 사용할 수 있습니다.</p>
<p>[ (p) = _i e(p_i) K(p-p_i). ]</p>
<p>커널 함수는 평활화 매개변수인 ()에 의존합니다. ()가 클수록 각 (p)에 대한 국소적 추정치를 계산하는 영역이 커집니다. (e(p))는 에지 보정 인자(edge correction factor)로, 커널의 서포트(“평활화 창”)가 점 과정이 정의된 공간 밖으로 나갈 때 발생하는 추정 편향을 고려합니다. <strong><a href="https://cran.r-project.org/web/packages/spatstat/">spatstat</a></strong> 패키지의 <em>ppp</em> 객체에 대해 정의된 <code>density</code> 함수는 식 11.8을 구현합니다.</p>
<p>d = density(subset(ln, marks == “Tumor”), edge=TRUE, diggle=TRUE) plot(d)</p>
<p><a href="11-chap_files/figure- html/fig-densityppp1-1.png" title="그림 11.24: ppp에서 Tumor로 마크된 세포들에 대한 강도 추정. 추정치의 서포트는 우리가 이전에 지정했던 다각형(그림 11.22)입니다."><img src="11-chap_files/figure-html/fig-densityppp1-1.png" class="img-fluid"></a></p>
<p>그림 11.24: <code>ppp</code>에서 <code>Tumor</code>로 마크된 세포들에 대한 강도 추정. 추정치의 서포트는 우리가 이전에 지정했던 다각형(그림 11.22)입니다.</p>
<p>플롯은 그림 11.24에 나와 있습니다.</p>
<p>질문 11.13</p>
<p>에지 보정 없이 추정하면 어떻게 보이나요?</p>
<p>해결책</p>
<p>d0 = density(subset(ln, marks == “Tumor”), edge = FALSE) plot(d0)</p>
<p><a href="11-chap_files/figure- html/fig-densityppp0-1.png" title="그림 11.25: 그림 11.24와 같지만 에지 보정이 없는 모습."><img src="11-chap_files/figure-html/fig-densityppp0-1.png" class="img-fluid"></a></p>
<p>그림 11.25: 그림 11.24와 같지만 에지 보정이 없는 모습.</p>
<p>이제 추정된 강도는 공간의 가장자리로 갈수록 작아지는데, 이는 에지 편향을 반영합니다 (그림 11.25).</p>
<p><code>density</code>는 우리에게 점 과정의 <em>강도</em> 에 대한 추정치를 제공합니다. 이와 관련이 있지만 다른 작업은 특정 세포 클래스에 속할 (조건부) <em>확률</em> 을 추정하는 것입니다. <code>relrisk</code> 함수는 특정 사건 유형의 공간적으로 변화하는 위험에 대한 비모수적 추정치를 계산합니다. 우리는 특정 공간적 위치에 존재하는 세포가 종양 세포일 확률에 관심이 있습니다 (그림 11.26).</p>
<pre><code>rr = relrisk(ln, sigma = 250)


plot(rr)</code></pre>
<p><a href="11-chap_files/figure- html/fig-relrisk-1.png" title="그림 11.26: 세포가 존재한다는 조건 하에 각 세포 클래스의 공간적으로 변화하는 확률 추정치."><img src="11-chap_files/figure-html/fig-relrisk-1.png" class="img-fluid"></a></p>
<p>그림 11.26: 세포가 존재한다는 조건 하에 각 세포 클래스의 공간적으로 변화하는 확률 추정치.</p>
</section>
</section>
<section id="차-효과-공간적-의존성" class="level2" data-number="13.17">
<h2 data-number="13.17" class="anchored" data-anchor-id="차-효과-공간적-의존성"><span class="header-section-number">13.17</span> 11.17 2차 효과: 공간적 의존성</h2>
<p>우리의 공간 과정에서 무작위로 한 점을 골랐을 때, 가장 가까운 이웃까지의 거리 (W)는 얼마일까요? 균질 포아송 과정의 경우, 이 거리의 누적 분포 함수는 다음과 같습니다.</p>
<p>[ G(w) = P(Ww) = 1-e<sup>{-w</sup>2}. ]</p>
<p>(G)를 플롯하는 것은 균질 포아송 과정으로부터의 이탈을 알아차리는 한 가지 방법을 제공합니다. 에지 효과도 고려하는 (G)의 추정량 (<a href="16-chap.html#ref-Baddeley1998">A. J. Baddeley 1998</a>; <a href="16-chap.html#ref-RipleySISS1988">Ripley 1988</a>)은 <strong><a href="https://cran.r-project.org/web/packages/spatstat/">spatstat</a></strong> 패키지의 <code>Gest</code> 함수에 의해 제공됩니다.</p>
<p>gln = Gest(ln) gln</p>
<pre><code>Function value object (class 'fv')
for the function r -&gt; G(r)
.....................................................................
        Math.label      Description                                  
r       r               distance argument r                          
theo    G[pois](r)      theoretical Poisson G(r)                     
han     hat(G)[han](r)  Hanisch estimate of G(r)                     
rs      hat(G)[bord](r) border corrected estimate of G(r)            
km      hat(G)[km](r)   Kaplan-Meier estimate of G(r)                
hazard  hat(h)[km](r)   Kaplan-Meier estimate of hazard function h(r)
theohaz h[pois](r)      theoretical Poisson hazard function h(r)     
.....................................................................
Default plot formula:  .~r
where "." stands for 'km', 'rs', 'han', 'theo'
Recommended range of argument r: [0, 20.998]
Available range of argument r: [0, 52.443]


library("RColorBrewer")
plot(gln, xlim = c(0, 10), lty = 1, col = brewer.pal(4, "Set1"))</code></pre>
<p><a href="11-chap_files/figure- html/fig-Gest-1.png" title="그림 11.27: 세 가지 서로 다른 에지 효과 보정을 사용한 G의 추정치들(여기서는 본질적으로 서로 겹쳐져 있음)과 균질 포아송 과정에 대한 이론적 분포."><img src="11-chap_files/figure-html/fig-Gest-1.png" class="img-fluid"></a></p>
<p>그림 11.27: 세 가지 서로 다른 에지 효과 보정을 사용한 (G)의 추정치들(여기서는 본질적으로 서로 겹쳐져 있음)과 균질 포아송 과정에 대한 이론적 분포.</p>
<p>객체 <code>gln</code>에 대해 출력된 요약 정보는 계산된 추정치들에 대한 개요를 제공하며, 추가 설명은 <code>Gest</code> 매뉴얼 페이지에 있습니다. 그림 11.27에서 우리는 경험적 분포 함수와 우리가 적절히 선택한 강도를 가진 균질 포아송 과정인 귀무 모델의 분포 함수가 약 4.5 단위 지점에서 교차하는 것을 볼 수 있습니다. 이 값보다 짧은 세포 간 거리는 귀무 모델에서보다 덜 발생할 가능성이 높으며, 특히 약 2 이하의 거리는 거의 존재하지 않습니다. 이는 물론 우리의 세포들이 유한한 크기를 가지고 있어 동일한 공간을 겹쳐서 차지할 수 없다는 사실을 반영합니다. 포아송 과정과 비교했을 때 매우 큰 거리를 피하려는 경향이 있는 것으로 보이는데, 이는 아마도 세포들이 군집을 이루려는 경향을 나타내는 것으로 보입니다.</p>
<section id="ripley의-k-함수" class="level3" data-number="13.17.1">
<h3 data-number="13.17.1" class="anchored" data-anchor-id="ripley의-k-함수"><span class="header-section-number">13.17.1</span> 11.17.1 Ripley의 (K) 함수</h3>
<p>균질 공간 포아송 과정에서, 우리가 임의의 점을 무작위로 고르고 거리 (r) 이내에 있는 점들의 수를 센다면, 이 숫자가 원의 면적인 (r^2)에 따라 증가할 것으로 기대합니다. 주어진 데이터 세트에 대해, 우리는 모든 점들에 대해 평균을 낸 관측된 이웃의 수를 이 기대값과 비교할 수 있습니다.</p>
<p>정상 점 과정(stationary point process)의 (K) 함수(Ripley의 (K)-함수 또는 축소된 2차 모멘트 함수라고도 함)는 (K(r))이 주어진 임의의 점으로부터 거리 (r) 이내에 있는 (추가적인) 점들의 기대값이 되도록 정의됩니다. ()는 과정의 강도, 즉 단위 면적당 기대되는 점의 수임을 기억합시다. (K) 함수는 과정의 2차 모멘트 속성입니다.</p>
<p>(K)의 정의는 비균질 점 과정으로 일반화될 수 있으며 (<a href="16-chap.html#ref-Baddeley2000">A. Baddeley, Moller, and Waagepetersen 2000</a>), 다음과 같이 쓰여집니다.</p>
<p>[ K_{}(r)= <em>{i,j} \𝟙</em>{d(p_i, p_j) r} { (x_i) (x_j) }, ]</p>
<p>여기서 (d(p_i, p_j))는 점 (p_i)와 (p_j) 사이의 거리이며, (e(p_i, p_j, r))은 에지 보정 인자입니다 14. 추정과 시각화를 위해 (K)(그리고 유사하게 (K_{}))의 변환인 소위 (L) 함수를 고려하는 것이 유용합니다.</p>
<p>14 자세한 내용은 <code>Kinhom</code> 매뉴얼 페이지를 참조하세요.</p>
<p>[ L(r)=. ]</p>
<p>균질 공간 포아송 과정의 경우, 이론적 값은 (L(r) = r)입니다. 이를 데이터 세트에 대한 (L) 추정치와 비교함으로써, 점 간 의존성과 공간적 군집화에 대해 배울 수 있습니다. 식 11.11의 제곱근은 추정량의 분산을 안정화하는 효과가 있어, (K)와 비교할 때 (L)은 데이터 분석과 시뮬레이션에 더 적합합니다. <strong><a href="https://cran.r-project.org/web/packages/spatstat/">spatstat</a></strong> 패키지의 <code>Linhom</code> 함수를 사용한 계산은 우리 데이터에 대해 몇 분 정도 걸립니다 (그림 11.28).</p>
<pre><code>Lln = Linhom(subset(ln, marks == "T_cells"))


Lln


Function value object (class 'fv')


for the function r -&gt; L[inhom](r)


................................................................................
           Math.label                
r          r                         
theo       L[pois](r)                
border     {hat(L)[inhom]^{bord}}(r) 
bord.modif {hat(L)[inhom]^{bordm}}(r)
           Description                                      
r          distance argument r                              
theo       theoretical Poisson L[inhom](r)                  
border     border-corrected estimate of L[inhom](r)         
bord.modif modified border-corrected estimate of L[inhom](r)
................................................................................
Default plot formula:  .~.x
where "." stands for 'bord.modif', 'border', 'theo'
Recommended range of argument r: [0, 694.7]
Available range of argument r: [0, 694.7]


plot(Lln, lty = 1, col = brewer.pal(3, "Set1"))</code></pre>
<p><a href="11-chap_files/figure- html/fig-images-Lln-1.png" title="그림 11.28: T 세포 패턴의 L_{inhom}(식 11.10 및 11.11) 추정치."><img src="11-chap_files/figure-html/fig-images-Lln-1.png" class="img-fluid"></a></p>
<p>그림 11.28: T 세포 패턴의 (L_{})(식 11.10 및 11.11) 추정치.</p>
<p>우리는 이제 다른 세포 유형들에 대해서도, 그리고 다른 종양들과 건강한 림프절들에 대해서도 (L) 함수를 살펴보는 작업을 계속할 수 있습니다. 이것이 Setiadi와 동료들이 그들의 보고서에서 수행한 작업이며 (<a href="16-chap.html#ref-Setiadi2010">Setiadi et al.&nbsp;2010</a>), 건강한 림프절과 유방암 림프절 사이의 T 세포 및 B 세포 공간적 그룹화 패턴을 비교함으로써, B 세포가 일부 종양에서 림프절의 소포 외(extrafollicular) 영역에서의 정상적인 위치를 잃는 것처럼 보인다는 것을 확인했습니다.</p>
<section id="쌍-상관-함수-the-pair-correlation-function" class="level4" data-number="13.17.1.1">
<h4 data-number="13.17.1.1" class="anchored" data-anchor-id="쌍-상관-함수-the-pair-correlation-function"><span class="header-section-number">13.17.1.1</span> 쌍 상관 함수 (The pair correlation function)</h4>
<p>는 기준 점으로부터의 거리의 함수로서 점 밀도가 어떻게 변하는지 설명합니다. 이는 공간적 군집화를 살펴보는 데 있어 물리학에서 영감을 얻은 관점을 제공합니다. 정상 점 과정의 경우, 다음과 같이 정의됩니다.</p>
<p>[ g(r)=(r). ]</p>
<p>정상 포아송 과정의 경우, 쌍 상관 함수는 항상 1과 같습니다. (g(r) &lt; 1)인 값은 점들 사이의 억제(inhibition)를 시사하고, 1보다 큰 값은 군집화를 시사합니다.</p>
<p><strong><a href="https://cran.r-project.org/web/packages/spatstat/">spatstat</a></strong> 패키지는 비균질 과정에 대해서도 (g)의 추정치 계산을 가능하게 하며, 아래와 같이 <code>pcf</code>를 호출하면 식 11.12의 정의가 (K_{}). 추정치에 적용됩니다.</p>
<p>pcfln = pcf(Kinhom(subset(ln, marks == “T_cells”)))</p>
<pre><code>plot(pcfln, lty = 1)
plot(pcfln, lty = 1, xlim = c(0, 10))</code></pre>
<p><a href="11-chap_files/figure- html/fig-images-pcf-1.png" title="그림 11.29 (a):"><img src="11-chap_files/figure-html/fig-images-pcf-1.png" class="img-fluid"></a></p>
<ol type="a">
<li></li>
</ol>
<p><a href="11-chap_files/figure- html/fig-images-pcf-2.png" title="그림 11.29 (b):"><img src="11-chap_files/figure-html/fig-images-pcf-2.png" class="img-fluid"></a></p>
<ol start="2" type="a">
<li></li>
</ol>
<p>그림 11.29: T 세포 패턴의 쌍 상관 함수(식 11.12) 추정치.</p>
<p>그림 11.29에서 보듯이, T 세포들은 군집을 이루고 있지만, 아주 짧은 거리에서는 기피(avoidance)의 증거도 보입니다.</p>
<p>질문 11.14</p>
<p>그림 11.29의 하단 패널에 있는 쌍 상관 함수 플롯의 샘플링 해상도가 낮습니다. 어떻게 이를 높일 수 있을까요?</p>
<p>해결책</p>
<p>답은 <code>Kinhom</code> 함수의 <code>r</code> 인수에 있습니다. 그림 11.30을 참조하세요.</p>
<p>pcfln2 = pcf(Kinhom(subset(ln, marks == “T_cells”), r = seq(0, 10, by = 0.2))) plot(pcfln2, lty = 1)</p>
<p><a href="11-chap_files/figure- html/fig-samplingpcf-1.png" title="그림 11.30: 질문 11.14에 대한 답변: 그림 11.29의 하단 패널과 같지만, 더 조밀한 샘플링을 사용한 모습."><img src="11-chap_files/figure-html/fig-samplingpcf-1.png" class="img-fluid"></a></p>
<p>그림 11.30: 질문 11.14에 대한 답변: 그림 11.29의 하단 패널과 같지만, 더 조밀한 샘플링을 사용한 모습.</p>
</section>
</section>
</section>
<section id="이-장의-요약" class="level2" data-number="13.18">
<h2 data-number="13.18" class="anchored" data-anchor-id="이-장의-요약"><span class="header-section-number">13.18</span> 11.18 이 장의 요약</h2>
<p>우리는 R에서 이미지 데이터로 작업하는 법을 배웠습니다. 이미지는 기본적으로 배열일 뿐이며, 우리는 이를 조작하기 위해 익숙한 관용구들을 사용할 수 있습니다. 우리는 이미지로부터 정량적 특징들을 추출할 수 있으며, 그 후의 많은 분석적 질문들은 다른 고처리량 데이터의 경우와 다르지 않습니다: 특징들을 평균이나 분산과 같은 통계량으로 요약하고, 조건들 사이의 차이에 대해 가설 검정을 수행하고, 분산 분석을 수행하며, 차원 축소, 군집화 및 분류를 적용합니다.</p>
<p>종종 우리는 전체 이미지가 아니라 이미지에 표시된 개별 객체들에 대해 그러한 정량적 특징들을 계산하고 싶어 하며, 그때 우리는 관심 있는 객체들의 경계를 획정하기 위해 먼저 이미지를 분할해야 합니다. 우리는 핵과 세포 이미지에 대해 이를 수행하는 방법을 보았습니다.</p>
<p>객체들의 위치와 이러한 위치들이 서로 어떻게 연관되어 있는지에 관심이 있을 때, 우리는 <em>공간 통계</em> 영역으로 들어갑니다. 우리는 <strong><a href="https://cran.r-project.org/web/packages/spatstat/">spatstat</a></strong> 패키지의 일부 기능들을 탐구했고, 점 과정 클래스를 접했으며, Ripley의 (K) 함수와 같이 점 패턴을 위해 사용되는 몇 가지 특수한 진단 통계량들을 배웠습니다.</p>
</section>
<section id="더-읽을거리" class="level2" data-number="13.19">
<h2 data-number="13.19" class="anchored" data-anchor-id="더-읽을거리"><span class="header-section-number">13.19</span> 11.19 더 읽을거리</h2>
<ul>
<li><p>이미지 분석에 관한 방대한 문헌이 있습니다. 이를 탐색할 때, 이 분야가 두 가지 힘에 의해 주도된다는 점을 깨닫는 것이 도움이 됩니다: 구체적인 응용 도메인(우리는 고처리량 세포 기반 어세이 분석을 보았습니다)과 가용한 컴퓨터 하드웨어입니다. 1970년대에 개발된 일부 알고리즘과 개념들은 여전히 유효하며, 다른 것들은 더 체계적이고 아마도 계산 집약적인 방법들에 의해 대체되었습니다. 많은 알고리즘은 데이터의 성격과 제기된 과학적 질문에 대해 특정한 가정들을 내포하고 있는데, 이는 한 응용 분야에서는 괜찮을 수 있지만 다른 분야에서는 새롭게 검토되어야 할 필요가 있습니다. 고전적인 입문서는 <em>The Image Processing Handbook</em> (<a href="16-chap.html#ref-RussImageProcessingHandbook">Russ and Neal 2015</a>)이며, 현재 7판까지 나와 있습니다.</p></li>
<li><p>공간 점 패턴 분석에 대해서는, Diggle (<a href="16-chap.html#ref-DiggleSPP">2013</a>; <a href="16-chap.html#ref-RipleySISS1988">Ripley 1988</a>; <a href="16-chap.html#ref-CressieSSD1991">Cressie 1991</a>; <a href="16-chap.html#ref-MeckeSG2013">Chiu et al.&nbsp;2013</a>)을 참조하십시오.</p></li>
</ul>
</section>
<section id="연습-문제" class="level2" data-number="13.20">
<h2 data-number="13.20" class="anchored" data-anchor-id="연습-문제"><span class="header-section-number">13.20</span> 11.20 연습 문제</h2>
<p>연습 문제 11.1</p>
<p>여러분의 개인 사진 보관함에서 몇 가지 이미지를 R로 로드하고 11.6절의 조작법들을 적용해 보세요.</p>
<p>연습 문제 11.2</p>
<p>그림 11.17에서처럼 <code>cellbodies</code> 이미지를 표시하되, 사용자가 <code>propagate</code> 함수의 <code>lambda</code> 매개변수(11.12, 11.13절)의 효과를 탐색할 수 있는 대화형 요소를 포함한 <strong><a href="https://cran.r-project.org/web/packages/shiny">shiny</a></strong> 앱을 작성해 보세요.</p>
<p>연습 문제 11.3</p>
<p>다음과 같은 2차원 경험적 자기 상관 함수(autocorrelation function)를 고려해 보세요.</p>
<p>[ a(v_x, v_y) = _{(x,y)I} B(x, y),B(x+v_x, , y+v_y), ]</p>
<p>여기서 (B)는 이미지, 즉 픽셀 세트 (I) 위의 함수이고, 튜플 ((x,y))는 모든 픽셀 좌표를 순회하며, (v=(v_x, v_y))는 오프셋 벡터입니다. <a href="https://mathworld.wolfram.com/Wiener-KhinchinTheorem.html">위너-킨친 정리(Wiener–Khinchin theorem)</a>를 사용하면, 고속 푸리에 변환을 통해 이 함수를 효율적으로 계산할 수 있습니다.</p>
<pre><code>autocorr2d = function(x) {
  y = fft(x/sum(x))
  abs(gsignal::fftshift(fft(y * Conj(y), inverse = TRUE), MARGIN = 1:2))
}</code></pre>
<p>아래에서 우리는 행렬을 <strong><a href="https://cran.r-project.org/web/packages/ggplot2/">ggplot2</a></strong>를 사용하여 (기본 R의 <code>image</code>와 유사하게) 히트맵으로 보여주는 작은 헬퍼 함수를 사용할 것입니다.</p>
<pre><code>matrix_as_heatmap = function(m)
  ggplot(reshape2::melt(m), aes(x = Var1, y = Var2, fill = value)) +
    geom_tile() + coord_fixed() +
    scale_fill_continuous(type = "viridis") +
    scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0))</code></pre>
<p>이제 <code>autocorr2d</code>를 세 가지 색상 채널 각각에 별도로 적용해 봅시다. 그 결과는 그림 11.31에 나와 있습니다.</p>
<p>nm = dimnames(cells)[[3]] ac = lapply(nm, function(i) autocorr2d(cells[,, i])) |&gt; setNames(sub(“^image-”, ““, nm))</p>
<pre><code>for (w in names(ac))
  print(matrix_as_heatmap(ac[[w]]) + ggtitle(w))

cy = dim(cells)[1] / 2
cx = dim(cells)[2] / 2
r  = round(sqrt((col(cells[,,1]) - cx)^2 + (row(cells[,,1]) - cy)^2))

matrix_as_heatmap(r) + ggtitle("radius r")</code></pre>
<p><a href="11-chap_files/figure- html/fig-autocorr2d-1.png" title="그림 11.31 (a):"><img src="11-chap_files/figure-html/fig-autocorr2d-1.png" class="img-fluid"></a></p>
<ol type="a">
<li></li>
</ol>
<p><a href="11-chap_files/figure- html/fig-autocorr2d-2.png" title="그림 11.31 (b):"><img src="11-chap_files/figure-html/fig-autocorr2d-2.png" class="img-fluid"></a></p>
<ol start="2" type="a">
<li></li>
</ol>
<p><a href="11-chap_files/figure- html/fig-autocorr2d-3.png" title="그림 11.31 (c):"><img src="11-chap_files/figure-html/fig-autocorr2d-3.png" class="img-fluid"></a></p>
<ol start="3" type="a">
<li></li>
</ol>
<p><a href="11-chap_files/figure- html/fig-autocorr2d-4.png" title="그림 11.31 (d):"><img src="11-chap_files/figure-html/fig-autocorr2d-4.png" class="img-fluid"></a></p>
<ol start="4" type="a">
<li></li>
</ol>
<p>그림 11.31: 히트맵으로 표시된 <code>cells</code> 이미지의 세 색상 채널의 자기 상관 함수. 중앙의 피크들은 짧은 거리에서의 신호 상관관계에 해당합니다. 또한 방사 좌표 <code>r</code>도 표시되어 있습니다.</p>
<p>이미지들은 등방성(isotropic)이어야 하므로(즉, 선호되는 방향이 없어야 하므로), 우리는 각도 좌표에 대해 평균을 낼 수 있습니다. 그 결과는 그림 11.32에 나와 있습니다. 우리는 서로 다른 색상 채널의 신호들이 서로 다른 길이 스케일을 가짐을 알 수 있습니다.</p>
<pre><code>aggregate_by_radius = function(x, r)
  tibble(x = as.vector(x),
         r = as.vector(r)) |&gt;
  group_by(r) |&gt;
  summarize(value = mean(x))

lapply(names(ac), function(w) 
  cbind(channel = w, 
        aggregate_by_radius(ac[[w]], r))
  ) |&gt; 
  bind_rows() |&gt; 
  dplyr::filter(r &lt;= 50) |&gt; 
  ggplot(aes(x = r, y = value, col = channel)) + geom_line() + 
    scale_color_manual(values = c(`Cy3` = "red", `FITC` = "green", `DAPI` = "blue"))</code></pre>
<p>서로 다른 채널들 사이의 상호 상관관계(cross-correlation)도 계산할 수 있도록 <code>autocorr2d</code> 함수를 확장해 보세요.</p>
<ul>
<li>위에서 구현한 <code>autocorr2d</code>에서 <code>sum</code> 정규화의 동기는 무엇인가요?</li>
<li>다른 계산을 수행하기 전에 <code>x</code>의 평균을 빼는 것이 타당할까요?</li>
<li>이 함수와 기본 R의 <code>var</code> 및 <code>sd</code> 함수를 통해 계산된 일반적인 경험적 분산 또는 상관관계 사이의 관계는 무엇인가요?</li>
<li>그림 11.32와 같은 플롯들이 고처리량 스크리닝 환경(즉, 수천 또는 수백만 개의 이미지를 분석해야 할 때)에서 품질 지표를 구축하는 데 어떻게 사용될 수 있을까요?</li>
<li><code>autocorr2d</code>의 3차원 또는 (n)차원 확장은 어떤 모습일까요? 그것이 어디에 유용할까요?</li>
</ul>
<p><a href="11-chap_files/figure- html/fig-autocorr1d-1.png" title="그림 11.32: 반지름별로 집계된 cells 이미지의 세 색상 채널의 자기 상관 함수."><img src="11-chap_files/figure-html/fig-autocorr1d-1.png" class="img-fluid"></a></p>
<p>그림 11.32: 반지름별로 집계된 <code>cells</code> 이미지의 세 색상 채널의 자기 상관 함수.</p>
<p>연습 문제 11.4</p>
<p>“이미지 데이터 작업(Working with Image Data)” 워크숍(<a href="https://github.com/wolfganghuber/WorkingWithImageData" class="uri">https://github.com/wolfganghuber/WorkingWithImageData</a>)을 살펴보세요. 이 워크숍은 이 장과 동일한 내용 중 일부를 다른 이미지들로 다루고 있으며, 분할과 광학 흐름(optical flow)에 대한 추가적인 예시들도 포함하고 있습니다.</p>
<p>연습 문제 11.5</p>
<p><a href="09-chap.html">9장</a>의 우크라이나 도시들에 대해 보로노이 테셀레이션을 계산하고 표시해 보세요. 2D 평면에서 유클리드 거리를 사용한 MDS 좌표를 사용하거나, 대권 거리(great circle distance, 하버사인 공식)를 사용한 위도와 경도를 사용하세요.</p>
<p>연습 문제 11.6</p>
<p>광시트 현미경(light sheet microscopy) 15으로부터 3D 이미지 데이터를 다운로드하고, 이를 <strong><a href="https://bioconductor.org/packages/EBImage/">EBImage</a></strong> <em>Image</em> 객체로 로드하여 데이터를 탐색해 보세요.</p>
<p>15 예: <a href="http://www.digital-embryo.org" class="uri">http://www.digital-embryo.org</a></p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./10-chap.html" class="pagination-link" aria-label="네트워크와 트리 (Networks and Trees)">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">네트워크와 트리 (Networks and Trees)</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./12-chap.html" class="pagination-link" aria-label="지도 학습 (Supervised Learning)">
        <span class="nav-page-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">지도 학습 (Supervised Learning)</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>