![](imgs/Pile_ou_face.png)

분자생물학에서는 여러 상황에서 카운팅 이벤트가 관련됩니다. 특정 철자를 사용하는 코돈 수, 참조와 일치하는 DNA 판독 수, DNA 서열에서 관찰되는 CG 다이그램 수 등이 있습니다. 이러한 개수는 _연속적인_ 규모로 측정되는 질량 및 강도와 같은 양과 달리 _이산_ 변수를 제공합니다.


연구 중인 메커니즘이 따르는 규칙을 안다면 결과가 무작위라 하더라도 계산 및 표준 확률 법칙을 통해 관심 있는 모든 사건의 확률을 생성할 수 있습니다. 이는 추론과 확률 조작 방법에 대한 지식을 기반으로 한 하향식 접근 방식입니다. [2장](02-chap.html)에서는 이를 데이터 기반(_bottom-up_) 통계 모델링과 결합하는 방법을 살펴보겠습니다.


## 1.1 이 장의 목표


이 장에서는 다음을 수행합니다.


* 주어진 모델에서 가능한 모든 결과의 확률을 얻는 방법을 배우고 이론적 빈도와 실제 데이터에서 관찰된 빈도를 비교하는 방법을 알아보세요.

* 푸아송 분포를 사용하여 에피토프 검출에 대한 데이터를 분석하는 방법에 대한 전체 예를 살펴보세요.

* 이산형 데이터에 가장 유용한 생성 모델(포아송, 이항, 다항)을 실험하는 방법을 알아보세요.

* 확률을 계산하고 희귀한 사건을 계산하려면 R 함수를 사용하세요.

* 지정된 분포에서 난수를 생성합니다.

## 1.2 실제 예


데이터 생성 프로세스에 대한 확률 모델이 있는 예를 살펴보겠습니다. 우리 모델에 따르면 HIV(인간 면역결핍 바이러스) 게놈의 돌연변이는 복제 주기당 뉴클레오티드당 \\(5 \times 10^{-4}\\)의 비율로 발생합니다. 각 뉴클레오티드 위치의 비율은 동일하며 한 위치의 돌연변이는 다른 위치에서 발생하는 것과 독립적으로 발생합니다1. HIV의 게놈 크기는 약 \\(10^4=10,000\\) 뉴클레오티드이므로 한 주기 후에 총 돌연변이 수는 \\(5 \times 10^{-4} \times 10^4 = 5\\) 비율의 **포아송** 분포2를 따릅니다. 그것은 우리에게 무엇을 말해주는가?


1 실제로, 그리고 엄밀히 말하면, 충분히 자세히 살펴보면 완전하고 완전한 독립은 현실적으로 거의 유지되지 않습니다. 따라서 모델러가 이러한 주장을 통해 일반적으로 의미하는 바는 가능한 상관 관계나 종속성이 너무 약하고 드물기 때문에 이를 무시해도 충분한 근사치라는 것입니다.


2 이러한 유형의 확률 분포에 대해서는 나중에 더 자세히 설명하겠습니다.


이 확률 모델은 한 번의 복제 주기 동안 돌연변이 수가 5에 가까울 것이며 이 추정치의 변동성은 \\(\sqrt{5}\\)(표준 오류)라고 예측합니다. 이제 우리는 일반적인 HIV 계통에서 볼 것으로 예상되는 돌연변이 수와 그 다양성에 대한 기준선 참조 값을 갖게 되었습니다.


실제로 우리는 훨씬 더 자세한 정보를 추론할 수 있습니다. 푸아송(5) 모델에서 3개의 돌연변이가 얼마나 자주 발생할 수 있는지 알고 싶다면 R 함수를 사용하여 \\(x=3\\) 이벤트를 볼 확률을 생성할 수 있으며, 람다(\\(\lambda\\))라고 하는 푸아송 분포의 **속도 매개변수** 값을 \\(5\\)로 취합니다.


\\(\lambda\\) 및 \\(\mu\\)와 같은 그리스 문자는 종종 우리가 사용하는 확률 분포를 특징짓는 중요한 매개변수를 나타냅니다.




dpois(x = 3, 람다 = 5)__



[1] 0.1403739


이는 정확히 3개의 사건을 볼 확률이 약 0.14, 즉 7분의 1이라는 것을 의미합니다.


0부터 12까지의 모든 값의 확률을 생성하려면 루프를 작성할 필요가 없습니다. R의 시퀀스 연산자인 콜론 "`:`"을 사용하여 첫 번째 인수를 이 13개 값의 **벡터**로 설정할 수 있습니다. 그래프를 그려서 확률을 확인할 수 있습니다(그림 1.1). 이 그림과 마찬가지로 이 책의 여백에 있는 대부분의 그림은 본문에 표시된 코드에 의해 생성됩니다.


[![R의 출력 형식이 어떻게 지정되는지 참고하세요. 첫 번째 줄은 벡터의 첫 번째 항목으로 시작하므로 \[1\]이고 두 번째 줄은 9번째 항목으로 시작하므로 \[9\]입니다. 이는 긴 벡터의 요소를 추적하는 데 도움이 됩니다. 벡터라는 용어는 동일한 유형 \(이 경우 숫자\)의 순서가 지정된 요소 목록에 대한 R 용어입니다.](imgs/devil.png)](imgs/devil.png "R의 출력 형식이 어떻게 지정되는지 확인하세요. 첫 번째 줄은 벡터의 첫 번째 항목으로 시작하므로 \[1\]이고 두 번째 줄은 9번째 항목으로 시작하므로 \[9\]입니다. 이는 긴 벡터의 요소를 추적하는 데 도움이 됩니다. 벡터라는 용어는 R 용어입니다. 동일한 유형 \(이 경우 숫자\)의 순서가 지정된 요소 목록의 경우.")


R의 출력 형식이 어떻게 지정되는지 참고하세요. 첫 번째 줄은 벡터의 첫 번째 항목으로 시작하므로 [1]이 되고, 두 번째 줄은 9번째 항목으로 시작하므로 [9]가 됩니다. 이는 긴 벡터의 요소를 추적하는 데 도움이 됩니다. _벡터_라는 용어는 동일한 유형(이 경우 숫자)의 순서가 지정된 요소 목록에 대한 R 용어입니다.




0:12 __



[1] 0 1 2 3 4 5 6 7 8 9 10 11 12



dpois(x = 0:12, 람다 = 5)__



[1] 0.0067 0.0337 0.0842 0.1404 0.1755 0.1755 0.1462 0.1044 0.0653 0.0363 [11] 0.0181 0.0082 0.0034



barplot(dpois(0:12, 5), names.arg = 0:12, col = "red")__


[![](01-chap_files/Figure-html/fig-Poisson5-1.png)](01-chap_files/Figure- html/fig-Poisson5-1.png "그림 1.1: Poisson\(5\) 분포에 의해 모델링된 대로 0,1,2,…,12개의 돌연변이가 나타날 확률. 플롯은 4개 또는 5개의 돌연변이가 자주 표시되지만 거의 발생하지 않음을 보여줍니다. 12만큼. 분포는 더 높은 숫자 \(13,...\)으로 계속되지만 확률은 연속적으로 작아지므로 여기서는 이를 시각화하지 않습니다.")


그림 1.1: 포아송(5) 분포에 의해 모델링된 대로 0,1,2,…,12개의 돌연변이가 나타날 확률. 플롯은 종종 4개 또는 5개의 돌연변이를 볼 수 있지만 12개까지는 거의 볼 수 없음을 보여줍니다. 분포는 더 높은 숫자(\\(13,...\\))로 계속되지만 확률은 연속적으로 작아지므로 여기서는 이를 시각화하지 않습니다.


수학 이론에 따르면 \\(x\\) 값을 볼 수 있는 포아송 확률은 \\(e^{-\lambda} \lambda^x / x!\\) 공식으로 제공됩니다. 이 책에서 우리는 때때로 이론을 논의할 것이지만 그림 1.1과 같은 구체적인 숫자 예와 시각화를 표시하는 것을 선호합니다.


포아송 분포는 돌연변이와 같은 희귀 사건에 대한 좋은 모델입니다. **이산 사건**에 대한 다른 유용한 확률 모델은 Bernoulli, 이항 및 다항 분포입니다. 이 장에서는 이러한 모델을 살펴보겠습니다.


## 1.3 이산 확률 모델 사용


[![범주형 변수가 다른 대체 값을 갖는 것으로 생각하십시오. 이는 유전자 좌위의 다양한 대안과 유사한 수준입니다: 대립유전자.](imgs/devil.png)](imgs/devil.png "범주형 변수가 서로 다른 대체 값을 갖는 것으로 생각하십시오. 이는 유전자 좌위의 다양한 대안과 유사한 수준입니다: 대립유전자.")


범주형 변수가 다른 대체 값을 갖는 것으로 생각하십시오. 이는 유전자 위치의 다양한 대안인 _대립체_와 유사한 수준입니다.


점 돌연변이는 발생할 수도 있고 발생하지 않을 수도 있습니다. 바이너리 이벤트입니다. 두 가지 가능한 결과(예, 아니오)를 범주형 변수의 **수준**이라고 합니다.


모든 이벤트가 바이너리인 것은 아닙니다. 예를 들어, 이배체 유기체의 유전자형은 세 가지 수준(AA, Aa, aa)을 가질 수 있습니다.


범주형 변수의 수준 수가 매우 큰 경우도 있습니다. 그 예로는 생물학적 샘플에 있는 다양한 유형의 박테리아 수(수백 또는 수천 개)와 3개의 뉴클레오티드로 구성된 코돈 수(64개 수준)가 포함됩니다.


표본에서 범주형 변수를 측정할 때 카운트 벡터에서 다양한 수준의 빈도를 집계하려는 경우가 많습니다. R에는 범주형 변수에 대한 특수 인코딩이 있으며 이를 **인자** 3이라고 부릅니다. 여기서 우리는 표로 작성하는 벡터에 19명의 피험자에 대한 다양한 혈액 유전자형을 캡처합니다.


3 R은 요인 변수가 다른 "불법" 값을 허용하지 않도록 하며 이는 계산을 안전하게 유지하는 데 유용합니다.


[![c\(\)는 가장 기본적인 기능 중 하나입니다. 동일한 유형의 요소를 벡터로 조합합니다. 여기에 표시된 코드에서 유전자형 요소는 문자열입니다.](imgs/devil.png)](imgs/devil.png "c\(\)는 가장 기본적인 기능 중 하나입니다. 동일한 유형의 요소를 벡터로 조합합니다. 여기에 표시된 코드에서 유전자형 요소는 문자열입니다.")


`c()`는 가장 기본적인 함수 중 하나입니다. 동일한 유형의 요소를 벡터로 조합합니다. 여기에 표시된 코드에서 '유전자형'의 요소는 문자열입니다.




genotype = c("AA","AO","BB","AO","OO","AO","AA","BO","BO", "AO","BB","AO","BO","AB","OO","AB","BB","AO","AO") table(genotype)__



유전자형 AA AB AO BB BO OO 2 2 7 3 3 2


_factor_ 생성 시 R은 자동으로 수준을 감지합니다. `levels` 기능을 사용하여 레벨에 액세스할 수 있습니다.


[![입력이 요인이라는 것이 테이블 함수의 출력에서 ​​명확하지 않습니다. 그러나 인스턴스가 없는 다른 레벨이 있었다면 테이블에는 개수가 0인 해당 레벨도 포함되었을 것입니다.](imgs/devil.png)](imgs/devil.png "테이블 함수의 출력에서는 입력이 요인이라는 것이 분명하지 않습니다. 그러나 인스턴스가 없는 다른 레벨이 있었다면 테이블에는 개수가 0인 해당 레벨도 포함되었을 것입니다.")


'table' 함수의 출력에서는 입력이 요인이라는 것이 분명하지 않습니다. 그러나 인스턴스가 없는 다른 수준이 있었다면 테이블에는 개수가 0인 해당 수준도 포함되었을 것입니다.




genotypeF = factor(genotype) levels(genotypeF)__



[1] "AA" "AB" "AO" "BB" "BO" "OO"



테이블(유전자형F)__



유전자형F AA AB AO BB BO OO 2 2 7 3 3 2


__


질문 1.1


데이터에 아직 없는 일부 수준이 있는 _요인_을 생성하려면 어떻게 해야 합니까?


__


해결책


__


`factor` 함수의 매뉴얼 페이지를 보십시오.


데이터가 관찰되는 순서가 중요하지 않은 경우 무작위 변수를 **교환 가능**이라고 부릅니다. 이 경우 요인에서 사용할 수 있는 모든 정보는 요인 수준의 개수로 요약됩니다. 그런 다음 빈도 벡터가 데이터의 모든 관련 정보를 캡처하는 데 **충분**하여 데이터를 압축하는 효과적인 방법을 제공한다고 말합니다.


### 1.3.1 베르누이 시행


[![](imgs/BallsinBoxes2.png)](imgs/BallsinBoxes2.png "그림 1.2: 확률이 다른 두 가지 가능한 이벤트. 확률 매개변수 p=2/3을 사용하여 베르누이 분포로 모델링합니다.")


그림 1.2: 확률이 다른 두 가지 가능한 사건. 우리는 이것을 확률 매개변수 \\(p=2/3\\)를 사용하여 Bernoulli 분포로 모델링합니다.


동전을 던지면 두 가지 결과가 나올 수 있습니다. 베르누이 시행(Bernoulli trial)이라고 불리는 이 간단한 실험은 소위 베르누이 확률 변수(Bernoulli Random Variable)를 사용하여 모델링되었습니다. 이 빌딩 블록을 이해하면 놀라울 정도로 멀리 갈 수 있습니다. 이를 사용하여 보다 복잡한 모델을 구축할 수 있습니다.


이러한 무작위 변수 중 일부가 어떻게 보이는지 확인하기 위해 몇 가지 실험을 시도해 보겠습니다. 우리는 각 분포 유형에 대한 결과를 생성하도록 맞춤화된 특수 R 기능을 사용합니다. 그것들은 모두 문자 'r'로 시작하고 그 뒤에 모델 사양이 옵니다. 여기에서는 'rbinom'입니다. 여기서 'binom'은 이항식에 사용되는 약어입니다.


15번의 공정한 동전 던지기 시퀀스를 시뮬레이션한다고 가정해 보겠습니다. 성공 확률이 0.5(공정한 동전)인 15번의 베르누이 시행 결과를 얻으려면 다음과 같이 작성합니다.




rbinom(15, prob = 0.5, 크기 = 1)__



[1] 0 0 1 1 0 0 1 1 1 1 1 0 1 0 0


특정 **매개변수** 세트와 함께 `rbinom` 함수를 사용합니다. 4: 첫 번째 매개변수는 관찰하려는 시행 횟수입니다. 여기서는 15를 선택했습니다. 성공 확률을 'prob'로 지정합니다. 'size=1'을 통해 각 개별 시행은 단 한 번의 동전 던지기로만 구성됨을 선언합니다.


4 R 함수의 경우 매개변수를 **인수**라고도 합니다.


__


질문 1.2


이 함수 호출을 여러 번 반복하십시오. 왜 대답은 항상 같지 않습니까?


성공과 실패는 확률의 합이 1인 한 베르누이 시행에서 불평등한 확률을 가질 수 있습니다5. 오른쪽 상자 \\(\frac{2}{3}\\)와 왼쪽 상자 \\(\frac{1}{3}\\)에 떨어질 확률을 사용하여 그림 1.2에 표시된 두 상자에 공을 던지는 12번의 시도를 시뮬레이션하기 위해 다음과 같이 작성합니다.


5 우리는 이러한 이벤트를 **보완**이라고 부릅니다.




rbinom(12, 확률 = 2/3, 크기 = 1)__



[1] 1 1 1 0 0 0 1 0 1 0 1 0


1은 성공을 나타내며 공이 오른쪽 상자에 떨어졌음을 의미하고, 0은 공이 왼쪽 상자에 떨어졌음을 의미합니다.


### 1.3.2 이항 성공 횟수


오른쪽 상자에 공이 몇 개 들어가는지에만 관심이 있다면 던진 순서는 중요하지 않습니다.6 출력 벡터에서 셀의 합을 취하면 이 숫자를 얻을 수 있습니다. 따라서 위에서 본 이진 벡터 대신 단일 숫자만 보고하면 됩니다. R에서는 `size` 매개변수를 12로 설정하고 `rbinom` 함수를 한 번 호출하여 이를 수행할 수 있습니다.


결과가 2개이고 크기가 1 이상이면 이항 시험이 됩니다. 크기가 1이면 베르누이 시행의 특별한 경우입니다.


6 교환성 속성.




rbinom(1, 확률 = 2/3, 크기 = 12)__



[1] 9


이 출력은 12개의 공 중 몇 개가 오른쪽 상자에 떨어졌는지 알려줍니다(확률이 2/3인 결과). 앞면 또는 뒷면, 성공 또는 실패, CpG 또는 비CpG, M 또는 F, Y = 피리미딘 또는 R = 퓨린, 질병이 있거나 건강함, 참 또는 거짓과 같은 두 가지 가능한 결과만 있는 경우 무작위 2박스 모델을 사용합니다. "실패"(_보완_ 이벤트)가 확률 \\(1-p\\)로 발생하기 때문에 "성공" 확률 \\(p\\)만 필요합니다. 그러한 여러 번의 시도의 결과를 볼 때 교환이 가능한 경우7 성공 횟수만 기록합니다. 따라서 SSSSSFSSSSFFFSF는 (#Successes=10, #Failures=5) 또는 \\(x=10\\), \\(n=15\\)로 요약됩니다.


7 시행이 교환 가능한 한 가지 상황은 서로 **독립적**인 경우입니다.


성공 확률이 0.3인 베르누이 시행 15회 성공 횟수를 **이항** 확률 변수 또는 \\(B(15,0.3)\\) 분포를 따르는 확률 변수라고 합니다. 샘플을 생성하기 위해 시행 횟수를 15로 설정한 `rbinom` 함수 호출을 사용합니다.


[![set.seed는 여기서 무엇을 합니까?](imgs/devil.png)](imgs/devil.png "set.seed는 여기서 무엇을 합니까?")


여기서 `set.seed`는 무엇을 합니까?




set.seed(235569515) rbinom(1, prob = 0.3, 크기 = 15)__



[1] 5


__


질문 1.3


이 함수 호출을 10번 반복합니다. 가장 일반적인 결과는 무엇입니까?


__


해결책


__


가장 빈번한 값은 4입니다. 실제로 4가 나타날 것으로 예상되는 이론적 비율은 \\(X\\)가 \\(B(15, 0.3)\\) 다음에 오면 \\(X=4\\)가 나올 확률의 값입니다.


전체 **확률 질량 분포**는 다음을 입력하여 확인할 수 있습니다.


소수점 이하 자릿수를 2로 유지하기 위해 `round` 함수를 사용합니다.




probabilities = dbinom(0:15, prob = 0.3, size = 15) round(probabilities, 2)__



[1] 0.00 0.03 0.09 0.17 0.22 0.21 0.15 0.08 0.03 0.01 0.00 0.00 0.00 0.00 0.00 [16] 0.00


그림 1.3과 같이 이 분포의 막대 그래프를 생성할 수 있습니다.




barplot(확률, names.arg = 0:15, col = "red")__


[![](01-chap_files/Figure-html/fig-binombarplot-1.png)](01-chap_files/Figure- html/fig-binombarplot-1.png "그림 1.3: B\(15,0.3\)의 이론적 분포. 가장 높은 막대는 x=4에 있습니다. 우리는 이론적 값을 전체적으로 빨간색으로 나타내도록 선택했습니다.")


그림 1.3: \\(B(15,0.3)\\) 의 이론적 분포. 가장 높은 막대는 \\(x=4\\)에 있습니다. 우리는 이론적인 값을 전체적으로 빨간색으로 표시하기로 선택했습니다.


시행 횟수는 R에 `size` 매개변수로 입력한 숫자이며 종종 \\(n\\)로 표시되는 반면, 성공 확률은 \\(p\\)입니다. 수학 이론에 따르면 \\(X\\) 매개변수 \\((n,p)\\)가 \\(X \sim B(n,p)\\)로 작성된 이항 분포로 분포된 경우 \\(X=k\\)개의 성공을 볼 확률은 다음과 같습니다.


[![\\frac{n!}{\(n-k\)!k!} 대신 특수 표기법 {n \\choose k}를 단축키로 사용할 수 있습니다.](imgs/devil.png)](imgs/devil.png "\\frac{n!}{\(n-k\)!k!} 대신 특수 표기법 {n \\choose k}를 단축키로 사용할 수 있습니다.")


\\(\frac{n!}{(n-k)!k!}\\) 대신 특수 표기법 \\({n \choose k}\\)을 단축키로 사용할 수 있습니다.


\\[ \begin{aligned} P(X=k) &=&\frac{n\times (n-1)... (n-k+1)}{k\times(k-1)... 1}\; p^k\, (1-p)^{n-k}\\\ &=&\frac{n!}{(n-k)!k!}\;p^k\, (1-p)^{n-k}\\\ &=&{ n \k 선택}\; p^k\, (1-p)^{n-k}. \end{정렬} \\]


__


질문 1.4


\\(k=3\\), \\(p=2/3\\), \\(n=4\\)에 대한 수식의 출력은 무엇입니까?


### 1.3.3 포아송 분포


[![](imgs/Simeon_Poisson.jpg)](imgs/Simeon_Poisson.jpg "그림 1.4: Simeon Poisson의 이름을 따서 Poisson 분포의 이름이 \(이것이 R 코드를 제외하고 항상 대문자를 사용하는 이유입니다\). ")


그림 1.4: Poisson 분포의 이름을 딴 Simeon Poisson(이것이 R 코드를 제외하고 항상 대문자를 사용하는 이유입니다).


성공 확률 \\(p\\)이 작고 시행 횟수 \\(n\\)가 큰 경우 이항 분포 \\(B(n, p)\\)는 더 간단한 분포인 비율 매개변수 \\(\lambda=np\\)를 사용하는 **푸아송 분포**에 의해 충실하게 근사될 수 있습니다. 우리는 이미 HIV 예(그림 1.1)에서 이 사실과 분포를 사용했습니다.


__


질문 1.5


확률이 뉴클레오티드당 \\(p = 5 \times 10^{-4}\\)일 때 \\(n = 10^4\\) 뉴클레오티드 게놈에서 `0:12` 돌연변이를 관찰할 확률 질량 분포는 무엇입니까? 이항 \\(B(n,p)\\) 분포와 Poisson\\((\lambda=np)\\) 분포로 모델링할 때 유사합니까?


__


해결책


__


이항 분포와 달리 포아송은 더 이상 두 개의 개별 매개변수 \\(n\\) 및 \\(p\\)에 의존하지 않고 해당 곱 \\(np\\)에만 의존합니다. 이항 분포의 경우와 마찬가지로 포아송 확률을 계산하는 수학 공식도 있습니다.


\\[ P(X=k)= \frac{\lambda^k\;e^{-\lambda}}{k!}. \\]


예를 들어 \\(\lambda=5\\)를 취하고 \\(P(X=3)\\)을 계산해 보겠습니다.




5^3 * exp(-5) / 계승(3)__



[1] 0.1403739


이는 `dpois`를 사용하여 위에서 계산한 것과 비교할 수 있습니다.


__


일


\\(5\times10^{-4}\\)의 돌연변이율로 10,000개 위치에 대한 돌연변이 프로세스를 시뮬레이션하고 돌연변이 수를 계산합니다. 이를 여러 번 반복하고 'barplot' 기능을 사용하여 분포를 그립니다(그림 1.5 참조).




rbinom(1, prob = 5e-4, 크기 = 10000)__



[1] 6



simulations = rbinom(n = 300000, prob = 5e-4, size = 10000) barplot(table(simulations), col = "lavender")__


[![](01-chap_files/Figure-html/fig-gen-simpoisson-1.png)](01-chap_files/Figure-html/fig-gen-simpoisson-1.png "그림 1.5: 300000회 시뮬레이션에 대한 B\(10000, 10^{-4}\)의 시뮬레이션된 분포.")


그림 1.5: 300000번의 시뮬레이션에 대한 B(10000, \\(10^{-4}\\))의 시뮬레이션된 분포.


이제 사례 연구에서 확률 계산을 사용할 준비가 되었습니다.


### 1.3.4 에피토프 검출을 위한 생성 모델


특정 제약 화합물을 테스트할 때 알레르기 반응을 유발하는 단백질을 검출하는 것이 중요합니다. 이러한 반응을 담당하는 분자 부위를 **에피토프**라고 합니다. 에피토프의 기술적 정의는 다음과 같습니다.


> 항체가 결합하는 거대분자 항원의 특정 부분입니다.
> T 세포가 인식하는 단백질 항원의 경우 에피토프 또는
> 결정자는 Major에 결합하는 펩타이드 부분 또는 부위입니다.
> T 세포의 인식을 위한 조직적합성 복합체(MHC) 분자
> 수용체 (TCR).

면역학에 대해 잘 모르시는 경우를 대비해 말씀드리자면, **항체**(그림 1.6에 개략적으로 설명되어 있음)는 **항원**이라고 불리는 체내 이물질에 대한 반응으로 특정 백혈구에서 생성되는 단백질 유형입니다.


[![](imgs/Antibody_IgG2.png)](imgs/Antibody_IgG2.png "그림 1.6: 여러 면역글로불린 도메인을 색상으로 보여주는 항체 다이어그램.")


그림 1.6: 여러 면역글로불린 도메인을 컬러로 보여주는 항체 다이어그램.


항체는 항원에 (다소 특이적으로) 결합합니다. 결합의 목적은 항원을 파괴하는 것을 돕는 것입니다. 항체는 항원의 성질에 따라 여러 가지 방식으로 작용할 수 있습니다. 일부 항체는 항원을 직접 파괴합니다. 다른 사람들은 항원을 파괴하기 위해 백혈구를 모집하는 데 도움을 줍니다. 항원 결정기라고도 알려진 에피토프는 면역 체계, 특히 항체, B 세포 또는 T 세포에 의해 인식되는 항원의 일부입니다.


#### 알려진 매개변수를 사용한 ELISA 오류 모델


ELISA8 분석은 단백질을 따라 다른 위치에서 특정 에피토프를 검출하는 데 사용됩니다. 우리가 사용하는 ELISA 어레이에 대해 다음 사실이 성립한다고 가정합니다.


8 **E** nzyme-**L** 잉크 **I** mmuno**S** orbent **A** ssay([Wikipedia 링크 ELISA](http://en.wikipedia.org/wiki/ELISA)).


* 위치당 기본 소음 수준, 더 정확하게는 거짓양성률은 1%입니다. 이는 에피토프가 없을 때 히트를 선언할 확률입니다. 우리는 에피토프가 있다고 생각합니다. 우리는 이것을 \\(P(\text{에피토프 선언}|\text{에피토프 없음})\\)9라고 씁니다.

* 단백질은 독립적인 것으로 추정되는 100개의 다른 위치에서 테스트되었습니다.

* 우리는 50명의 환자 샘플을 수집하여 검사할 예정입니다.

9 \\(X|Y\\)와 같은 표현의 수직 막대는 "\\(X\\)는 _조건에 따라_ \\(Y\\)가 발생함"을 의미합니다.


#### 한 환자의 데이터


한 환자의 분석에 대한 데이터는 다음과 같습니다.




[1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 [38] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 [75] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0


여기서 1은 충격(따라서 알레르기 반응의 가능성)을 나타내고 0은 해당 위치에서 반응이 없음을 나타냅니다.


__


일


\\(p=0.01\\)인 50개의 독립 베르누이 변수의 합이 –충분히 근사한 – Poisson(\\(0.5\\)) 확률 변수와 동일하다는 것을 시뮬레이션을 통해 검증합니다.


#### 50가지 분석 결과


우리는 100개 위치 각각에서 집계된 50명의 환자 전체에 대한 데이터를 연구할 것입니다. 알레르기 반응이 없는 경우 위양성률은 한 명의 환자에 대해 각 개별 위치가 1/100의 확률을 갖는다는 것을 의미합니다. 따라서 50명의 환자를 집계한 후 특정 위치에서 관찰된 50개의 \\((0,1)\\) 변수의 합이 매개변수가 0.5인 포아송 분포를 가질 것으로 예상합니다. 일반적인 결과는 그림 1.7과 같습니다. 이제 그림 1.8과 같이 데이터 파일 `e100.RData`에서 R 객체 `e100`으로 로드된 실제 데이터가 있다고 가정합니다.


[![](01-chap_files/Figure-html/fig-전형P-1.png)](01-chap_files/Figure- html/fig-전형P-1.png "그림 1.7: 배경에 대한 생성 모델의 일반적인 데이터 플롯, 즉 거짓 양성 적중의 경우: 단백질을 따라 100개 위치, 각 위치에서 개수는 포아송\(0.5\)에서 추출됩니다. 무작위 변수.")


그림 1.7: 배경에 대한 생성 모델의 일반적인 데이터 플롯(예: 거짓 양성 히트): 단백질을 따라 100개 위치, 각 위치에서 카운트는 포아송(0.5) 무작위 변수에서 추출됩니다.




load("../data/e100.RData") barplot(e100, ylim = c(0, 7), width = 0.7, xlim = c(-0.5, 100.5), names.arg = seq(along = e100), col = "darkolivegreen")__


[![](01-chap_files/Figure-html/fig-epitopedata-1.png)](01-chap_files/Figure-html/fig-epitopedata-1.png "그림 1.8: 100개 위치에서 50명의 환자에 대한 ELISA 배열 결과 출력.")


그림 1.8: 100개 자세에서 50명의 환자에 대한 ELISA 어레이 결과 출력.


그림 1.8의 스파이크는 놀랍습니다. _에피토프가 없다면 7만큼 큰 값이 나올 확률은 얼마나 되나요?_ 하나의 포아송(\\(0.5\\)) 확률변수를 고려할 때 7(또는 그 이상)만큼 큰 숫자가 나올 확률을 구하면 답은 다음과 같이 닫힌 형식으로 계산될 수 있습니다.


\\[ P(X\geq 7)= \sum_{k=7}^\infty P(X=k). \\]


물론 이는 \\(1-P(X\leq 6)\\)과 동일합니다. 확률 \\(P(X\leq 6)\\)은 6에서의 소위 **누적 분포** 함수이고, R에는 이를 계산하기 위한 'ppois' 함수가 있는데, 이를 다음 두 가지 방법 중 하나로 사용할 수 있습니다.


10 하나에서 뺄셈을 할 필요가 없다는 편리함 외에도 이러한 계산 중 두 번째 계산은 확률이 작을 때 더 정확한 경향이 있습니다. 이는 부동 소수점 연산의 한계와 관련이 있습니다.




1 - ppois(6, 0.5)__



[1] 1.00238e-06



ppois(6, 0.5, lower.tail = FALSE)__



[1] 1.00238e-06


__


일


`lower.tail` 인수의 의미는 `ppois` 매뉴얼 페이지를 확인하세요.


이 숫자는 그리스 문자 엡실론11인 \\(\epsilon\\)으로 표시됩니다. 우리는 에피토프 반응이 없다고 가정할 때 \\(7\\)만큼 큰 수를 볼 확률은 다음과 같다는 것을 보여주었습니다.


11 수학자들은 종종 작은 숫자(및 하위 숫자)를 \\(\epsilon\\)이라고 부릅니다.


\\[ \epsilon=P(X\geq 7)=1-P(X\leq 6)\simeq10^{-6}. \\]


#### 포아송 분포에 대한 극단값 분석


멈추다! 위의 계산은 이 경우 올바른 계산이 _아닙니다_.


__


질문 1.6


에피토프가 없을 때 이러한 데이터를 관찰할 확률을 계산하려는 경우 우리 추론에서 결함을 발견할 수 있습니까?


__


해결책


__


100개의 위치를 ​​모두 살펴보고 가장 큰 값을 찾아보니 7이었습니다. 이러한 선택으로 인해 하나의 위치만 볼 때보다 7이라는 큰 값이 발생할 가능성이 더 높습니다.


따라서 포아송(0.5)이 7만큼 클 가능성이 무엇인지 묻는 대신, 최대 100번의 포아송(0.5) 시행이 7만큼 클 가능성은 얼마나 되는지 자문해야 합니다. 여기서는 **극단가치** 분석을 사용합니다12. 데이터 값 \\(x_1,x_2,... ,x_{100}\\)의 순서를 지정하고 이름을 \\(x_{(1)},x_{(2)},x_{(3)},... ,x_{(100)}\\)로 변경하여 \\(x_{(1)}\\)가 가장 작은 값을 나타내고 \\(x_{(100)}\\)가 가장 큰 값을 나타냅니다. 100개의 위치. \\(x_{(1)},... x_{(100)}\\)를 함께 이 100개 값 샘플의 **순위 통계**라고 합니다.


12 이는 우리가 무작위 분포의 매우 크거나 작은 값(예: 최대값 또는 최소값)의 동작에 관심이 있음을 의미합니다.


13 \\(\prod\\)를 사용한 표기법은 합계에 대한 \\(\sum\\)과 유사하게 일련의 용어의 곱을 작성하는 간결한 방법일 뿐입니다.


7만큼 큰 최대값은 100개 카운트가 모두 6보다 작거나 같은 **상보 사건**입니다. 두 상보 사건의 합은 1이 될 확률을 갖습니다. 위치가 독립적이라고 가정하므로 이제 계산을 수행할 수 있습니다13.


\\[ \begin{정렬} P(x_{(100)}\geq7) &=&1-P(x_{(100)}\leq6)\\\ &=&1-P(x_{(1)}\leq6)\times P(x_{(2)}\leq6)\times \cdots \times P(x_{(100)}\leq6)\\\ &=&1-P(x_1\leq6)\times P(x_2\leq6)\times \cdots \times P(x_{100}\leq6)\\\ &=&1-\prod_{i=1}^{100} P(x_i\leq6). \end{정렬} \\]


이러한 100개의 이벤트 각각이 독립적이라고 가정하기 때문에 위의 결과를 사용할 수 있습니다.


\\[ \prod_{i=1}^{100} P(x_i \leq 6)= \left(P(x_i \leq 6)\right)^{100}= \left(1-\epsilon\right)^{100}. \\]


#### 실제로 숫자 계산하기


R이 이 숫자의 값 \\(\left(1-\epsilon\right)^{100}\\)을 계산하도록 할 수 있습니다. 그러한 계산이 근사를 통해 어떻게 단축될 수 있는지에 관심이 있는 사람들을 위해 몇 가지 세부 사항을 제공합니다. 처음 읽을 때는 건너뛸 수 있습니다.


위에서 \\(\epsilon\simeq 10^{-6}\\)가 1보다 훨씬 작다는 점을 기억합니다. \\(\left(1-\epsilon\right)^{100}\\)의 값을 대략적으로 계산하려면 이항 정리를 사용하고 \\(\epsilon\\)의 "고차" 항을 모두 삭제할 수 있습니다. 즉, \\(\epsilon^2, \epsilon^3, ...\\), 나머지("선행") 항에 비해 무시할 정도로 작기 때문입니다.


\\[ (1-\epsilon)^n = \sum_{k=0}^n {n\ 선택 k} \, 1^{n-k} \, (-\epsilon)^k = 1-n\epsilon+{n\선택 2} \epsilon^2 - {n\ 선택 3} \epsilon^3 + ... \simeq 1-n\epsilon \simeq 1 - 10^{-4} \\]


또 다른 동등한 경로는 \\(\log(1-\epsilon)\simeq -\epsilon\\)과 동일한 근사값 \\(e^{-\epsilon} \simeq 1-\epsilon\\)을 사용하는 것입니다. 따라서


\\[ (1-\epsilon)^{100} = e^{\log\left((1-\epsilon)^{100}\right)} = e^{ 100 \log (1-\epsilon)} \simeq e^{-100 \epsilon} \simeq e^{-10^{-4}} \simeq 1 - 10^{-4}. \\]


따라서 에피토프가 없는 경우 100개 위치에서 7개 이상의 히트 수를 볼 정확한 확률은 이전에 잘못 계산한 확률의 약 100배입니다.


계산된 확률 \\(10^{-6}\\) 및 \\(10^{-4}\\)은 모두 표준 유의성 임계값(예: \\(0.05, 0.01\\) 또는 \\(0.001\\))보다 작습니다. 에피토프가 없다는 것을 거부하는 결정도 마찬가지였을 것입니다. 그러나 일부 법의학 법원 사건처럼 법정에 서서 p-값을 유효 숫자 8자리까지 방어해야 한다면 이는 또 다른 문제입니다. 검정의 다중성을 고려한 수정된 p-값이 보고되어야 하는 값이며, 이 중요한 문제는 [6장](06-chap.html)에서 다시 다루겠습니다.


14 이는 OJ 심슨 사건의 법의학 증거 조사에서 발생했습니다.


#### 시뮬레이션을 통한 확률 계산


방금 살펴본 경우에는 이론적인 확률 계산이 매우 간단하고 명시적인 계산을 통해 결과를 파악할 수 있었습니다. 실제로는 상황이 더 복잡해지는 경향이 있으므로 관심 있는 사건의 확률을 찾는 생성 모델을 기반으로 하는 컴퓨터 시뮬레이션인 **몬테 카를로** 방법을 사용하여 확률을 계산하는 것이 더 좋습니다. 아래에서는 100개의 푸아송 분포 수에서 최대값을 선택하는 100,000개의 인스턴스를 생성합니다.




maxes = replicate(100000, { max(rpois(100, 0.5)) }) table(maxes)__



최대 1 2 3 4 5 6 7 9 7 23028 60840 14364 1604 141 15 1


100,000번의 시도 중 16번의 시도에서 최대값은 7 이상이었습니다. 이는 \\(P(X_{\text{max}}\geq 7)\\)15에 대해 다음과 같은 근사치를 제공합니다.


15 R에서 `maxes >= 7` 표현식은 `maxes`와 길이는 같지만 값은 `TRUE` 및 `FALSE`인 논리 벡터로 평가됩니다. 여기에 `mean` 함수를 적용하면 해당 벡터는 0과 1로 변환되고, 계산 결과는 `TRUE`의 분수와 동일한 1의 분수가 됩니다.




평균(최대값 >= 7 )__



[1] 0.00016


이는 우리의 이론적 계산과 어느 정도 일치합니다. 우리는 이미 Monte Carlo 시뮬레이션의 잠재적인 한계 중 하나를 확인했습니다. 시뮬레이션 결과의 "세분성"은 시뮬레이션 수(100000)의 역수에 의해 결정되므로 약 10^{-5}가 됩니다. 추정된 확률은 이 세분성보다 더 정확할 수 없으며 실제로 추정의 정밀도는 그 몇 배입니다. 지금까지 수행한 모든 작업은 위치별 위양성률, 분석된 환자 수 및 단백질 길이를 알고 모델에서 동일하게 분포된 독립적 추첨을 갖고 있으며 알려지지 않은 매개변수가 없기 때문에 가능합니다. 이것은 **확률 또는 생성 모델링**의 예입니다. 모든 매개변수가 알려져 있으며 수학적 이론을 통해 **하향식** 방식으로 **연역**을 통해 작업할 수 있습니다.


우리는 모든 매개변수를 알고 있고 수학적 추론을 통해 결론을 내릴 수 있는 척하면서 소음에 대한 포아송 분포를 가정했습니다.


대신에 환자 수와 단백질의 길이를 알 수 있는 보다 현실적인 상황에 있지만 데이터의 분포를 모르는 경우 **통계적 모델링**을 사용해야 합니다. 이 접근 방식은 [2장](02-chap.html)에서 개발됩니다. 시작할 데이터만 있는 경우 먼저 이를 설명하기 위한 합리적인 분포를 **맞춰야** 합니다. 하지만 이 더 어려운 문제에 도달하기 전에 이산 분포에 대한 지식을 이분법, 성공 또는 실패 결과 이상으로 확장해 보겠습니다.


## 1.4 다항 분포: DNA의 경우


#### 결과가 2개 이상입니다.


예를 들어 그림 1.9의 상자와 같이 네 가지 가능한 결과를 모델링하거나 네 가지 뉴클레오티드 [A,C,G] 및 [T]의 수를 연구할 때 [이항] 모델을 확장해야 합니다.


[![](imgs/BallsinBoxes4.png)](imgs/BallsinBoxes4.png "그림 1.9: 상자는 개별 범주형 변수의 네 가지 결과 또는 수준을 나타냅니다. 오른쪽 상자는 가능성이 더 높은 결과를 나타냅니다.")


그림 1.9: 상자는 개별 **범주형** 변수의 네 가지 결과 또는 수준을 나타냅니다. 오른쪽 상자는 가능성이 더 높은 결과를 나타냅니다.


이항식을 사용할 때 결과 1에 확률 \\(p=P(1)=p_1\\)을 결과 0에 확률 \\(1-p=p(0)=p_0\\)을 할당하여 두 결과에 대한 불평등한 확률을 고려할 수 있다는 점을 상기하십시오. [A,C,G] 및 [T]와 같이 두 개 이상의 가능한 결과가 있는 경우 서로 다른 확률에 해당하는 서로 다른 크기의 상자에 공을 던지는 것을 생각할 수 있으며 레이블을 지정할 수 있습니다. 이러한 확률은 \\(p_A,p_C,p_G,p_T\\)입니다. 이항의 경우와 마찬가지로 가능한 모든 결과의 확률의 합은 1입니다. \\(p_A+p_C+p_G+p_T=1\\).


[![당신은 여기서 비밀리에 연속 배포판, 균등 배포판: runif를 만나고 있습니다.](imgs/devil.png)](imgs/devil.png "당신은 여기서 비밀리에 연속 배포판, 균일 배포판: runif를 만나고 있습니다.")


당신은 여기서 연속 분포, 균일 분포인 'runif'를 비밀리에 만나고 있습니다.


__


일


`runif`라는 함수를 통해 \\(0\\)과 \\(1\\) 사이의 가능한 모든 숫자를 생성하는 난수 생성기를 실험해 보세요. 이를 사용하여 4개 수준(A, C, G, T)의 확률 변수를 생성합니다. 여기서 \\(p_{\text{A}}=\frac{1}{8}, p_{\text{C}}=\frac{3}{8}, p_{\text{G}}=\frac{3}{8}, p_{\text{T}}=\frac{1}{8}\\)입니다.


**수학적 공식화.** 다항 분포는 개수 계산을 위한 가장 중요한 모델이며 R은 일반 공식을 사용하여 확률 \\(p_1,...,p_m\\)이 있는 \\(m\\) 상자에서 \\(n\\) 결과에 대한 개수의 **다항** 벡터 \\((x_1,...,x_m)\\)의 확률을 계산합니다.


첫 번째 용어는 다음과 같습니다. 상자 1의 확률 \\(p_1\\), 상자 2의 확률 \\(p_2\\), … 상자 \\(m\\)의 확률 \\(p_m\\)을 가정할 때 상자 1의 개수 \\(x_1\\), 2의 \\(x_2\\) 및 상자 m의 … \\(x_m\\)을 관찰할 결합 확률입니다.


\\[\begin{align} P(x_1,x_2,...,x_m) &=\frac{n!}{\prod_{i=1}^m x_i!} \prod_{i=1}^m p_i^{x_i}\\\ &={{n}\choose{x_1,x_2,...,x_m}} \; p_1^{x_1}\,p_2^{x_2}\cdots p_m^{x_m}. \end{정렬}\\]


괄호 안의 항은 다항 계수라고 하며 \\[{n\choose x_1,x_2,...,x_m}=\frac{n!}{x_1!x_2!\cdots x_m!}.\\]의 약어입니다. 따라서 이것은 이항 계수의 일반화입니다. \\(m=2\\)의 경우 이항 계수와 동일합니다.


__


질문 1.7


확률이 동일한 네 개의 상자가 있다고 가정해 보겠습니다. 공식을 사용하면 첫 번째 상자에서 4가 관찰되고, 두 번째 상자에서 2가 관찰되고, 다른 두 상자에서는 아무것도 관찰되지 않을 확률은 얼마입니까?


__


해결책


__


\\[ P(4,2,0,0)=\frac{6\times 5\times 4\times 3\times 2}{4\times 3\times 2 \times 2} \frac{1}{4^6} =\frac{15}{4^6}\simeq 0.0037. \\]




dmultinom(c(4, 2, 0, 0), prob = 담당자(1/4, 4))__



[1] 0.003662109


우리는 우리가 보는 데이터가 각 상자의 확률이 1/4인 가장 간단한 4박스 모델과 일치하는지 확인하기 위해 시뮬레이션 실험을 자주 실행합니다. 어떤 의미에서는 그것은 허수아비입니다(흥미로운 일은 일어나지 않습니다). 이에 대한 더 많은 예는 [2장](02-chap.html)에서 살펴보겠습니다. 여기서는 몇 가지 R 명령을 사용하여 이러한 개수 벡터를 생성합니다. 먼저 서로 다른 동일한 유형의 8개 문자가 있다고 가정합니다.




pvec = rep(1/4, 4) t(rmultinom(1, prob = pvec, size = 8))__



[,1] [,2] [,3] [,4] [1,] 1 3 1 3


__


질문 1.8


`t()` 함수를 사용하지 않고 코드를 시도해 보세요. 't'는 무엇을 뜻하나요?


__


질문 1.9


`rmultinom(n = 8, prob = pvec, size = 1)`과 `rmultinom(n = 1, prob = pvec, size = 8)`의 차이점을 어떻게 해석합니까? 힌트: 섹션 1.3.1과 1.3.2에서 수행한 작업을 기억하세요.


### 1.4.1 전력 시뮬레이션


과학자들이 실험을 계획할 때 종종 해결해야 하는 문제인 '얼마나 큰 표본 크기가 필요한가?'와 관련된 방식으로 **다항식**에 몬테카를로를 사용하는 예를 살펴보겠습니다.


![](imgs/SampleSize.png)

통계학자에게 표본 크기에 대해 물어보면 그들은 항상 더 많은 데이터가 필요하다고 말할 것입니다. 표본 크기가 클수록 결과가 더 민감해집니다. 그러나 실험실 작업은 비용이 많이 들기 때문에 고려해야 할 까다로운 비용-편익 균형이 있습니다. 이것은 매우 중요한 문제이기 때문에 책 마지막 부분([Chapter 13](13-chap.html))에 전체 장을 할애했습니다.


**전력**이라는 용어는 통계에서 특별한 의미를 갖습니다. 이는 무언가가 거기에 _있다면_ 이를 탐지할 확률로, **참양성률**이라고도 합니다.


전통적으로 실험주의자들은 실험을 계획할 때 80%(또는 그 이상)의 검정력을 목표로 합니다. 이는 동일한 실험을 여러 번 실행하면 약 20%의 시간 동안 의미 있는 결과를 산출해야 함에도 불구하고 실패할 것이라는 의미입니다.


우리가 수집한 DNA 데이터가 _공정한_ 프로세스에서 나온다는 귀무 가설을 \\(H_0\\)이라고 부르겠습니다. 여기서 4개의 뉴클레오티드 각각은 동일할 가능성이 \\((p_A,p_C,p_G,p_T)=(0.25,0.25,0.25,0.25)\\)입니다. 여기서 Null은 흥미로운 일이 전혀 일어나지 않는 기준선을 의미합니다. 우리가 반증(또는 통계학자의 용어로 "거부")하려는 것은 허수아비이므로 귀무 가설은 귀무 가설로부터의 편차가 흥미로워야 합니다16.


16 생물학을 조금이라도 안다면 살아있는 유기체의 DNA가 귀무 가설을 거의 따르지 않는다는 사실을 알게 될 것입니다. 따라서 이를 반증하는 것은 그다지 흥미롭지 않을 수 있습니다. 여기서 우리는 이 귀무가설을 통해 계산을 설명할 수 있지만 좋은 귀무가설(기각이 흥미로운)을 선택하려면 과학적 입력이 필요하다는 점을 상기시켜 주는 역할도 합니다.


동일한 크기의 상자로 표시되는 8개의 문자와 4개의 동일한 결과에 대해 R 명령을 실행하여 보았듯이 각 상자에 항상 2개가 표시되는 것은 아닙니다. 단지 8개의 문자만 보면 뉴클레오티드가 공정한 과정에서 나온 것인지 아닌지를 알 수 없습니다.


길이가 \\(n=20\\)인 시퀀스를 살펴봄으로써 뉴클레오티드의 원래 분포가 공정한지 아니면 다른("대체") 프로세스에서 나오는지 여부를 감지할 수 있는지 판단해 보겠습니다.


'rmultinom' 함수를 사용하여 귀무 가설로부터 1000개의 시뮬레이션을 생성합니다. 공간을 절약하기 위해 처음 11개 열만 표시합니다.




obsunder0 = rmultinom(1000, prob = pvec, size = 20) dim(obsunder0)__



[1] 4 1000



obsunder0[, 1:11]__



[,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [1,] 6 5 6 8 4 6 2 7 5 4 4 [2,] 6 6 3 7 3 3 8 4 3 3 5 [3,] 3 3 6 2 8 3 5 7 4 7 6 [4,] 5 6 5 3 5 8 5 2 8 6 5


[![모든 열의 상단에는 \[,1\]\[,2\] 형식의 인덱스가 있습니다... 이것이 열 인덱스입니다. 행에는 \[1,\]\[2,\]라는 레이블이 지정됩니다.... obsunder0 개체는 이전에 본 것과 같은 단순한 벡터가 아니라 행렬의 숫자 배열입니다.](imgs/devil.png)](imgs/devil.png "모든 열의 상단에는 \[,1\]\[,2\] 형식의 인덱스가 있습니다... 이는 열 인덱스입니다. 행에 레이블이 지정되어 있습니다. \[1,\]\[2,\].... obsunder0 개체는 이전에 본 것처럼 단순한 벡터가 아니라 행렬의 숫자 배열입니다.")


모든 열의 상단에는 '[,1][,2]...' 형식의 인덱스가 있습니다. 이것이 열 인덱스입니다. 행에는 `[1,][2,]...`라는 레이블이 지정됩니다. 'obsunder0' 객체는 이전에 본 것처럼 단순한 벡터가 아니라 행렬의 숫자 배열입니다.


매트릭스 'obsunder0'의 각 열은 시뮬레이션된 인스턴스입니다. 상자 안의 숫자가 매우 다양하다는 것을 알 수 있습니다. 일부는 8만큼 큰 반면 예상 값은 5=20/4입니다.


#### 테스트 만들기


기억하세요: 우리는 이러한 가치가 공정한 과정에서 나온다는 것을 알고 있습니다. 분명히 프로세스의 예상 값을 아는 것만으로는 충분하지 않습니다. 또한 얼마나 많은 변동성이 예상되는지, 어느 정도가 너무 큰지 설명할 수 있는 변동성 척도가 필요합니다. 우리는 측정값으로 다음 통계를 사용합니다. 이는 기대값에 대한 관찰값과 기대값 간의 차이의 제곱의 합으로 계산됩니다. 따라서 각 인스턴스에 대해


이 측정값은 기대값을 기준으로 각 제곱 잔차에 가중치를 부여합니다.


\\[ {\tt 통계}=\frac{(E_A-x_A)^2}{E_A}+ \frac{(E_C-x_C)^2}{E_C}+ \frac{(E_G- x_G)^2}{E_G}+ \frac{(E_T-x_T)^2}{E_T} =\sum_i\frac{(E_i-x_i)^2}{E_i} \tag{1.1}\\]


생성된 데이터의 처음 세 열은 우리가 기대하는 것과 얼마나 다릅니까? 우리는 다음을 얻습니다:




expected0 = pvec * 20 sum((obsunder0[, 1] - expected0)^2 / expected0)__



[1] 1.2



sum((obsunder0[, 2] - 예상0)^2 / 예상0)__



[1] 1.2



sum((obsunder0[, 3] - 예상0)^2 / 예상0)__



[1] 1.2


측정값의 값은 다를 수 있습니다. 3개 이상의 열을 볼 수 있으며, 1,000개 열을 모두 연구하는 방법을 살펴보겠습니다. 반복적인 입력을 피하기 위해 'stat' 공식(수식 1.1)을 함수에 캡슐화합니다.




stat = function(obsvd, exptd = 20 * pvec) { sum((obsvd - exptd)^2 / exptd) } stat(obsunder0[, 1])__



[1] 1.2


이 변형에 대한 보다 완전한 그림을 얻기 위해 모든 1000개 인스턴스에 대한 측정값을 계산하고 이 값을 'S0'이라고 하는 벡터에 저장합니다. 여기에는 \\(H_0\\) 아래에 생성된 값이 포함됩니다. 그림 1.10에 표시된 'S0' 값의 히스토그램을 **영 분포**의 추정치로 간주할 수 있습니다.




S0 = apply(obsunder0, 2, stat) summary(S0)__



최소 1쿼.  중앙값 평균 3번째 Qu.    최대. 0.000 1.200 2.800 3.126 4.400 17.600



hist(S0, break = 25, col = "라벤더", main = "")__


[![](01-chap_files/Figure-html/fig-histS0-1.png)](01-chap_files/Figure- html/fig-histS0-1.png "그림 1.10: null \(fair\) 분포에서 통계 통계의 시뮬레이션된 값 S0의 히스토그램은 통계 통계의 샘플링 분포에 대한 근사치를 제공합니다.")


그림 1.10: 널(공정) 분포에서 통계 'stat'의 시뮬레이션된 값 'S0'의 히스토그램은 통계 'stat'의 **샘플링 분포**에 대한 근사치를 제공합니다.


[![적용 함수는 배열의 행이나 열에 대한 루프를 줄여서 표현한 것입니다. 여기서 두 번째 인수 2는 열에 대한 루프를 나타냅니다.](imgs/devil.png)](imgs/devil.png "적용 함수는 배열의 행 또는 열에 대한 루프의 약어입니다. 여기서 두 번째 인수 2는 열에 대한 루프를 나타냅니다.")


'apply' 함수는 배열의 행이나 열에 대한 루프를 줄여서 표현한 것입니다. 여기서 두 번째 인수인 2는 열에 대한 반복을 나타냅니다.


요약 함수는 'S0'이 다양한 값을 취한다는 것을 보여줍니다. 예를 들어, 시뮬레이션된 데이터에서 95% 분위수(5% 가장 큰 값에서 작은 95% 값을 구분하는 값)를 근사화할 수 있습니다.




q95 = quantile(S0, probs = 0.95) q95 __



95% 7.6


따라서 'S0' 값의 5%가 7.6보다 크다는 것을 알 수 있습니다. 우리는 이것을 데이터 테스트를 위한 중요한 값으로 제안하고 'stat' 가중 제곱합이 7.6보다 큰 경우 데이터가 동일한 가능성의 뉴클레오티드를 사용하는 공정한 프로세스에서 나온다는 가설을 기각할 것입니다.


#### 테스트의 검정력 결정


가중 제곱합 차이를 기반으로 한 테스트에서 실제로 데이터가 귀무 가설에서 나온 것이 아니라는 사실을 탐지할 확률을 계산해야 합니다. 시뮬레이션을 통해 거부 확률을 계산합니다. 'pvecA'로 매개변수화된 대체 프로세스에서 1000개의 시뮬레이션 인스턴스를 생성합니다.


![](imgs/roulette.png)



pvecA = c(3/8, 1/4, 1/4, 1/8) observed = rmultinom(1000, prob = pvecA, size = 20) dim(observed)__



[1] 4 1000



관찰됨[, 1:7]__



[,1] [,2] [,3] [,4] [,5] [,6] [,7] [1,] 10 4 8 8 4 7 7 [2,] 3 10 5 6 6 7 2 [3,] 5 3 5 6 4 2 6 [4,] 2 3 2 0 6 4 5



적용(관찰, 1, 평균)__



[1] 7.469 4.974 5.085 2.472



expectedA = pvecA * 20 expectedA __



[1] 7.5 5.0 5.0 2.5


귀무가설의 시뮬레이션과 마찬가지로 관측값은 상당히 다양합니다. 문제는 데이터가 null에서 벗어났음을 테스트에서 얼마나 자주(1000개 인스턴스 중) 감지하는 것입니다.


통계 값이 95번째 백분위수 내에 있기 때문에 테스트는 첫 번째 관측치(10, 3, 5, 2)를 거부하지 않습니다.




통계(관찰됨[, 1])__



[1] 7.6



S1 = apply(observed, 2, stat) q95 __



95% 7.6



합계(S1 > q95)__



[1] 199



power = mean(S1 > q95) power __



[1] 0.199


[![우리는 주어진 또는 조건에 따라 수직선을 읽습니다.](imgs/devil.png)](imgs/devil.png "우리는 주어진 또는 조건에 따라 수직선을 읽습니다.")


우리는 수직선을 **주어진** 또는 **조건부**로 읽습니다.


1000개의 시뮬레이션을 실행한 결과 199개가 대체 분포에서 나온 것으로 확인되었습니다. 따라서 우리는 확률 \\(P(\text{reject }H_0 \;|\; H_A)\\)이 0.199라는 것을 계산했습니다.


\\(n = 20\\)의 시퀀스 길이를 사용하면 공정한 생성 프로세스와 **대안** 간의 차이를 감지할 수 있는 약 20%의 _능력_이 있습니다.


__


일


실제로 앞서 언급했듯이 허용되는 전력 값은 \\(0.8\\) 이상입니다. 시뮬레이션 실험을 반복하고 전력이 허용 가능한지 확인하는 새로운 시퀀스 길이 \\(n\\)를 제안합니다.


#### 고전 데이터에 대한 고전 통계


95번째 백분위수를 계산하기 위해 Monte Carlo를 사용하여 데이터를 시뮬레이션할 필요가 없었습니다. 계산에 도움이 되는 적절한 이론이 있습니다.


우리의 통계 `stat`에는 실제로 카이제곱 분포(자유도 3)라는 잘 알려진 분포가 있으며 \\({\chi}^2_3\\)로 표시됩니다.


[![](imgs/ProbaDiagram.png)](imgs/ProbaDiagram.png "그림 1.11: 우리는 확률 모델에 F라고 부르는 분포가 있는 방법을 연구했습니다. F는 관례에 따라 \\theta와 같은 그리스 문자로 표시되는 매개변수에 따라 달라지는 경우가 많습니다. 관찰된 데이터는 갈색 화살표를 통해 생성되고 x와 같은 라틴 문자로 표시됩니다. 확률 계산의 세로 막대는 가정을 의미합니다. 에")


그림 1.11: 우리는 확률 모델이 \\(F\\)라고 부르는 분포를 갖는 방식을 연구했습니다. \\(F\\)는 관례에 따라 \\(\theta\\)와 같이 그리스 문자로 표시되는 매개 변수에 따라 달라지는 경우가 많습니다. 관찰된 데이터는 갈색 화살표를 통해 생성되며 \\(x\\)와 같은 라틴 문자로 표시됩니다. 확률 계산의 세로 막대는 **가정** 또는 **조건부**를 나타냅니다.


Q-Q 플롯을 사용하여 분포를 비교하는 방법은 [Chapter 2](02-chap.html)에서 살펴보겠습니다([그림 2.8](02-chap.html#fig-qqplot3-1) 참조). 직접 만든 시뮬레이션을 실행하는 대신 보다 표준적인 테스트를 사용할 수도 있었습니다. 그러나 우리가 배운 절차는 카이제곱 분포가 적용되지 않는 많은 상황으로 확장됩니다. 예를 들어, 일부 상자의 확률이 매우 낮고 개수가 대부분 0인 경우입니다.


## 1.5 이 장의 요약


우리는 몇 가지 기본 분포를 사용하여 다양한 이산 _이벤트_의 확률을 계산하기 위해 수학 공식과 R을 사용했습니다.


**_Bernoulli_ 분포**는 우리의 가장 기본적인 빌딩 블록이었습니다. 이는 동전 던지기와 같은 단일 이진 시행을 나타내는 데 사용됩니다. 결과를 0과 1로 코딩할 수 있습니다. \\(p\\)를 성공 확률(1번째 결과)이라고 부릅니다.


**_이항 분포**는 \\(n\\) 이진 시행에서 1의 개수에 사용되며, R 함수 `dbinom`을 사용하여 \\(k\\) 성공 확률을 계산할 수 있습니다. 또한 `rbinom` 함수를 사용하여 \\(n\\) 시행으로 이항 실험을 시뮬레이션하는 방법도 살펴보았습니다.


**_푸아송_ 분포**는 \\(p\\)가 작은 경우(1은 거의 발생하지 않음)에 가장 적합합니다. 여기에는 하나의 매개변수 \\(\lambda\\)만 있고 \\(\lambda=np\\)에 대한 포아송 분포는 \\(p\\)가 작은 경우 \\((n,p)\\)에 대한 이항 분포와 거의 동일합니다. 우리는 위치당 위양성 비율(\\(p\\))이 작다고 가정하고 시퀀스에 따라 에피토프를 테스트한 분석에서 무작위로 발생하는 위양성 수를 모델링하기 위해 포아송 분포를 사용했습니다. 우리는 모든 매개변수를 알고 있는 한 그러한 매개변수 모델을 통해 어떻게 극단적인 사건의 확률을 계산할 수 있는지 살펴보았습니다.


**_다항식_ 분포**는 3개 이상의 가능한 결과 또는 **수준**이 있는 개별 이벤트에 사용됩니다. 파워 예제에서는 동일한 확률을 갖는 다항 모델이 데이터와 일치하는지 테스트하려는 경우 몬테 카를로 시뮬레이션을 사용하여 수집해야 하는 데이터의 양을 결정하는 방법을 보여주었습니다. 우리는 생성 모델에 대한 가정을 통해 데이터가 어떻게 생성되었는지에 대한 가설을 평가하기 위해 확률 분포와 확률 모델을 사용했습니다. 가설이 주어졌을 때 데이터를 볼 확률을 **p-값**이라고 부릅니다. 이것은 가설이 참일 확률과는 다릅니다!


[![P\(H_0\\;|\\;\\text{data}\)는 p-값 P\(\\text{data}\\;|\\;H_0\)과 동일하지 않습니다.](imgs/devil.png)](imgs/devil.png "P\(H_0\\;|\\;\\text{data}\)는 p-값과 동일하지 않습니다. P\(\\텍스트{데이터}\\;|\\;H_0\).")


\\(P(H_0\;|\;\text{data})\\)는 p-값 \\(P(\text{data}\;|\;H_0)\\)과 동일하지 않습니다.


## 1.6 추가 자료


* Freedman, Pisani 및 Purves([1997](16-chap.html#ref-Freedman:1997))의 초등 서적은 여기서 언급하는 상자 모델 유형을 통해 확률에 대한 최고의 소개를 제공합니다.

* Durbin 등의 저서. ([1998](16-chap.html#ref-DEKM))은 많은 유용한 확률 분포를 다루고 있으며 부록에서 확률 이론의 이론적 배경과 생물학 시퀀스에 대한 적용에 대한 보다 완전한 보기를 제공합니다.

* 몬테카를로 방법은 현대 통계에서 광범위하게 사용됩니다. Robert와 Casella([2009](16-chap.html#ref-Casella2009))는 R을 사용하여 이러한 방법을 소개합니다.

* [6장](06-chap.html)에서는 가설 검정에 대한 내용을 다룹니다. 우리는 또한 데이터 분석에 자주 사용하는 고급 확률 분포, 베타, 감마, 지수 유형에 유용한 고급 자료에 대해 Rice([2006](16-chap.html#ref-Rice:2007))를 제안합니다.

## 1.7 연습


__


연습 1.1


R은 알려진 모든 분포에서 숫자를 생성할 수 있습니다. 이제 우리는 각 분포 유형에 맞춰진 특화된 R 함수를 사용하여 임의의 이산 데이터를 생성하는 방법을 알았습니다. 우리는 `rXXXX`에서와 같이 `r`로 시작하는 함수를 사용합니다. 여기서 `XXXX`는 `pois`, `binom`, `multinom`이 될 수 있습니다. 이러한 모델 중 하나에서 확률에 대한 이론적 계산이 필요한 경우 이산 이항 분포에서 사건의 확률을 계산하는 'dbinom'과 연속 정규 분포에 대한 확률 밀도 함수를 계산하는 'dnorm'과 같은 'dXXXX' 함수를 사용합니다. \\(P(X>a)\\)와 같은 꼬리 확률을 계산할 때 'pXXXX'라고 불리는 누적 분포 함수를 사용하는 것이 편리합니다. 위의 `XXXX`를 대체할 수 있는 두 개의 다른 이산 분포를 찾으십시오.


__


연습 1.2


이 장에서 우리는 확률이 셀 수 있는 값 세트에 집중되어 있는 이산적 무작위 변수에 집중했습니다. `dbinom`을 사용하여 이항식 \\(B(10, 0.3)\\)에 대해 \\(X=2\\) 값에서 _확률 질량_을 어떻게 계산합니까? `dbinom`을 사용하여 \\(P(X\leq 2)\\)에 해당하는 값 2에서 _누적_ 분포를 계산하고 다른 R 함수로 답을 확인하세요.


__


해결책


__




dbinom(2, 크기 = 10, 확률 = 0.3)__



[1] 0.2334744



pbinom(2, 크기 = 10, 확률 = 0.3)__



[1] 0.3827828



sum(dbinom(0:2, 크기 = 10, 확률 = 0.3)) __



[1] 0.3827828


__


연습 1.3


특정 명령 시퀀스가 ​​계속 필요하다는 것을 알 때마다 해당 명령을 함수에 넣는 것이 좋습니다. 함수 본문에는 우리가 반복해서 수행하려는 명령이 포함되어 있으며, 함수 인수는 우리가 변경하려는 항목을 사용합니다. '람다' 비율로 'n'개의 포아송 변수를 살펴볼 때 최대값이 'm'일 확률을 계산하는 함수를 작성하세요.


__


해결책


__




poismax = function(lambda, n, m) { epsilon = 1 - ppois(m - 1, lambda) 1 - exp( -n * epsilon) } poismax(lambda = 0.5, n = 100, m = 7)__



[1] 0.0001002329



poismax(람다 = 평균(e100), n = 100, m = 7)__



[1] 0.0001870183


__


연습 1.4


인수에 대한 기본값(즉, 함수 호출에서 인수가 지정되지 않은 경우 사용되는 값)을 갖도록 함수를 다시 작성합니다.


__


해결책


__




poismax = function(lambda, n = 100, m = 7) { 1 - exp( -n * (1 - ppois(m - 1, lambda))) } poismax(0.5)__



[1] 0.0001002329



포이즈맥스(0.5, m = 9)__



[1] 3.43549e-07


__


연습 1.5


에피토프 예에서는 시뮬레이션을 사용하여 100번의 시도에서 최대 9 이상일 확률을 찾습니다. "확률이 0.000001보다 작다"는 것을 증명하려면 몇 번의 시뮬레이션이 필요합니까?


__


연습 1.6


사용 가능한 배포판 목록을 얻으려면 R에서 `?Distributions`를 사용하세요17. 다양한 분포에 대한 확률 질량 또는 밀도 함수의 도표를 작성하고('dXXXX'라는 함수 사용) 이산형이 아닌 5개의 분포를 나열하십시오.


17 이는 기본 R 설치와 함께 제공되는 것들입니다. 추가 패키지에는 더 많은 내용이 있습니다. [CRAN 작업 보기: 확률 분포](https://cran.r-project.org/web/views/Distributions.html)를 참조하세요.


__


연습 1.7


Poisson(3) 확률 변수의 인스턴스 100개를 생성합니다. 무슨 뜻인가요? R 함수 `var`로 계산된 분산은 무엇입니까?


__


연습 1.8


_기음. elegans_ 게놈 뉴클레오티드 빈도: _C의 미토콘드리아 서열입니다. elegans_ 가능성이 동일한 뉴클레오티드 모델과 일치합니까?


1. Bioconductor의 **[Biostrings](https://bioconductor.org/packages/Biostrings/)** 패키지에 있는 전용 기능을 사용하여 염색체 M의 뉴클레오티드 빈도를 탐색해 보세요.

2. _C. elegans_ 데이터는 시뮬레이션을 사용하여 균일 모델(모든 뉴클레오티드 빈도가 동일)과 일치합니다. 힌트: 이번이 처음으로 Bioconductor를 사용해 볼 수 있는 기회입니다. Bioconductor의 패키지 관리는 CRAN보다 더 엄격하게 제어되므로 Bioconductor 패키지를 설치하려면 **[BiocManager](https://cran.r-project.org/web/packages/BiocManager/)** 패키지의 특수 '설치' 기능을 사용해야 합니다.



if (!requireNamespace("BiocManager", 조용히 = TRUE)) install.packages("BiocManager") BiocManager::install(c("Biostrings", "BSgenome.Celegans.UCSC.ce2"))__


그런 다음 다른 R 패키지를 로드할 때 게놈 시퀀스 패키지를 로드할 수 있습니다.


__


해결책


__




library("BSgenome.Celegans.UCSC.ce2") 셀레간스 __



| 웜용 BSgenome 개체 | - 유기체: Caenorhabditis elegans | - 제공자: UCSC | - 게놈: ce2 | - 출시일: 2004년 3월 | - 7개 시퀀스: |     chrI chrII chrIII chrIV chrV chrX chrM | | 팁: 모든 시퀀스 이름을 얻으려면 객체에 대해 'seqnames()'를 호출하고 | 전체 시퀀스 정보를 얻으려면 'seqinfo()', '$' 또는 '[[' 연산자를 사용하여 | 주어진 서열에 접근하세요. 자세한 내용은 '?BSgenome'을 참조하세요.



시퀀스 이름(Celegans)__



[1] "chrI" "chrII" "chrIII" "chrIV" "chrV" "chrX" "chrM"



셀레간스$chrM __



13794-문자 DNAString 개체 시퀀스: CAGTAAATAGTTTAATAAAAATATAGCATTTGGGTT...TATTTATAGATATATACTTTGTATATATCTATATTA



클래스(셀레간스$chrM)__



[1] "DNAString" attr(,"package") [1] "바이오스트링"



길이(셀레간스$chrM)__



[1] 13794



library("바이오스트링") lfM = letterFrequency(Celegans$chrM, letter=c("A", "C", "G", "T")) lfM __



A C G T 4335 1225 2055 6179



합(lfM)__



[1] 13794



lfM / 합계(lfM)__



A C G T 0.31426707 0.08880673 0.14897782 0.44794838


_C와 길이가 동일한 무작위(확률이 동일한 각 문자) 시퀀스를 만듭니다. 엘레강스_염색체 M:




t(rmultinom(1, length(Celegans$chrM), p = 담당자(1/4, 4)))__



[,1] [,2] [,3] [,4] [1,] 3409 3486 3476 3423


예상 빈도는 다음과 같습니다.




길이(Celegans$chrM) / 4 __



[1] 3448.5


두 개의 다항식 출력이 서로 얼마나 가까운지 측정하는 통계를 계산해 보겠습니다. 관측된(`o`) 개수와 예상되는(`e`) 개수 사이의 평균 제곱 차이를 'e'로 스케일링해 보겠습니다. 우리는 `oestat` 함수를 호출할 것입니다.




oestat = function(o, e) { sum((o-e)^2 / e) } oe = oestat(o = lfM, e = length(Celegans$chrM) / 4) oe __



[1] 4386.634


이것이 무작위성이 설명할 수 있는 것보다 더 큰가요? 우리는 이미 null 모델에서 기대할 수 있는 일련의 일반적인 개수를 살펴보았습니다. 그러나 우리에게는 가치의 전체 집합(분포)이 필요합니다. 함수를 여러 번 평가하는 복제 함수를 사용하여 이를 계산합니다. 우리는 다음을 실행합니다:




B = 10000 n = length(Celegans$chrM) expected = rep(n / 4, 4) oenull = replicate(B, oestat(e = expected, o = rmultinom(1, n, p = rep(1/4, 4))))__


더빈, 리차드, 션 에디, 앤더스 크로그, 그레이엄 미치슨. 1998. _생물학적 서열 분석_. 케임브리지 대학 출판부.


프리드먼, 데이비드, 로버트 피사니, 로저 퍼브스. 1997. _통계_. 뉴욕, 뉴욕: WW 노턴.


라이스, 존. 2006. _수학적 통계 및 데이터 분석_. 센게이지 학습.


로버트, 크리스찬, 조지 카셀라. 2009. _R을 이용한 몬테카를로 방법 소개_. Springer 과학 및 비즈니스 미디어.


R 버전 4.5.1(2025-06-13)을 사용하여 2025-09-01 01:33에 작성된 페이지


