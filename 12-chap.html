<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>14&nbsp; 지도 학습 (Supervised Learning) – Modern Statistics for Modern Biology</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./13-chap.html" rel="next">
<link href="./11-chap.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-ed96de9b727972fe78a7b5d16c58bf87.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-45c1b2e5a2b0567ccfb99e4dfc03f650.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="msmb.css">
</head>

<body class="nav-sidebar docked quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./12-chap.html"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">지도 학습 (Supervised Learning)</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Modern Statistics for Modern Biology</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">홈</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./00-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">이 책에는 무엇이 들어있나요?</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">1.2 실제 예제</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">매개변수가 핵심입니다.</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">3.2 기본 R 플로팅</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">4.2 유한 혼합물</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">5.2 데이터란 무엇이며 왜 군집화하는가?</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">6.1.1 쏟아지는 데이터 속에서 정보 찾기</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">7.2 데이터란 무엇인가? 행렬과 그 동기</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./08-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">8.2 몇 가지 핵심 개념</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./09-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">9.2 다차원 척도법과 서열화 (Ordination)</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./10-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">10.2 그래프(Graphs)</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./11-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">11.1 이 장의 목표</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./12-chap.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">지도 학습 (Supervised Learning)</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./13-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">13.1 이 장의 목표</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./14-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">14-chap.html</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./15-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">15-chap.html</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./16-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">16-chap.html</span></span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#이-장의-목표" id="toc-이-장의-목표" class="nav-link active" data-scroll-target="#이-장의-목표"><span class="header-section-number">14.1</span> 12.1 이 장의 목표</a></li>
  <li><a href="#데이터란-무엇인가" id="toc-데이터란-무엇인가" class="nav-link" data-scroll-target="#데이터란-무엇인가"><span class="header-section-number">14.2</span> 12.2 데이터란 무엇인가?</a>
  <ul class="collapse">
  <li><a href="#동기-부여-예시" id="toc-동기-부여-예시" class="nav-link" data-scroll-target="#동기-부여-예시"><span class="header-section-number">14.2.1</span> 12.2.1 동기 부여 예시</a></li>
  </ul></li>
  <li><a href="#선형-판별-linear-discrimination" id="toc-선형-판별-linear-discrimination" class="nav-link" data-scroll-target="#선형-판별-linear-discrimination"><span class="header-section-number">14.3</span> 12.3 선형 판별 (Linear discrimination)</a>
  <ul class="collapse">
  <li><a href="#당뇨병-데이터" id="toc-당뇨병-데이터" class="nav-link" data-scroll-target="#당뇨병-데이터"><span class="header-section-number">14.3.1</span> 12.3.1 당뇨병 데이터</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">지도 학습 (Supervised Learning)</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p><img src="imgs/BuildWall.png" class="img-fluid"></p>
<p><img src="imgs/EWall.png" class="img-fluid"></p>
<p>지도 학습(Supervised Learning) 환경에서는 우리가 얼마나 잘하고 있는지를 판단할 수 있는 잣대, 바로 반응 변수(response) 그 자체가 존재합니다.</p>
<p>생물학 및 생물의학 응용 분야에서 자주 묻는 질문은 관심 있는 속성(예: 질병 유형, 세포 유형, 환자의 예후)을 다른 하나 이상의 속성, 즉 <strong>예측 변수(predictors)</strong>를 통해 “예측”할 수 있는지 여부입니다. 종종 우리는 예측해야 할 속성은 알 수 없지만(미래에 있거나 측정하기 어려운 경우), 예측 변수는 알고 있는 상황에 직면합니다. 중요한 점은 관심 있는 속성 또한 알고 있는 <strong>학습 데이터(training data)</strong> 집합으로부터 예측 규칙을 <em>학습</em> 한다는 것입니다. 규칙을 확보하고 나면, 이를 새로운 데이터에 적용하여 알 수 없는 결과를 실제로 예측하거나, 기저에 있는 생물학적 원리를 더 잘 이해하기 위해 규칙 자체를 분석할 수 있습니다.</p>
<p>우리가 무엇을 찾고 있는지, 또는 결과가 “맞는지” 어떻게 결정해야 할지 모르는 비지도 학습(Unsupervised Learning)이나 <a href="05-chap.html">5장</a>, <a href="07-chap.html">7장</a>, <a href="09-chap.html">9장</a>에서 본 내용과 비교할 때, 지도 학습은 훨씬 더 확고한 기반 위에 있습니다. 목표가 명확하게 명시되어 있고, 우리가 얼마나 잘하고 있는지 측정할 수 있는 간단한 기준이 있기 때문입니다.</p>
<p><strong>지도 학습</strong> 1의 핵심 이슈는 <strong>과적합(overfitting)</strong>과 <strong>일반화 가능성(generalizability)</strong>입니다. 훈련 데이터에 대해 100% 정확도를 가지지만 새로운 데이터에 대해서는 형편없는 성능을 보이는 규칙을 만들어 훈련 데이터를 단순히 “암기”한 것일까요? 아니면 우리의 규칙이 연구 중인 시스템의 적절한 패턴을 실제로 포착하여 아직 보지 못한 새로운 데이터에도 적용될 수 있을까요? (그림 12.1)</p>
<p>1 때때로 <strong>통계적 학습(statistical learning)</strong>이라는 용어가 거의 같은 의미로 사용됩니다.</p>
<p><a href="12-chap_files/figure-html/fig-overfitting-1-1.png" title="그림 12.1: 과적합의 예: 두 회귀선이 (x, y)-평면의 데이터(검은 점)에 적합되었습니다. 우리는 이러한 선을 (x) 값이 주어졌을 때 (y) 값을 예측하는 규칙으로 생각할 수 있습니다. 두 선 모두 부드럽지만, 적합(fit)은 대역폭(bandwidth)이라고 불리는 것에서 차이가 나며, 이는 직관적으로 경직성(stiffness)으로 해석될 수 있습니다. 파란색 선은 데이터의 사소한 움직임까지 지나치게 따라가려는 것처럼 보이는 반면, 주황색 선은 전반적인 추세는 포착하지만 세부적인 것은 덜합니다. 파란색 선을 설명하는 데 필요한 유효 매개변수(effective parameters)의 수는 주황색 선보다 훨씬 높습니다. 또한, 추가 데이터를 얻게 된다면 파란색 선은 주황색 선보다 새로운 데이터를 모델링하는 데 더 나쁜 성능을 보일 가능성이 높습니다. 이 장의 뒷부분에서 이러한 개념들 – 훈련 오차(training error)와 테스트 세트 오차(test set error) – 을 공식화할 것입니다. 여기서는 선 적합(line fitting)으로 예시를 들었지만, 이 개념은 예측 모델에 더 일반적으로 적용됩니다."><img src="12-chap_files/figure-html/fig-overfitting-1-1.png" class="img-fluid"></a></p>
<p>그림 12.1: <strong>과적합(overfitting)</strong>의 예: 두 회귀선이 ((x, y))-평면의 데이터(검은 점)에 적합되었습니다. 우리는 이러한 선을 (x) 값이 주어졌을 때 (y) 값을 예측하는 규칙으로 생각할 수 있습니다. 두 선 모두 부드럽지만, 적합(fit)은 <strong>대역폭(bandwidth)</strong>이라고 불리는 것에서 차이가 나며, 이는 직관적으로 경직성(stiffness)으로 해석될 수 있습니다. 파란색 선은 데이터의 사소한 움직임까지 지나치게 따라가려는 것처럼 보이는 반면, 주황색 선은 전반적인 추세는 포착하지만 세부적인 것은 덜합니다. 파란색 선을 설명하는 데 필요한 유효 매개변수(effective parameters)의 수는 주황색 선보다 훨씬 높습니다. 또한, 추가 데이터를 얻게 된다면 파란색 선은 주황색 선보다 새로운 데이터를 모델링하는 데 더 <strong>나쁜</strong> 성능을 보일 가능성이 높습니다. 이 장의 뒷부분에서 이러한 개념들 – 훈련 오차(training error)와 테스트 세트 오차(test set error) – 을 공식화할 것입니다. 여기서는 선 적합(line fitting)으로 예시를 들었지만, 이 개념은 예측 모델에 더 일반적으로 적용됩니다.</p>
<section id="이-장의-목표" class="level2" data-number="14.1">
<h2 data-number="14.1" class="anchored" data-anchor-id="이-장의-목표"><span class="header-section-number">14.1</span> 12.1 이 장의 목표</h2>
<p>이 장에서는 다음을 수행합니다:</p>
<ul>
<li><p>지도 학습 방법의 사용 동기가 되는 예시적인 응용 사례를 살펴봅니다.</p></li>
<li><p>판별 분석(discriminant analysis)이 무엇을 하는지 배웁니다.</p></li>
<li><p>성능 척도(measures of performance)를 정의합니다.</p></li>
<li><p>차원의 저주(curse of dimensionality)를 접하고 과적합(overfitting)이 무엇인지 알아봅니다.</p></li>
<li><p>정규화(regularization) – 특히 벌점화(penalization) – 에 대해 알아보고 일반화 가능성(generalizability)과 모델 복잡성(model complexity)의 개념을 이해합니다.</p></li>
<li><p>교차 검증(cross-validation)을 사용하여 알고리즘의 매개변수를 조정하는 방법을 살펴봅니다.</p></li>
<li><p>방법론 해킹(method hacking)에 대해 논의합니다.</p></li>
</ul>
</section>
<section id="데이터란-무엇인가" class="level2" data-number="14.2">
<h2 data-number="14.2" class="anchored" data-anchor-id="데이터란-무엇인가"><span class="header-section-number">14.2</span> 12.2 데이터란 무엇인가?</h2>
<p>지도 학습과 비지도 학습 모두에 대한 기본적인 데이터 구조는 (적어도 개념적으로는) 데이터프레임입니다. 여기서 각 행은 객체(object)에 해당하고 열은 객체의 다른 특징(feature, 주로 숫자 값)입니다2. 비지도 학습에서는 특징 값을 기반으로 객체 간의 (비)유사성 관계를 찾는 것(예: 군집화 또는 정렬)을 목표로 하는 반면, 지도 학습에서는 다른 특징들로부터 특징 중 하나의 값을 예측하는 수학적 함수(또는 계산 알고리즘)를 찾는 것을 목표로 합니다. 많은 구현체들은 결측치(missing values)가 없어야 작동하지만, 일부 방법은 약간의 결측 데이터가 있어도 작동하도록 만들 수 있습니다.</p>
<p>2 이것은 단순화된 설명입니다. 기계 학습(Machine Learning)은 거대한 분야이며, 이 단순한 개념적 그림에 대한 많은 일반화가 이루어졌습니다. 이미 관련 특징을 구축하는 것 자체가 하나의 예술입니다. <a href="11-chap.html">11장</a>에서 세포 이미지의 예를 보았고, 더 일반적으로 이미지, 소리, 영화, 자유 텍스트 등에서 특징을 추출할 수 있는 많은 가능성이 있습니다 … 또한, 특징이 전혀 필요 없는 <strong>커널 방법(kernel methods)</strong>이라는 기계 학습 방법의 변형도 있습니다. 대신 커널 방법은 객체 간의 거리 또는 유사성 척도를 사용합니다. 예를 들어, 두 자연어텍스트 객체를 나타낼 관련 수치 특징을 찾는 것보다 두 객체 간의 유사성 척도를 정의하는 것이 더 쉬울 수 있습니다. 커널 방법은 이 책의 범위를 벗어납니다.</p>
<p>예측을 목표로 다른 모든 특징들 중에서 선택한 특징을 <strong>목표(objective)</strong> 또는 <strong>반응(response)</strong>이라고 합니다. 때로는 선택이 자연스럽지만, 때로는 역할을 뒤집는 것이 유익할 수 있습니다. 특히 생물학적 이해를 위해 예측 함수를 분석하거나 상관관계와 인과관계를 구분하는 데 관심이 있다면 더욱 그렇습니다.</p>
<p>지도 학습의 프레임워크는 연속형 및 범주형 반응 변수를 모두 포괄합니다. 연속형인 경우 <strong>회귀(regression)</strong>라고 하고, 범주형인 경우 <strong>분류(classification)</strong>라고 합니다. 이 구분은 사소한 것이 아닙니다. 손실 함수 (12.5절) 선택과 그에 따른 알고리즘 선택에 꽤 광범위한 영향을 미치기 때문입니다 (<a href="16-chap.html#ref-friedmanbiasvariance01">Friedman 1997</a>).</p>
<p>모든 지도 학습 작업에서 고려해야 할 첫 번째 질문은 객체의 수가 예측 변수의 수와 어떻게 비교되는지입니다. 객체가 많을수록 좋으며, 지도 학습에서의 많은 힘든 작업은 유한한(그리고 일반적으로 너무 작은) 훈련 세트가 가진 한계를 극복하는 것과 관련이 있습니다.</p>
<p><a href="imgs/fourquad.png" title="그림 12.2: 지도 학습에서 우리는 변수에 두 가지 다른 역할을 부여합니다. 설명 변수를 X, 반응 변수(들)를 Y라고 라벨링했습니다. 또한 두 가지 다른 관측값 세트가 있습니다: 훈련 세트 X_\ell과 Y_\ell, 그리고 테스트 세트 X_v와 Y_v.(아래첨자는 두 세트의 다른 이름인 “learning”과 “validation”을 나타냅니다.)"><img src="imgs/fourquad.png" class="img-fluid"></a></p>
<p>그림 12.2: 지도 학습에서 우리는 변수에 두 가지 다른 역할을 부여합니다. 설명 변수를 (X), 반응 변수(들)를 (Y)라고 라벨링했습니다. 또한 두 가지 다른 관측값 세트가 있습니다: 훈련 세트 (X_)과 (Y_), 그리고 테스트 세트 (X_v)와 (Y_v). (아래첨자는 두 세트의 다른 이름인 “learning”과 “validation”을 나타냅니다.)</p>
<p>__</p>
<p>일</p>
<p>이 책에서 범주형 반응 변수를 가진 지도 학습 사례를 접한 예시를 드시오.</p>
<section id="동기-부여-예시" class="level3" data-number="14.2.1">
<h3 data-number="14.2.1" class="anchored" data-anchor-id="동기-부여-예시"><span class="header-section-number">14.2.1</span> 12.2.1 동기 부여 예시</h3>
<section id="당뇨병-유형-예측" class="level4" data-number="14.2.1.1">
<h4 data-number="14.2.1.1" class="anchored" data-anchor-id="당뇨병-유형-예측"><span class="header-section-number">14.2.1.1</span> 당뇨병 유형 예측</h4>
<p><code>diabetes</code> 데이터셋(<a href="16-chap.html#ref-diabetes">Reaven and Miller 1979</a>)은 세 가지 다른 당뇨병 환자 그룹과 그들에게서 측정된 5가지 임상 변수를 제공합니다.</p>
<pre><code>data("diabetes", package = "rrcov")
head(diabetes)__


    rw fpg glucose insulin sspg  group
1 0.81  80     356     124   55 normal
2 0.95  97     289     117   76 normal
3 0.94 105     319     143  105 normal
4 1.04  90     356     199  108 normal
5 1.00  90     323     240  143 normal
6 0.76  86     381     157  165 normal</code></pre>
<p>일변량 분포(더 정확하게는 그것들의 밀도 추정치)는 그림 12.3에 나와 있습니다.</p>
<pre><code>library("reshape2")
ggplot(melt(diabetes, id.vars = "group"), aes(x = value, col = group)) +
 geom_density() + facet_wrap( ~variable, ncol = 1, scales = "free") +
 theme(legend.position = "bottom")__</code></pre>
<p><a href="12-chap_files/figure-html/fig-ldagroups-1-1.png" title="그림 12.3: 1차원 분포에서 이미 개별 변수 중 일부가 환자가 어떤 그룹에 속할 가능성이 높은지 잠재적으로 예측할 수 있음을 알 수 있습니다. 우리의 목표는 변수들을 결합하여 이러한 1차원 예측 모델보다 개선하는 것입니다."><img src="12-chap_files/figure-html/fig-ldagroups-1-1.png" class="img-fluid"></a></p>
<p>그림 12.3: 1차원 분포에서 이미 개별 변수 중 일부가 환자가 어떤 그룹에 속할 가능성이 높은지 잠재적으로 예측할 수 있음을 알 수 있습니다. 우리의 목표는 변수들을 결합하여 이러한 1차원 예측 모델보다 개선하는 것입니다.</p>
<p>변수들은 데이터셋의 매뉴얼 페이지와 논문(<a href="16-chap.html#ref-diabetes">Reaven and Miller 1979</a>)에 설명되어 있습니다:</p>
<ul>
<li><p>rw: 상대 체중 (relative weight)</p></li>
<li><p>fpg: 공복 혈장 포도당 (fasting plasma glucose)</p></li>
<li><p>glucose: 3시간 경구 포도당 내성 검사(OGTT)에 대한 혈장 포도당 곡선 아래 면적</p></li>
<li><p>insulin: OGTT에 대한 혈장 인슐린 곡선 아래 면적</p></li>
<li><p>sspg: 정상 상태 혈장 포도당 반응 (steady state plasma glucose response)</p></li>
<li><p>group: 정상(normal), 화학적 당뇨병(chemical diabetes), 명백한 당뇨병(overt diabetes)</p></li>
</ul>
</section>
<section id="세포-표현형-예측" class="level4" data-number="14.2.1.2">
<h4 data-number="14.2.1.2" class="anchored" data-anchor-id="세포-표현형-예측"><span class="header-section-number">14.2.1.2</span> 세포 표현형 예측</h4>
<p>Neumann 등(<a href="16-chap.html#ref-Neumann:2010">2010</a>)은 라이브 셀 이미징(live-cell imaging)을 사용하여 인간 암세포를 관찰했습니다. 세포의 히스톤이 녹색 형광 단백질(GFP)로 태그되도록 유전적으로 조작되었습니다. 게놈 전체 RNAi 라이브러리를 세포에 적용했고, 각 siRNA 교란에 대해 며칠 동안 수백 개의 세포 영상을 기록하여 각 유전자의 고갈이 세포 주기, 핵 형태 및 세포 증식에 어떤 영향을 미치는지 확인했습니다. 그들의 논문은 각 세포 핵의 시각적 외관을 정량화하고 정상적인 유사 분열 상태 또는 비정상적인 핵을 예측할 수 있게 해주는 자동화된 이미지 분류 알고리즘의 사용을 보고합니다. 이 알고리즘은 인간 전문가가 주석을 단 약 3000개의 세포 데이터로 훈련되었습니다. 그런 다음 거의 20억 개의 핵 이미지에 적용되었습니다(그림 12.4). 자동화된 이미지 분류를 사용하여 확장성(20억 개의 이미지를 수동으로 주석 처리하는 데는 오랜 시간이 걸릴 것입니다)과 객관성을 제공했습니다.</p>
<p><a href="imgs/Neumann2010Fig1b_web.jpg" title="그림 12.4: 데이터는 영상에서 나온 2\times10^9핵의 이미지였습니다. 이미지는 핵을 식별하기 위해 분할되었고, 각 핵에 대해 크기, 모양, 밝기 및 픽셀 강도의 결합 분포에 대한 다소 추상적인 정량적 요약에 해당하는 수치 특징이 계산되었습니다. 특징으로부터 세포는 16가지 다른 핵 형태 클래스로 분류되었으며, 막대 그래프의 행으로 표시됩니다. 각 클래스에 대한 대표 이미지는 가운데 열에 흑백으로 표시됩니다. 클래스 빈도는 막대의 길이로 표시되며 매우 불균형합니다."><img src="imgs/Neumann2010Fig1b_web.jpg" class="img-fluid"></a></p>
<p>그림 12.4: 데이터는 영상에서 나온 (2^9)개 핵의 이미지였습니다. 이미지는 핵을 식별하기 위해 분할되었고, 각 핵에 대해 크기, 모양, 밝기 및 픽셀 강도의 결합 분포에 대한 다소 추상적인 정량적 요약에 해당하는 수치 특징이 계산되었습니다. 특징으로부터 세포는 16가지 다른 핵 형태 클래스로 분류되었으며, 막대 그래프의 행으로 표시됩니다. 각 클래스에 대한 대표 이미지는 가운데 열에 흑백으로 표시됩니다. 클래스 빈도는 막대의 길이로 표시되며 매우 불균형합니다.</p>
</section>
<section id="배아-세포-상태-예측" class="level4" data-number="14.2.1.3">
<h4 data-number="14.2.1.3" class="anchored" data-anchor-id="배아-세포-상태-예측"><span class="header-section-number">14.2.1.3</span> 배아 세포 상태 예측</h4>
<p>우리는 <a href="03-chap.html">3장</a>, <a href="05-chap.html">5장</a>, <a href="07-chap.html">7장</a>에서 이미 본 마우스 배아 데이터(<a href="16-chap.html#ref-Ohnishi2014">Ohnishi et al.&nbsp;2014</a>)를 다시 살펴볼 것입니다. 12.3.2절과 12.6.3절에서 유전자 발현 측정값으로부터 세포 상태와 유전자형을 예측해 보겠습니다.</p>
</section>
</section>
</section>
<section id="선형-판별-linear-discrimination" class="level2" data-number="14.3">
<h2 data-number="14.3" class="anchored" data-anchor-id="선형-판별-linear-discrimination"><span class="header-section-number">14.3</span> 12.3 선형 판별 (Linear discrimination)</h2>
<p>가장 간단한 판별 문제 중 하나부터 시작해 보겠습니다3. 두 개의 연속형 특징으로 설명되는(따라서 객체는 2D 평면의 점으로 생각할 수 있는) 객체가 있고, 이들은 세 그룹으로 나뉩니다. 우리의 목표는 2D 공간의 선인 클래스 경계를 정의하는 것입니다.</p>
<p>3 틀림없이 가장 간단한 문제는 단일 연속형 특징, 두 개의 클래스, 그리고 두 그룹을 구별하기 위한 단일 임계값을 찾는 작업입니다 – <a href="06-chap.html#fig-testing-FDRvspstatic1">그림 6.2</a>와 같이.</p>
<section id="당뇨병-데이터" class="level3" data-number="14.3.1">
<h3 data-number="14.3.1" class="anchored" data-anchor-id="당뇨병-데이터"><span class="header-section-number">14.3.1</span> 12.3.1 당뇨병 데이터</h3>
<p><code>diabetes</code> 데이터의 <code>sspg</code>와 <code>glucose</code> 변수로부터 <code>group</code>을 예측할 수 있는지 알아봅시다. 먼저 데이터를 시각화하는 것이 항상 좋은 아이디어입니다(그림 12.5).</p>
<pre><code>ggdb = ggplot(mapping = aes(x = sspg, y = glucose)) +
  geom_point(aes(colour = group), data = diabetes)
ggdb __</code></pre>
<p><a href="12-chap_files/figure-html/fig-scatterdiabetes-1-1.png" title="그림 12.5: 당뇨병 데이터의 두 변수에 대한 산점도. 각 점은 샘플이며, 색상은 group 변수에 인코딩된 당뇨병 유형을 나타냅니다."><img src="12-chap_files/figure-html/fig-scatterdiabetes-1-1.png" class="img-fluid"></a></p>
<p>그림 12.5: <code>diabetes</code> 데이터의 두 변수에 대한 산점도. 각 점은 샘플이며, 색상은 <code>group</code> 변수에 인코딩된 당뇨병 유형을 나타냅니다.</p>
<p><strong>선형 판별 분석(Linear Discriminant Analysis, LDA)</strong>이라는 방법으로 시작하겠습니다. 이 방법은 분류의 초석이며, 더 복잡한(그리고 때로는 더 강력한) 알고리즘 중 많은 것들이 실제로는 LDA의 일반화일 뿐입니다.</p>
<pre><code>library("MASS")
diabetes_lda = lda(group ~ sspg + glucose, data = diabetes)
diabetes_lda __


Call:
lda(group ~ sspg + glucose, data = diabetes)

Prior probabilities of groups:
   normal  chemical     overt 
0.5241379 0.2482759 0.2275862 

Group means:
             sspg   glucose
normal   114.0000  349.9737
chemical 208.9722  493.9444
overt    318.8788 1043.7576

Coefficients of linear discriminants:
                LD1         LD2
sspg    0.005036943 -0.01539281
glucose 0.005461400  0.00449050

Proportion of trace:
   LD1    LD2 
0.9683 0.0317 


ghat = predict(diabetes_lda)$class
table(ghat, diabetes$group)__


          
ghat       normal chemical overt
  normal       69       12     1
  chemical      7       24     6
  overt         0        0    26


mean(ghat != diabetes$group)__


[1] 0.1793103</code></pre>
<p>__</p>
<p>질문 12.1</p>
<p>위 출력의 다른 부분들은 무엇을 의미합니까?</p>
<p>이제 LDA 결과를 시각화해 보겠습니다. 각 세 그룹에 대한 예측 영역을 그릴 것입니다. 이를 위해 점 그리드를 만들고 각각에 대해 예측 규칙을 사용합니다. 그런 다음 LDA의 메커니즘을 좀 더 깊이 파고들어 클래스 중심(<code>diabetes_lda$means</code>)과 적합된 공분산 행렬(<code>diabetes_lda$scaling</code>)에 해당하는 타원을 그릴 것입니다. 이 시각화를 조립하려면 약간의 코드를 작성해야 합니다.</p>
<pre><code>make1Dgrid = function(x) {
  rg = grDevices::extendrange(x)
  seq(from = rg[1], to = rg[2], length.out = 100)
}__</code></pre>
<p>데이터 범위를 커버하는 (100 ) 그리드인 예측용 점들을 설정합니다.</p>
<pre><code>diabetes_grid = with(diabetes,
  expand.grid(sspg = make1Dgrid(sspg),
              glucose = make1Dgrid(glucose)))</code></pre>
<p>예측을 수행합니다.</p>
<pre><code>diabetes_grid$ghat =
  predict(diabetes_lda, newdata = diabetes_grid)$class __</code></pre>
<p>그룹 중심입니다.</p>
<pre><code>centers = diabetes_lda$means __</code></pre>
<p>타원을 계산합니다. 단위원(360개의 변을 가진 다각형으로 근사)에서 시작하여 LDA 출력의 해당 아핀 변환(affine transformation)을 적용합니다.</p>
<pre><code>unitcircle = exp(1i * seq(0, 2*pi, length.out = 360)) |&gt;
          (\(z) cbind(Re(z), Im(z)))() 
ellipse = unitcircle %*% solve(diabetes_lda$scaling) |&gt; as_tibble()__</code></pre>
<p>세 개의 타원 모두, 각 그룹 중심에 하나씩입니다.</p>
<pre><code>library("dplyr")
ellipses = lapply(rownames(centers), function(gr) {
  mutate(ellipse, 
     sspg    = sspg    + centers[gr, "sspg"],
     glucose = glucose + centers[gr, "glucose"],
     group   = gr)
}) |&gt; bind_rows()__</code></pre>
<p>이제 그릴 준비가 되었습니다 (그림 12.6).</p>
<pre><code>ggdb + geom_raster(aes(fill = ghat),
            data = diabetes_grid, alpha = 0.25, interpolate = TRUE) +
    geom_point(data = as_tibble(centers), pch = "+", size = 8) +
    geom_path(aes(colour = group), data = ellipses) +
    scale_x_continuous(expand = c(0, 0)) +
    scale_y_continuous(expand = c(0, 0))__</code></pre>
<p><a href="12-chap_files/figure-html/fig-modeldiabetes-1-1.png" title="그림 12.6: 그림 12.5와 동일하지만, LDA 모델의 분류 영역이 표시되어 있습니다. 세 개의 타원은 클래스 중심과 LDA 모델의 공분산 행렬을 나타냅니다. 공분산 행렬은 단 하나뿐이며 세 클래스 모두에 대해 동일하다는 점에 유의하십시오. 따라서 타원의 크기와 방향도 세 클래스 모두에 대해 동일하며 중심만 다릅니다. 이들은 동일한 클래스 멤버십 확률의 등고선을 나타냅니다."><img src="12-chap_files/figure-html/fig-modeldiabetes-1-1.png" class="img-fluid"></a></p>
<p>그림 12.6: 그림 12.5와 동일하지만, LDA 모델의 분류 영역이 표시되어 있습니다. 세 개의 타원은 클래스 중심과 LDA 모델의 공분산 행렬을 나타냅니다. 공분산 행렬은 단 하나뿐이며 세 클래스 모두에 대해 동일하다는 점에 유의하십시오. 따라서 타원의 크기와 방향도 세 클래스 모두에 대해 동일하며 중심만 다릅니다. 이들은 동일한 클래스 멤버십 확률의 등고선을 나타냅니다.</p>
<p>__</p>
<p>질문 12.2</p>
<p><em>chemical</em> 과 <em>overt</em> 사이의 예측 영역 경계가 그룹 중심 사이의 선과 수직이 아닌 이유는 무엇입니까?</p>
<p>__</p>
<p>해결책</p>
<p>__</p>
<p>타원이 원이라면 경계는 수직일 것입니다. 일반적으로 경계는 동일 클래스 확률의 등고선에 접하며, 등고선의 타원 형태로 인해 경계는 일반적으로 중심 사이의 선과 수직이 아닙니다.</p>
<p>__</p>
<p>질문 12.3</p>
<p>모든 군집 중심에서 멀리 떨어진 2D 평면 영역에서의 예측에 대해 얼마나 확신할 수 있습니까?</p>
<p>__</p>
<p>해결책</p>
<p>__</p>
<p>어떤 군집 중심에서도 멀리 떨어진 예측은 비판적으로 평가해야 합니다. 이는 LDA 모델이 좋지 않을 수 있거나 예측을 뒷받침할 훈련 데이터가 근처에 없을 수 있는 영역으로의 외삽(extrapolation)에 해당하기 때문입니다. 가장 가까운 중심까지의 거리를 특정 지점에 대한 예측 신뢰도의 척도로 사용할 수 있습니다. 그러나 리샘플링 및 교차 검증 기반 방법이 더 일반적이고 보통 더 신뢰할 수 있는 척도를 제공한다는 것을 보게 될 것입니다.</p>
<p>__</p>
<p>질문 12.4</p>
<p><em>normal</em> 과 <em>chemical</em> 사이의 예측 영역 경계가 중심 사이의 중간이 아니라 <em>normal</em> 에 유리하게 이동된 이유는 무엇입니까? 힌트: <code>lda</code>의 <code>prior</code> 인수를 살펴보세요. 균일 사전 확률(uniform prior)로 다시 시도해 보세요.</p>
<p>__</p>
<p>해결책</p>
<p>__</p>
<p>다음 코드 청크의 결과는 그림 12.7에 나와 있습니다. 접미사 <code>_up</code>은 “uniform prior”의 줄임말입니다.</p>
<pre><code>diabetes_up = lda(group ~ sspg + glucose, data = diabetes,
  prior = (\(n) rep(1/n, n)) (nlevels(diabetes$group)))

diabetes_grid$ghat_up =
  predict(diabetes_up, newdata = diabetes_grid)$class

stopifnot(all.equal(diabetes_up$means, diabetes_lda$means))

ellipse_up  = unitcircle %*% solve(diabetes_up$scaling) |&gt; as_tibble()
ellipses_up = lapply(rownames(centers), function(gr) {
  mutate(ellipse_up, 
     sspg    = sspg    + centers[gr, "sspg"],
     glucose = glucose + centers[gr, "glucose"],
     group   = gr)
}) |&gt; bind_rows()

ggdb + geom_raster(aes(fill = ghat_up),
            data = diabetes_grid, alpha = 0.4, interpolate = TRUE) +
    geom_point(data = data.frame(centers), pch = "+", size = 8) +
    geom_path(aes(colour = group), data = ellipses_up) +
    scale_x_continuous(expand = c(0, 0)) +
    scale_y_continuous(expand = c(0, 0))__</code></pre>
<p><a href="12-chap_files/figure-html/fig-diabetes-lda-uniform-prior-1-1.png" title="그림 12.7: 그림 12.6과 동일하지만, 균일 클래스 사전 확률을 사용했습니다."><img src="12-chap_files/figure-html/fig-diabetes-lda-uniform-prior-1-1.png" class="img-fluid"></a></p>
<p>그림 12.7: 그림 12.6과 동일하지만, 균일 클래스 사전 확률을 사용했습니다.</p>
<p><code>stopifnot</code> 라인은 클래스 중심이 사전 확률과 독립적이기 때문에 동일함을 확인해 줍니다. 결합 공분산은 그렇지 않습니다.</p>
<p>__</p>
<p>질문 12.5</p>
<p>그림 12.6과 12.7은 타원을 통한 적합된 LDA 모델과 영역 색칠을 통한 예측 영역을 모두 보여줍니다. 이 시각화의 어떤 부분이 모든 종류의 분류 방법에 대해 일반적이며, 어떤 부분이 방법 특정적입니까?</p>
<p>__</p>
<p>해결책</p>
<p>__</p>
<p>예측 영역은 “블랙박스” 방법을 포함한 모든 분류 방법에 대해 표시될 수 있습니다. 그림 12.6과 12.7의 군집 중심과 타원은 방법 특정적입니다.</p>
<p>__</p>
<p>질문 12.6</p>
<p><code>glucose</code>와 <code>sspg</code>만 사용하는 대신 5개의 변수를 모두 사용하면 예측 정확도에 어떤 차이가 있습니까?</p>
<p>__</p>
<p>해결책</p>
<p>__</p>
<pre><code>diabetes_lda5 = lda(group ~ rw + fpg + glucose + sspg + insulin, data = diabetes)
diabetes_lda5 __


Call:
lda(group ~ rw + fpg + glucose + sspg + insulin, data = diabetes)

Prior probabilities of groups:
   normal  chemical     overt 
0.5241379 0.2482759 0.2275862 

Group means:
                rw       fpg   glucose     sspg  insulin
normal   0.9372368  91.18421  349.9737 114.0000 172.6447
chemical 1.0558333  99.30556  493.9444 208.9722 288.0000
overt    0.9839394 217.66667 1043.7576 318.8788 106.0000

Coefficients of linear discriminants:
                  LD1          LD2
rw       1.3624356881 -3.784142444
fpg     -0.0336487883  0.036633317
glucose  0.0125763942 -0.007092017
sspg     0.0042431866  0.001134070
insulin -0.0001022245 -0.006173424

Proportion of trace:
   LD1    LD2 
0.8812 0.1188 


ghat5 = predict(diabetes_lda5)$class
table(ghat5, diabetes$group)__


          
ghat5      normal chemical overt
  normal       73        5     1
  chemical      3       31     5
  overt         0        0    27


mean(ghat5 != diabetes$group)__


[1] 0.09655172</code></pre>
<p>__</p>
<p>Question 12.7</p>
<p>점 그리드로부터 분류하여 예측 영역을 근사하는 대신, 선형 판별 계수로부터 구분선을 명시적으로 계산하세요.</p>
<p>__</p>
<p>Solution</p>
<p>__</p>
<p>(<a href="16-chap.html#ref-HastieTibshiraniFriedman">Hastie, Tibshirani, and Friedman 2008</a>)의 4.3절, 식 (4.10)을 참조하십시오.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./11-chap.html" class="pagination-link" aria-label="11.1 이 장의 목표">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">11.1 이 장의 목표</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./13-chap.html" class="pagination-link" aria-label="13.1 이 장의 목표">
        <span class="nav-page-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">13.1 이 장의 목표</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>