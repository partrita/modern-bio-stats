<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>14&nbsp; 12.1 Goals for this chapter – Modern Statistics for Modern Biology</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./13-chap.html" rel="next">
<link href="./11-chap.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-22854ec117201859c8a7ba6f538122c9.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="msmb.css">
</head>

<body class="nav-sidebar docked quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./12-chap.html"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">12.1 Goals for this chapter</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Modern Statistics for Modern Biology</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Home</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./00-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">The challenge: heterogeneity</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">1.1 Goals for this chapter</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">2.1 Goals for this chapter</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">3.1 Goals for this chapter</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">4.1 Goals for this chapter</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">5.1 Goals for this chapter</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">6.1 Goals for this Chapter</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">7.1 Goals for this chapter</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./08-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">8.1 Goals of this chapter</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./09-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">9.1 Goals for this chapter</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./10-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">10.1 Goals for this chapter</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./11-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">11.1 Goals for this chapter</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./12-chap.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">12.1 Goals for this chapter</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./13-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">13.1 Goals for this chapter</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./14-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">14-chap.html</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./15-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">15-chap.html</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./16-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">16-chap.html</span></span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#what-are-the-data" id="toc-what-are-the-data" class="nav-link active" data-scroll-target="#what-are-the-data"><span class="header-section-number">14.1</span> 12.2 What are the data?</a>
  <ul class="collapse">
  <li><a href="#motivating-examples" id="toc-motivating-examples" class="nav-link" data-scroll-target="#motivating-examples"><span class="header-section-number">14.1.1</span> 12.2.1 Motivating examples</a></li>
  </ul></li>
  <li><a href="#linear-discrimination" id="toc-linear-discrimination" class="nav-link" data-scroll-target="#linear-discrimination"><span class="header-section-number">14.2</span> 12.3 Linear discrimination</a>
  <ul class="collapse">
  <li><a href="#diabetes-data" id="toc-diabetes-data" class="nav-link" data-scroll-target="#diabetes-data"><span class="header-section-number">14.2.1</span> 12.3.1 Diabetes data</a></li>
  <li><a href="#predicting-embryonic-cell-state-from-gene-expression" id="toc-predicting-embryonic-cell-state-from-gene-expression" class="nav-link" data-scroll-target="#predicting-embryonic-cell-state-from-gene-expression"><span class="header-section-number">14.2.2</span> 12.3.2 Predicting embryonic cell state from gene expression</a></li>
  </ul></li>
  <li><a href="#machine-learning-vs-rote-learning" id="toc-machine-learning-vs-rote-learning" class="nav-link" data-scroll-target="#machine-learning-vs-rote-learning"><span class="header-section-number">14.3</span> 12.4 Machine learning vs rote learning</a>
  <ul class="collapse">
  <li><a href="#cross-validation" id="toc-cross-validation" class="nav-link" data-scroll-target="#cross-validation"><span class="header-section-number">14.3.1</span> 12.4.1 Cross-validation</a></li>
  <li><a href="#the-curse-of-dimensionality" id="toc-the-curse-of-dimensionality" class="nav-link" data-scroll-target="#the-curse-of-dimensionality"><span class="header-section-number">14.3.2</span> 12.4.2 The curse of dimensionality</a></li>
  </ul></li>
  <li><a href="#objective-functions" id="toc-objective-functions" class="nav-link" data-scroll-target="#objective-functions"><span class="header-section-number">14.4</span> 12.5 Objective functions</a></li>
  <li><a href="#variancebias-trade-off" id="toc-variancebias-trade-off" class="nav-link" data-scroll-target="#variancebias-trade-off"><span class="header-section-number">14.5</span> 12.6 Variance–bias trade-off</a>
  <ul class="collapse">
  <li><a href="#penalization" id="toc-penalization" class="nav-link" data-scroll-target="#penalization"><span class="header-section-number">14.5.1</span> 12.6.1 Penalization</a></li>
  <li><a href="#example-predicting-colon-cancer-from-stool-microbiome-composition" id="toc-example-predicting-colon-cancer-from-stool-microbiome-composition" class="nav-link" data-scroll-target="#example-predicting-colon-cancer-from-stool-microbiome-composition"><span class="header-section-number">14.5.2</span> 12.6.2 Example: predicting colon cancer from stool microbiome composition</a></li>
  <li><a href="#example-classifying-mouse-cells-from-their-expression-profiles" id="toc-example-classifying-mouse-cells-from-their-expression-profiles" class="nav-link" data-scroll-target="#example-classifying-mouse-cells-from-their-expression-profiles"><span class="header-section-number">14.5.3</span> 12.6.3 Example: classifying mouse cells from their expression profiles</a></li>
  </ul></li>
  <li><a href="#a-large-choice-of-methods" id="toc-a-large-choice-of-methods" class="nav-link" data-scroll-target="#a-large-choice-of-methods"><span class="header-section-number">14.6</span> 12.7 A large choice of methods</a>
  <ul class="collapse">
  <li><a href="#method-hacking" id="toc-method-hacking" class="nav-link" data-scroll-target="#method-hacking"><span class="header-section-number">14.6.1</span> 12.7.1 Method hacking</a></li>
  </ul></li>
  <li><a href="#summary-of-this-chapter" id="toc-summary-of-this-chapter" class="nav-link" data-scroll-target="#summary-of-this-chapter"><span class="header-section-number">14.7</span> 12.8 Summary of this chapter</a></li>
  <li><a href="#further-reading" id="toc-further-reading" class="nav-link" data-scroll-target="#further-reading"><span class="header-section-number">14.8</span> 12.9 Further reading</a></li>
  <li><a href="#exercises" id="toc-exercises" class="nav-link" data-scroll-target="#exercises"><span class="header-section-number">14.9</span> 12.10 Exercises</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">12.1 Goals for this chapter</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p><a href="imgs/BuildWall.png"><img src="imgs/BuildWall.png" class="img-fluid"></a></p>
<p><a href="imgs/EWall.png"><img src="imgs/EWall.png" class="img-fluid"></a></p>
<p>In a supervised learning setting, we have a yardstick or plumbline to judge how well we are doing: the response itself.</p>
<p>A frequent question in biological and biomedical applications is whether a property of interest (say, disease type, cell type, the prognosis of a patient) can be “predicted”, given one or more other properties, called the <strong>predictors</strong>. Often we are motivated by a situation in which the property to be predicted is unknown (it lies in the future, or is hard to measure), while the predictors are known. The crucial point is that we <em>learn</em> the prediction rule from a set of <em>training data</em> in which the property of interest is also known. Once we have the rule, we can either apply it to new data, and make actual predictions of unknown outcomes; or we can dissect the rule with the aim of better understanding the underlying biology.</p>
<p>Compared to unsupervised learning and what we have seen in Chapters <a href="05-chap.html">5</a>, <a href="07-chap.html">7</a> and <a href="09-chap.html">9</a>, where we do not know what we are looking for or how to decide whether our result is “right”, we are on much more solid ground with supervised learning: the objective is clearly stated, and there are straightforward criteria to measure how well we are doing.</p>
<p>The central issues in <strong>supervised learning</strong> 1 are <strong>overfitting</strong> and <strong>generalizability</strong> : did we just learn the training data “by heart” by constructing a rule that has 100% accuracy on the training data, but would perform poorly on any new data? Or did our rule indeed pick up some of the pertinent patterns in the system being studied, which will also apply to yet unseen new data? (Figure 12.1)</p>
<p>1 Sometimes the term <strong>statistical learning</strong> is used, more or less exchangeably.</p>
<p><a href="12-chap_files/figure- html/fig-overfitting-1-1.png" title="Figure 12.1: An example for overfitting: two regression lines are fit to data in the (x, y)-plane (black points). We can think of such a line as a rule that predicts the y-value, given an x-value. Both lines are smooth, but the fits differ in what is called their bandwidth, which intuitively can be interpreted their stiffness. The blue line seems overly keen to follow minor wiggles in the data, while the orange line captures the general trend but is less detailed. The effective number of parameters needed to describe the blue line is much higher than for the orange line. Also, if we were to obtain additional data, it is likely that the blue line would do a worse job than the orange line in modeling the new data. We’ll formalize these concepts –training error and test set error– later in this chapter. Although exemplified here with line fitting, the concept applies more generally to prediction models."><img src="12-chap_files/figure-html/fig-overfitting-1-1.png" class="img-fluid"></a></p>
<p>Figure 12.1: An example for <strong>overfitting</strong> : two regression lines are fit to data in the \((x, y)\)-plane (black points). We can think of such a line as a rule that predicts the \(y\)-value, given an \(x\)-value. Both lines are smooth, but the fits differ in what is called their <strong>bandwidth</strong> , which intuitively can be interpreted their stiffness. The blue line seems overly keen to follow minor wiggles in the data, while the orange line captures the general trend but is less detailed. The effective number of parameters needed to describe the blue line is much higher than for the orange line. Also, if we were to obtain additional data, it is likely that the blue line would do a <strong>worse</strong> job than the orange line in modeling the new data. We’ll formalize these concepts –training error and test set error– later in this chapter. Although exemplified here with line fitting, the concept applies more generally to prediction models.</p>
<p>In this chapter we will:</p>
<ul>
<li><p>See exemplary applications that motivate the use of supervised learning methods.</p></li>
<li><p>Learn what discriminant analysis does.</p></li>
<li><p>Define measures of performance.</p></li>
<li><p>Encounter the curse of dimensionality and see what overfitting is.</p></li>
<li><p>Find out about regularization – in particular, penalization – and understand the concepts of generalizability and model complexity.</p></li>
<li><p>See how to use cross-validation to tune parameters of algorithms.</p></li>
<li><p>Discuss method hacking.</p></li>
</ul>
<section id="what-are-the-data" class="level2" data-number="14.1">
<h2 data-number="14.1" class="anchored" data-anchor-id="what-are-the-data"><span class="header-section-number">14.1</span> 12.2 What are the data?</h2>
<p>The basic data structure for both supervised and unsupervised learning is (at least conceptually) a dataframe, where each row corresponds to an object and the columns are different features (usually numerical values) of the objects2. While in unsupervised learning we aim to find (dis)similarity relationships between the objects based on their feature values (e.g., by clustering or ordination), in supervised learning we aim to find a mathematical function (or a computational algorithm) that predicts the value of one of the features from the other features. Many implementations require that there are no missing values, whereas other methods can be made to work with some amount of missing data.</p>
<p>2 This is a simplified description. Machine learning is a huge field, and lots of generalizations of this simple conceptual picture have been made. Already the construction of relevant features is an art by itself — we have seen examples with images of cells in <a href="11-chap.html">Chapter 11</a>, and more generally there are lots of possibilities to extract features from images, sounds, movies, free text, \(…\) Moreover, there is a variant of machine learning methods called <strong>kernel methods</strong> that do not need features at all; instead, kernel methods use distances or measures of similarity between objects. It may be easier, for instance, to define a measure of similarity between two natural language text objects than to find relevant numerical features to represent them. Kernel methods are beyond the scope of this book.</p>
<p>The feature that we select over all the others with the aim of predicting is called the <strong>objective</strong> or the <strong>response</strong>. Sometimes the choice is natural, but sometimes it is also instructive to reverse the roles, especially if we are interested in dissecting the prediction function for the purpose of biological understanding, or in disentangling correlations from causation.</p>
<p>The framework for supervised learning covers both continuous and categorical response variables. In the continuous case we also call it <strong>regression</strong> , in the categorical case, <strong>classification</strong>. It turns out that this distinction is not a detail, as it has quite far-reaching consequences for the choice of loss function (Section 12.5) and thus the choice of algorithm (<a href="16-chap.html#ref-friedmanbiasvariance01">Friedman 1997</a>).</p>
<p>The first question to consider in any supervised learning task is how the number of objects compares to the number of predictors. The more objects, the better, and much of the hard work in supervised learning has to do with overcoming the limitations of having a finite (and typically, too small) training set.</p>
<p><a href="imgs/fourquad.png" title="Figure 12.2: In supervised learning, we assign two different roles to our variables. We have labeled the explanatory variables X and the response variable(s) Y. There are also two different sets of observations: the training set X_\ell and Y_\ell and the test set X_v and Y_v. (The subscripts refer to alternative names for the two sets: “learning” and “validation”.)"><img src="imgs/fourquad.png" class="img-fluid"></a></p>
<p>Figure 12.2: In supervised learning, we assign two different roles to our variables. We have labeled the explanatory variables \(X\) and the response variable(s) \(Y\). There are also two different sets of observations: the training set \(X_\) and \(Y_\) and the test set \(X_v\) and \(Y_v\). (The subscripts refer to alternative names for the two sets: “learning” and “validation”.)</p>
<p>__</p>
<p>Task</p>
<p>Give examples where we have encountered instances of supervised learning with a categorical response in this book.</p>
<section id="motivating-examples" class="level3" data-number="14.1.1">
<h3 data-number="14.1.1" class="anchored" data-anchor-id="motivating-examples"><span class="header-section-number">14.1.1</span> 12.2.1 Motivating examples</h3>
<section id="predicting-diabetes-type" class="level4" data-number="14.1.1.1">
<h4 data-number="14.1.1.1" class="anchored" data-anchor-id="predicting-diabetes-type"><span class="header-section-number">14.1.1.1</span> Predicting diabetes type</h4>
<p>The <code>diabetes</code> dataset (<a href="16-chap.html#ref-diabetes">Reaven and Miller 1979</a>) presents three different groups of diabetes patients and five clinical variables measured on them.</p>
<pre><code>data("diabetes", package = "rrcov")
head(diabetes)__


    rw fpg glucose insulin sspg  group
1 0.81  80     356     124   55 normal
2 0.95  97     289     117   76 normal
3 0.94 105     319     143  105 normal
4 1.04  90     356     199  108 normal
5 1.00  90     323     240  143 normal
6 0.76  86     381     157  165 normal</code></pre>
<p>The univariate distributions (more precisely, some density estimates of them) are shown in Figure 12.3.</p>
<pre><code>library("reshape2")
ggplot(melt(diabetes, id.vars = "group"), aes(x = value, col = group)) +
 geom_density() + facet_wrap( ~variable, ncol = 1, scales = "free") +
 theme(legend.position = "bottom")__</code></pre>
<p><a href="12-chap_files/figure- html/fig-ldagroups-1-1.png" title="Figure 12.3: We see already from the one- dimensional distributions that some of the individual variables could potentially predict which group a patient is more likely to belong to. Our goal is to combine variables to improve over such one-dimensional prediction models."><img src="12-chap_files/figure-html/fig-ldagroups-1-1.png" class="img-fluid"></a></p>
<p>Figure 12.3: We see already from the one-dimensional distributions that some of the individual variables could potentially predict which group a patient is more likely to belong to. Our goal is to combine variables to improve over such one-dimensional prediction models.</p>
<p>The variables are explained in the manual page of the dataset, and in the paper (<a href="16-chap.html#ref-diabetes">Reaven and Miller 1979</a>):</p>
<ul>
<li><p>rw: relative weight</p></li>
<li><p>fpg: fasting plasma glucose</p></li>
<li><p>glucose: area under the plasma glucose curve for the three hour oral glucose tolerance test (OGTT)</p></li>
<li><p>insulin: area under the plasma insulin curve for the OGTT</p></li>
<li><p>sspg: steady state plasma glucose response</p></li>
<li><p>group: normal, chemical diabetes and overt diabetes</p></li>
</ul>
</section>
<section id="predicting-cellular-phenotypes" class="level4" data-number="14.1.1.2">
<h4 data-number="14.1.1.2" class="anchored" data-anchor-id="predicting-cellular-phenotypes"><span class="header-section-number">14.1.1.2</span> Predicting cellular phenotypes</h4>
<p>Neumann et al.&nbsp;(<a href="16-chap.html#ref-Neumann:2010">2010</a>) observed human cancer cells using live-cell imaging. The cells were genetically engineered so that their histones were tagged with a green fluorescent protein (GFP). A genome- wide RNAi library was applied to the cells, and for each siRNA perturbation, movies of a few hundred cells were recorded for about two days, to see what effect the depletion of each gene had on cell cycle, nuclear morphology and cell proliferation. Their paper reports the use of an automated image classification algorithm that quantified the visual appearance of each cell’s nucleus and enabled the prediction of normal mitosis states or aberrant nuclei. The algorithm was trained on the data from around 3000 cells that were annotated by a human expert. It was then applied to almost 2 billions images of nuclei (Figure 12.4). Using automated image classification provided scalability (annotating 2 billion images manually would take a long time) and objectivity.</p>
<p><a href="imgs/Neumann2010Fig1b_web.jpg &quot;Figure 12.4: The data were images of 2\times10^9 nuclei from movies. The images were segmented to identify the nuclei, and numeric features were computed for each nucleus, corresponding to size, shape, brightness and lots of other more or less abstract quantitative summaries of the joint distribution of pixel intensities. From the features, the cells were classified into 16 different nuclei morphology classes, represented by the rows of the barplot. Representative images for each class are shown in black and white in the center column. The class frequencies, which are very unbalanced, are shown by the lengths of the bars.&quot;"><img src="imgs/Neumann2010Fig1b_web.jpg" class="img-fluid"></a></p>
<p>Figure 12.4: The data were images of \(2^9\) nuclei from movies. The images were segmented to identify the nuclei, and numeric features were computed for each nucleus, corresponding to size, shape, brightness and lots of other more or less abstract quantitative summaries of the joint distribution of pixel intensities. From the features, the cells were classified into 16 different nuclei morphology classes, represented by the rows of the barplot. Representative images for each class are shown in black and white in the center column. The class frequencies, which are very unbalanced, are shown by the lengths of the bars.</p>
</section>
<section id="predicting-embryonic-cell-states" class="level4" data-number="14.1.1.3">
<h4 data-number="14.1.1.3" class="anchored" data-anchor-id="predicting-embryonic-cell-states"><span class="header-section-number">14.1.1.3</span> Predicting embryonic cell states</h4>
<p>We will revisit the mouse embryo data (<a href="16-chap.html#ref- Ohnishi2014">Ohnishi et al.&nbsp;2014</a>), which we have already seen in Chapters <a href="03-chap.html">3</a>, <a href="05-chap.html">5</a> and <a href="07-chap.html">7</a>. We’ll try to predict cell state and genotype from the gene expression measurements in Sections 12.3.2 and 12.6.3.</p>
</section>
</section>
</section>
<section id="linear-discrimination" class="level2" data-number="14.2">
<h2 data-number="14.2" class="anchored" data-anchor-id="linear-discrimination"><span class="header-section-number">14.2</span> 12.3 Linear discrimination</h2>
<p>We start with one of the simplest possible discrimination problems3: we have objects described by two continuous features (so the objects can be thought of as points in the 2D plane) and falling into three groups. Our aim is to define class boundaries, which are lines in the 2D space.</p>
<p>3 Arguably the simplest possible problem is a single continuous feature, two classes, and the task of finding a single threshold to discriminate between the two groups – as in <a href="06-chap.html#fig-testing-FDRvspstatic1">Figure 6.2</a>.</p>
<section id="diabetes-data" class="level3" data-number="14.2.1">
<h3 data-number="14.2.1" class="anchored" data-anchor-id="diabetes-data"><span class="header-section-number">14.2.1</span> 12.3.1 Diabetes data</h3>
<p>Let’s see whether we can predict the <code>group</code> from the <code>sspg</code> and <code>glucose</code> variables in the <code>diabetes</code> data. It’s always a good idea to first visualise the data (Figure 12.5).</p>
<pre><code>ggdb = ggplot(mapping = aes(x = sspg, y = glucose)) +
  geom_point(aes(colour = group), data = diabetes)
ggdb __</code></pre>
<p><a href="12-chap_files/figure-html/fig- scatterdiabetes-1-1.png" title="Figure 12.5: Scatterplot of two of the variables in the diabetes data. Each point is a sample, and the color indicates the diabetes type as encoded in the group variable."><img src="12-chap_files/figure-html/fig- scatterdiabetes-1-1.png" class="img-fluid"></a></p>
<p>Figure 12.5: Scatterplot of two of the variables in the <code>diabetes</code> data. Each point is a sample, and the color indicates the diabetes type as encoded in the <code>group</code> variable.</p>
<p>We’ll start with a method called <strong>linear discriminant analysis</strong> (<strong>LDA</strong>). This method is a foundation stone of classification, many of the more complicated (and sometimes more powerful) algorithms are really just generalizations of LDA.</p>
<pre><code>library("MASS")
diabetes_lda = lda(group ~ sspg + glucose, data = diabetes)
diabetes_lda __


Call:
lda(group ~ sspg + glucose, data = diabetes)

Prior probabilities of groups:
   normal  chemical     overt 
0.5241379 0.2482759 0.2275862 

Group means:
             sspg   glucose
normal   114.0000  349.9737
chemical 208.9722  493.9444
overt    318.8788 1043.7576

Coefficients of linear discriminants:
                LD1         LD2
sspg    0.005036943 -0.01539281
glucose 0.005461400  0.00449050

Proportion of trace:
   LD1    LD2 
0.9683 0.0317 


ghat = predict(diabetes_lda)$class
table(ghat, diabetes$group)__


          
ghat       normal chemical overt
  normal       69       12     1
  chemical      7       24     6
  overt         0        0    26


mean(ghat != diabetes$group)__


[1] 0.1793103</code></pre>
<p>__</p>
<p>Question 12.1</p>
<p>What do the different parts of the above output mean?</p>
<p>Now, let’s visualise the LDA result. We are going to plot the prediction regions for each of the three groups. We do this by creating a grid of points and using our prediction rule on each of them. We’ll then also dig a bit deeper into the mechanics of LDA and plot the class centers (<code>diabetes_lda$means</code>) and ellipses that correspond to the fitted covariance matrix (<code>diabetes_lda$scaling</code>). Assembling this visualization requires us to write a bit of code.</p>
<pre><code>make1Dgrid = function(x) {
  rg = grDevices::extendrange(x)
  seq(from = rg[1], to = rg[2], length.out = 100)
}__</code></pre>
<p>Set up the points for prediction, a \(100 \) grid that covers the data range.</p>
<pre><code>diabetes_grid = with(diabetes,
  expand.grid(sspg = make1Dgrid(sspg),
              glucose = make1Dgrid(glucose)))__</code></pre>
<p>Do the predictions.</p>
<pre><code>diabetes_grid$ghat =
  predict(diabetes_lda, newdata = diabetes_grid)$class __</code></pre>
<p>The group centers.</p>
<pre><code>centers = diabetes_lda$means __</code></pre>
<p>Compute the ellipse. We start from a unit circle (approximated by a polygon with 360 sides) and apply the corresponding affine transformation from the LDA output.</p>
<pre><code>unitcircle = exp(1i * seq(0, 2*pi, length.out = 360)) |&gt;
          (\(z) cbind(Re(z), Im(z)))() 
ellipse = unitcircle %*% solve(diabetes_lda$scaling) |&gt; as_tibble()__</code></pre>
<p>All three ellipses, one for each group center.</p>
<pre><code>library("dplyr")
ellipses = lapply(rownames(centers), function(gr) {
  mutate(ellipse,
     sspg    = sspg    + centers[gr, "sspg"],
     glucose = glucose + centers[gr, "glucose"],
     group   = gr)
}) |&gt; bind_rows()__</code></pre>
<p>Now we are ready to plot (Figure 12.6).</p>
<pre><code>ggdb + geom_raster(aes(fill = ghat),
            data = diabetes_grid, alpha = 0.25, interpolate = TRUE) +
    geom_point(data = as_tibble(centers), pch = "+", size = 8) +
    geom_path(aes(colour = group), data = ellipses) +
    scale_x_continuous(expand = c(0, 0)) +
    scale_y_continuous(expand = c(0, 0))__</code></pre>
<p><a href="12-chap_files/figure-html/fig-modeldiabetes-1-1.png &quot;Figure 12.6: As Figure fig-scatterdiabetes-1, with the classification regions from the LDA model shown. The three ellipses represent the class centers and the covariance matrix of the LDA model; note that there is only one covariance matrix, which is the same for all three classes. Therefore also the sizes and orientations of the ellipses are the same for the three classes, only their centers differ. They represent contours of equal class membership probability.&quot;"><img src="12-chap_files/figure-html/fig- modeldiabetes-1-1.png" class="img-fluid"></a></p>
<p>Figure 12.6: As Figure 12.5, with the classification regions from the LDA model shown. The three ellipses represent the class centers and the covariance matrix of the LDA model; note that there is only one covariance matrix, which is the same for all three classes. Therefore also the sizes and orientations of the ellipses are the same for the three classes, only their centers differ. They represent contours of equal class membership probability.</p>
<p>__</p>
<p>Question 12.2</p>
<p>Why is the boundary between the prediction regions for <em>chemical</em> and <em>overt</em> not perpendicular to the line between the group centers?</p>
<p>__</p>
<p>Solution</p>
<p>__</p>
<p>The boundaries would be perpendicular if the ellipses were circles. In general, a boundary is tangential to the contours of equal class probabilities, and due the elliptic shape of the contours, a boundary is in general not perpendicular to the line between centers.</p>
<p>__</p>
<p>Question 12.3</p>
<p>How confident would you be about the predictions in those areas of the 2D plane that are far from all of the cluster centers?</p>
<p>__</p>
<p>Solution</p>
<p>__</p>
<p>Predictions that are far from any cluster center should be assessed critically, as this amounts to an extrapolation into regions where the LDA model may not be very good and/or there may be no training data nearby to support the prediction. We could use the distance to the nearest center as a measure of confidence in the prediction for any particular point; although we will see that resampling and cross-validation based methods offer more generic and usually more reliable measures.</p>
<p>__</p>
<p>Question 12.4</p>
<p>Why is the boundary between the prediction regions for <em>normal</em> and <em>chemical</em> not half-way between the centers, but shifted in favor of <em>normal</em>? Hint: have a look at the <code>prior</code> argument of <code>lda</code>. Try again with uniform prior.</p>
<p>__</p>
<p>Solution</p>
<p>__</p>
<p>The result of the following code chunk is shown in Figure 12.7. The suffix <code>_up</code> is short for “uniform prior”.</p>
<pre><code>diabetes_up = lda(group ~ sspg + glucose, data = diabetes,
  prior = (\(n) rep(1/n, n)) (nlevels(diabetes$group)))

diabetes_grid$ghat_up =
  predict(diabetes_up, newdata = diabetes_grid)$class

stopifnot(all.equal(diabetes_up$means, diabetes_lda$means))

ellipse_up  = unitcircle %*% solve(diabetes_up$scaling) |&gt; as_tibble()
ellipses_up = lapply(rownames(centers), function(gr) {
  mutate(ellipse_up,
     sspg    = sspg    + centers[gr, "sspg"],
     glucose = glucose + centers[gr, "glucose"],
     group   = gr)
}) |&gt; bind_rows()

ggdb + geom_raster(aes(fill = ghat_up),
            data = diabetes_grid, alpha = 0.4, interpolate = TRUE) +
    geom_point(data = data.frame(centers), pch = "+", size = 8) +
    geom_path(aes(colour = group), data = ellipses_up) +
    scale_x_continuous(expand = c(0, 0)) +
    scale_y_continuous(expand = c(0, 0))__</code></pre>
<p><a href="12-chap_files/figure-html/fig-diabetes-lda-uniform- prior-1-1.png" title="Figure 12.7: As Figure fig-modeldiabetes-1, but with uniform class priors."><img src="12-chap_files/figure-html/fig-diabetes-lda-uniform- prior-1-1.png" class="img-fluid"></a></p>
<p>Figure 12.7: As Figure 12.6, but with uniform class priors.</p>
<p>The <code>stopifnot</code> line confirms that the class centers are the same, as they are independent of the prior. The joint covariance is not.</p>
<p>__</p>
<p>Question 12.5</p>
<p>Figures 12.6 and 12.7 show both the fitted LDA model, through the ellipses, and the prediction regions, through the area coloring. What part of this visualization is generic for all sorts of classification methods, what part is method-specific?</p>
<p>__</p>
<p>Solution</p>
<p>__</p>
<p>The prediction regions can be shown for any classification method, including a “black box” method. The cluster centers and ellipses in Figures 12.6 and 12.7 are method-specific.</p>
<p>__</p>
<p>Question 12.6</p>
<p>What is the difference in the prediction accuracy if we use all 5 variables instead of just <code>glucose</code> and <code>sspg</code>?</p>
<p>__</p>
<p>Solution</p>
<p>__</p>
<pre><code>diabetes_lda5 = lda(group ~ rw + fpg + glucose + sspg + insulin, data = diabetes)
diabetes_lda5 __


Call:
lda(group ~ rw + fpg + glucose + sspg + insulin, data = diabetes)

Prior probabilities of groups:
   normal  chemical     overt 
0.5241379 0.2482759 0.2275862 

Group means:
                rw       fpg   glucose     sspg  insulin
normal   0.9372368  91.18421  349.9737 114.0000 172.6447
chemical 1.0558333  99.30556  493.9444 208.9722 288.0000
overt    0.9839394 217.66667 1043.7576 318.8788 106.0000

Coefficients of linear discriminants:
                  LD1          LD2
rw       1.3624356881 -3.784142444
fpg     -0.0336487883  0.036633317
glucose  0.0125763942 -0.007092017
sspg     0.0042431866  0.001134070
insulin -0.0001022245 -0.006173424

Proportion of trace:
   LD1    LD2 
0.8812 0.1188 


ghat5 = predict(diabetes_lda5)$class
table(ghat5, diabetes$group)__


          
ghat5      normal chemical overt
  normal       73        5     1
  chemical      3       31     5
  overt         0        0    27


mean(ghat5 != diabetes$group)__


[1] 0.09655172</code></pre>
<p>__</p>
<p>Question 12.7</p>
<p>Instead of approximating the prediction regions by classification from a grid of points, compute the separating lines explicitly from the linear determinant coefficients.</p>
<p>__</p>
<p>Solution</p>
<p>__</p>
<p>See Section 4.3, Equation (4.10) in (<a href="16-chap.html#ref-HastieTibshiraniFriedman">Hastie, Tibshirani, and Friedman 2008</a>).</p>
</section>
<section id="predicting-embryonic-cell-state-from-gene-expression" class="level3" data-number="14.2.2">
<h3 data-number="14.2.2" class="anchored" data-anchor-id="predicting-embryonic-cell-state-from-gene-expression"><span class="header-section-number">14.2.2</span> 12.3.2 Predicting embryonic cell state from gene expression</h3>
<p>Assume that we already know that the four genes <em>FN1</em> , <em>TIMD2</em> , <em>GATA4</em> and <em>SOX7</em> are relevant to the classification task4. We want to build a classifier that predicts the developmental time (embryonic days: E3.25, E3.5, E4.5). We load the data and select four corresponding probes.</p>
<p>4 Later in this chapter we will see methods that can drop this assumption and screen all available features.</p>
<pre><code>library("Hiiragi2013")__


In chunk 'loadHiiragi2': Warning: replacing previous import 'boot::logit' by 'gtools::logit' whenloading 'Hiiragi2013'


In chunk 'loadHiiragi2': Warning: replacing previous import 'boot::inv.logit' by 'gtools::inv.logit'when loading 'Hiiragi2013'


data("x")
probes = c("1426642_at", "1418765_at", "1418864_at", "1416564_at")
embryoCells = t(Biobase::exprs(x)[probes, ]) |&gt; as_tibble() |&gt;
  mutate(Embryonic.day = x$Embryonic.day) |&gt;
  dplyr::filter(x$genotype == "WT")__</code></pre>
<p>We can use the Bioconductor annotation package associated with the microarray to verify that the probes correspond to the intended genes.</p>
<pre><code>annotation(x)__


[1] "mouse4302"


library("mouse4302.db")
anno = AnnotationDbi::select(mouse4302.db, keys = probes,
                             columns = c("SYMBOL", "GENENAME"))
anno __


     PROBEID SYMBOL                                            GENENAME
1 1426642_at    Fn1                                       fibronectin 1
2 1418765_at  Timd2 T cell immunoglobulin and mucin domain containing 2
3 1418864_at  Gata4                              GATA binding protein 4
4 1416564_at   Sox7                SRY (sex determining region Y)-box 7


mt = match(anno$PROBEID, colnames(embryoCells))
colnames(embryoCells)[mt] = anno$SYMBOL __</code></pre>
<p>Now we are ready to visualize the data in a pairs plot (Figure 12.8).</p>
<pre><code>library("GGally")
ggpairs(embryoCells, mapping = aes(col = Embryonic.day),
  columns = anno$SYMBOL, upper = list(continuous = "points"))__</code></pre>
<p><a href="12-chap_files/figure-html/fig- HiiragiFourGenesPairs-1-1.png" title="Figure 12.8: Expression values of the discriminating genes, with the prediction target Embryonic.day shown by color."><img src="12-chap_files/figure-html/fig- HiiragiFourGenesPairs-1-1.png" class="img-fluid"></a></p>
<p>Figure 12.8: Expression values of the discriminating genes, with the prediction target Embryonic.day shown by color.</p>
<p>We can now call <code>lda</code> on these data. The linear combinations <code>LD1</code> and <code>LD2</code> that serve as discriminating variables are given in the slot <code>ed_lda$scaling</code> of the output from <code>lda</code>.</p>
<pre><code>ec_lda = lda(Embryonic.day ~ Fn1 + Timd2 + Gata4 + Sox7,
             data = embryoCells)
round(ec_lda$scaling, 1)__


       LD1  LD2
Fn1   -0.2  0.4
Timd2  0.5  0.0
Gata4 -0.1  0.6
Sox7  -0.7 -0.5</code></pre>
<p>For the visualization of the learned model in Figure 12.9, we need to build the prediction regions and their boundaries by expanding the grid in the space of the two new coordinates LD1 and LD2.</p>
<pre><code>ec_rot = predict(ec_lda)$x |&gt; as_tibble() |&gt;
           mutate(ed = embryoCells$Embryonic.day)
ec_lda2 = lda(ec_rot[, 1:2], predict(ec_lda)$class)
ec_grid = with(ec_rot, expand.grid(
  LD1 = make1Dgrid(LD1),
  LD2 = make1Dgrid(LD2)))
ec_grid$edhat = predict(ec_lda2, newdata = ec_grid)$class
ggplot() +
  geom_point(aes(x = LD1, y = LD2, colour = ed), data = ec_rot) +
  geom_raster(aes(x = LD1, y = LD2, fill = edhat),
            data = ec_grid, alpha = 0.4, interpolate = TRUE) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  coord_fixed()__</code></pre>
<p><a href="12-chap_files/figure- html/fig-edcontour-1-1.png" title="Figure 12.9: LDA classification regions for Embryonic.day."><img src="12-chap_files/figure-html/fig-edcontour-1-1.png" class="img-fluid"></a></p>
<p>Figure 12.9: LDA classification regions for Embryonic.day.</p>
<p>__</p>
<p>Question 12.8</p>
<p>Repeat these analyses using quadratic discriminant analysis (<code>qda</code>). What difference do you see in the shape of the boundaries?</p>
<p>__</p>
<p>Solution</p>
<p>__</p>
<p>See code below and Figure 12.10.</p>
<pre><code>library("gridExtra")

ec_qda = qda(Embryonic.day ~ Fn1 + Timd2 + Gata4 + Sox7,
             data = embryoCells)

variables = colnames(ec_qda$means)
pairs = combn(variables, 2)
lapply(seq_len(ncol(pairs)), function(i) {
  grid = with(embryoCells,
    expand.grid(x = make1Dgrid(get(pairs[1, i])),
                y = make1Dgrid(get(pairs[2, i])))) |&gt;
    `colnames&lt;-`(pairs[, i])

  for (v in setdiff(variables, pairs[, i]))
    grid[[v]] = median(embryoCells[[v]])

  grid$edhat = predict(ec_qda, newdata = grid)$class

  x &lt;- pairs[1,i]
  y &lt;- pairs[2,i]
  ggplot() + 
    geom_point(
      data = embryoCells,
      aes(x = .data[[x]], y = .data[[y]], colour = Embryonic.day)
    ) +
    geom_raster(
      aes(x = .data[[x]], y = .data[[y]], fill = edhat),
      data = grid, alpha = 0.4, interpolate = TRUE
    ) +
    scale_x_continuous(expand = c(0, 0)) +
    scale_y_continuous(expand = c(0, 0)) +
    coord_fixed() +
    if (i != ncol(pairs)) theme(legend.position = "none")
}) |&gt; (\(g) grid.arrange(grobs = g, ncol = 2))()__</code></pre>
<p><a href="12-chap_files/figure- html/fig-qdamouse-1-1.png" title="Figure 12.10: QDA for the mouse cell data. Shown are all pairwise plots of the four features. In each plot, the other two features are set to the median."><img src="12-chap_files/figure-html/fig-qdamouse-1-1.png" class="img-fluid"></a></p>
<p>Figure 12.10: QDA for the mouse cell data. Shown are all pairwise plots of the four features. In each plot, the other two features are set to the median.</p>
<p>__</p>
<p>Question 12.9</p>
<p>What happens if you call <code>lda</code> or <code>qda</code> with a lot more genes, say the first 1000, in the Hiiragi dataset?</p>
<p>__</p>
<p>Solution</p>
<p>__</p>
<pre><code>lda(t(Biobase::exprs(x))[, 1:1000], x$Embryonic.day)__


 warnings()
qda(t(Biobase::exprs(x))[, 1:1000], x$Embryonic.day)__


Error in qda.default(x, grouping, ...): some group is too small for 'qda'</code></pre>
<p>The <code>lda</code> function manages to fit a model, but complains (with the warning) about the fact that there are more variables than replicates, which means that the variables are not linearly independent, and thus are redundant of each other. The <code>qda</code> function aborts with an error, since the QDA model with so many parameters cannot be fitted from the available data (at least, without making further assumptions, such as some sort of regularization, which it is not equipped for).</p>
</section>
</section>
<section id="machine-learning-vs-rote-learning" class="level2" data-number="14.3">
<h2 data-number="14.3" class="anchored" data-anchor-id="machine-learning-vs-rote-learning"><span class="header-section-number">14.3</span> 12.4 Machine learning vs rote learning</h2>
<p>Computers are really good at memorizing facts. In the worst case, a machine learning algorithm is a roundabout way of doing this5. The central goal in statistical learning, however, is <em>generalizability</em>. We want an algorithm that is able to generalize, i.e., interpolate and extrapolate from given data to make good predictions about future data.</p>
<p>5 The not-so roundabout way is database technologies.</p>
<p>Let’s look at the following example. We generate random data (<code>rnorm</code>) for <code>n</code> objects, with different numbers of features (given by <code>p</code>). We train a LDA on these data and compute the <strong>misclassification rate</strong> , i.e., the fraction of times the prediction is wrong (<code>pred != resp</code>).</p>
<pre><code>p = 2:21
n = 20

mcl = lapply(p, function(pp) {
  replicate(100, {
    xmat = matrix(rnorm(n * pp), nrow = n)
    resp = sample(c("apple", "orange"), n, replace = TRUE)
    fit  = lda(xmat, resp)
    pred = predict(fit)$class
    mean(pred != resp)
  }) |&gt; mean() |&gt; (\(x) tibble(mcl = x, p = pp))()
}) |&gt; bind_rows()__


 ggplot(mcl, aes(x = p, y = mcl)) + 
  geom_line() + geom_point() +
  ylab("Misclassification rate")__</code></pre>
<p><a href="12-chap_files/figure-html/fig-learnbyheart-1-1.png &quot;Figure 12.11: Misclassification rate of LDA applied to random data. While the number of observations n is held constant (at 20), we are increasing the number of features p starting from 2 up to 21. The misclassification rate becomes almost zero as p approaches 20. The LDA model becomes so elaborate and over-parameterized that it manages to learn the random labels “by heart”. (As p becomes even larger, the “performance” degrades again somewhat, apparently due to numerical properties of the lda implementation used here.)&quot;"><img src="12-chap_files/figure-html/fig- learnbyheart-1-1.png" class="img-fluid"></a></p>
<p>Figure 12.11: Misclassification rate of LDA applied to random data. While the number of observations <code>n</code> is held constant (at 20), we are increasing the number of features <code>p</code> starting from 2 up to 21. The misclassification rate becomes almost zero as <code>p</code> approaches 20. The LDA model becomes so elaborate and over-parameterized that it manages to learn the random labels “by heart”. (As <code>p</code> becomes even larger, the “performance” degrades again somewhat, apparently due to numerical properties of the <code>lda</code> implementation used here.)</p>
<p>__</p>
<p>Question 12.10</p>
<p>What is the purpose of the <code>replicate</code> loop in the above code? What happens if you omit it (or replace the 100 by 1)?</p>
<p>__</p>
<p>Solution</p>
<p>__</p>
<p>For each single replicate, the curve is a noisier version of Figure 12.11. Averaging the measured misclassifications rate over 100 replicates makes the estimate more stable. We can do this since we are working with simulated data.</p>
<p>Figure 12.11 seems to imply that we can perfectly predict random labels from random data, if we only fit a complex enough model, i.e., one with many parameters. How can we overcome such an absurd conclusion? The problem with the above code is that the model performance is evaluated on the same data on which it was trained. This generally leads to positive bias, as you see in this crass example. How can we overcome this problem? The key idea is to assess model performance on different data than those on which the model was trained.</p>
<section id="cross-validation" class="level3" data-number="14.3.1">
<h3 data-number="14.3.1" class="anchored" data-anchor-id="cross-validation"><span class="header-section-number">14.3.1</span> 12.4.1 Cross-validation</h3>
<p>A naive approach might be to split the data in two halves, and use the first half for learning (“training”) and the second half for assessment (“testing”). It turns out that this is needlessly variable and needlessly inefficient. It is needlessly variable, since by splitting the data only once, our results can be quite affected by how the split happens to fall. It seems better to do the splitting many times, and average. This will give us more stable results. It is needlessly inefficient, since the performance of machine learning algorithms depends on the number of observations, and the performance measured on half the data is likely6 to be worse than what it is with all the data. For this reason, it is better to use unequal sizes of training and test data. In the extreme case, we’ll use as much as \(n-1\) observations for training, and the remaining one for testing. After we’ve done this likewise for all observations, we can average our performance metric. This is called <strong>leave- one-out cross-validation</strong>.</p>
<p>6 Unless we have such an excess of data that it doesn’t matter.</p>
<p><a href="imgs/book_icon.png"><img src="imgs/book_icon.png" class="img-fluid"></a></p>
<p>See Chapter <em>Model Assessment and Selection</em> in the book by Hastie, Tibshirani, and Friedman (<a href="16-chap.html#ref-HastieTibshiraniFriedman">2008</a>) for further discussion on these trade-offs.</p>
<p>An alternative is <strong>\(k\) -fold cross-validation</strong>, where the observations are repeatedly split into a training set of size of around \(n(k-1)/k\) and a test set of size of around \(n/k\). Both alternatives have pros and contras, and there is not a universally best choice. An advantage of leave- one-out is that the amount of data used for training is close to the maximally available data; this is especially important if the sample size is limiting and “every little matters” for the algorithm. A drawback of leave-one-out is that the training sets are all very similar, so they may not model sufficiently well the kind of sampling changes to be expected if a new dataset came along. For large \(n\), leave-one-out cross-validation can be needlessly time-consuming.</p>
<pre><code>estimate_mcl_loocv = function(x, resp) {
  vapply(seq_len(nrow(x)), function(i) {
    fit  = lda(x[-i, ], resp[-i])
    ptrn = predict(fit, newdata = x[-i,, drop = FALSE])$class
    ptst = predict(fit, newdata = x[ i,, drop = FALSE])$class
    c(train = mean(ptrn != resp[-i]), test = (ptst != resp[i]))
  }, FUN.VALUE = numeric(2)) |&gt; rowMeans() |&gt; t() |&gt; as_tibble()
}

xmat = matrix(rnorm(n * last(p)), nrow = n)
resp = sample(c("apple", "orange"), n, replace = TRUE)

mcl = lapply(p, function(k) {
  estimate_mcl_loocv(xmat[, 1:k], resp)
}) |&gt; bind_rows() |&gt; data.frame(p) |&gt; melt(id.var = "p")__


 ggplot(mcl, aes(x = p, y = value, col = variable)) + geom_line() +
  geom_point() + ylab("Misclassification rate")__</code></pre>
<p><a href="12-chap_files/figure- html/fig-mclcv-1-1.png" title="Figure 12.12: Cross-validation: the misclassification rate of LDA applied to random data, when evaluated on test data that were not used for learning, hovers around 0.5 independent of p. The misclassification rate on the training data is also shown. It behaves similar to what we already saw in Figure fig-learnbyheart-1."><img src="12-chap_files/figure-html/fig-mclcv-1-1.png" class="img-fluid"></a></p>
<p>Figure 12.12: Cross-validation: the misclassification rate of LDA applied to random data, when evaluated on test data that were not used for learning, hovers around 0.5 independent of <code>p</code>. The misclassification rate on the training data is also shown. It behaves similar to what we already saw in Figure 12.11.</p>
<p>The result is show in Figure 12.12.</p>
<p>__</p>
<p>Question 12.11</p>
<p>Why are the curves in Figure 12.12 more variable (“wiggly”) than in Figure 12.11? How can you overcome this?</p>
<p>__</p>
<p>Solution</p>
<p>__</p>
<p>Only one dataset (<code>xmat</code>, <code>resp</code>) was used to calculate Figure 12.12, whereas for Figure 12.11, we had the data generated within a <code>replicate</code> loop. You could similarly extend the above code to average the misclassification rate curves over many replicate simulated datasets.</p>
</section>
<section id="the-curse-of-dimensionality" class="level3" data-number="14.3.2">
<h3 data-number="14.3.2" class="anchored" data-anchor-id="the-curse-of-dimensionality"><span class="header-section-number">14.3.2</span> 12.4.2 The curse of dimensionality</h3>
<p>In Section 12.4.1 we have seen overfitting and cross-validation on random data, but how does it look if there is in fact a relevant class separation?</p>
<pre><code>p   = 2:20
mcl = replicate(100, {
  xmat = matrix(rnorm(n * last(p)), nrow = n)
  resp = sample(c("apple", "orange"), n, replace = TRUE)
  xmat[, 1:6] = xmat[, 1:6] + as.integer(factor(resp))

  lapply(p, function(k) {
    estimate_mcl_loocv(xmat[, 1:k], resp)
  }) |&gt; bind_rows() |&gt; cbind(p = p) |&gt; melt(id.var = "p")
}, simplify = FALSE) |&gt; bind_rows()__


mcl = group_by(mcl, p, variable) |&gt; summarise(value = mean(value))

ggplot(mcl, aes(x = p, y = value, col = variable)) + geom_line() +
   geom_point() + ylab("Misclassification rate")__</code></pre>
<p><a href="12-chap_files/figure- html/fig-curseofdim-1.png" title="Figure 12.13: As we increase the number of features included in the model, the misclassification rate initially improves; as we start including more and more irrelevant features, it increases again, as we are fitting noise."><img src="12-chap_files/figure-html/fig-curseofdim-1.png" class="img-fluid"></a></p>
<p>Figure 12.13: As we increase the number of features included in the model, the misclassification rate initially improves; as we start including more and more irrelevant features, it increases again, as we are fitting noise.</p>
<p><a href="imgs/BiasVarianceTradeoff.png &quot;Figure 12.14: Idealized version of Figure fig-curseofdim, from @HastieTibshiraniFriedman. A recurrent goal in machine learning is finding the sweet spot in the variance <- bias trade-off.&quot;"><img src="imgs/BiasVarianceTradeoff.png" class="img-fluid"></a></p>
<p>Figure 12.14: Idealized version of Figure 12.13, from Hastie, Tibshirani, and Friedman (<a href="16-chap.html#ref-HastieTibshiraniFriedman">2008</a>). A recurrent goal in machine learning is finding the sweet spot in the variance &lt;- bias trade- off.</p>
<p>The result is shown in Figure 12.13. The group centers are the vectors (in \(^{20}\)) given by the coordinates \((1, 1, 1, 1, 1, 1, 0, 0, 0, …)\) (apples) and \((2, 2, 2, 2, 2, 2, 0, 0, 0, …)\) (oranges), and the optimal decision boundary is the hyperplane orthogonal to the line between them. For \(p\) smaller than \(6\), the decision rule cannot reach this hyperplane – it is biased. As a result, the misclassification rate is suboptimal, and it decreases with \(p\). But what happens for \(p\) larger than \(6\)? The algorithm is, in principle, able to model the optimal hyperplane, and it should not be distracted by the additional features. The problem is that it is. The more additional features enter the dataset, the higher the probability that one or more of them happen to fall in a way that they <em>look like</em> good, discriminating features in the training data – only to mislead the classifier and degrade its performance in the test data. Shortly we’ll see how to use penalization to (try to) control this problem.</p>
<p>The term <strong>curse of dimensionality</strong> was coined by Bellman (<a href="16-chap.html#ref-Bellman:1961">1961</a>). It refers to the fact that high- dimensional spaces are very hard, if not impossible, to sample thoroughly: for instance, to cover a 2-dimensional square of side length 1 with grid points that are 0.1 apart, we need \(10^2=100\) points. In 100 dimensions, we need \(10^{100}\) – which is more than <a href="https://en.wikipedia.org/wiki/Eddington_number">the number of protons in the universe</a>. In genomics, we often aim to fit models to data with thousands of features. Also our intuitions about distances between points or about the relationship between a volume and its surface break down in a high-dimensional settings. We’ll explore some of the weirdnesses of high-dimensional spaces in the next few questions.</p>
<p>__</p>
<p>Question 12.12</p>
<p>Assume you have a dataset with 1 000 000 data points in \(p\) dimensions. The data are uniformly distributed in the unit hybercube (i.e., all features lie in the interval \([0,1]\)). What’s the side length of a hybercube that can be expected to contain just 10 of the points, as a function of \(p\)?</p>
<p>__</p>
<p>Solution</p>
<p>__</p>
<p>See Figure 12.15.</p>
<pre><code>sideLength = function(p, pointDensity = 1e6, pointsNeeded = 10)
  (pointsNeeded / pointDensity) ^ (1 / p)
ggplot(tibble(p = 1:400, sideLength = sideLength(p)),
       aes(x = p, y = sideLength)) + geom_line(col = "red") +
  geom_hline(aes(yintercept = 1), linetype = 2)__</code></pre>
<p><a href="12-chap_files/figure-html/fig-cursedimans1-1-1.png &quot;Figure 12.15: Side length of a p-dimensional hybercube expected to contain 10 points out of 1 million uniformly distributed ones, as a function of the p. While for p=1, this length is conveniently small, namely 10/10^6=10^{-5}, for larger p it approaches 1, i.,e., becomes the same as the range of each the features. This means that a “local neighborhood” of 10 points encompasses almost the same data range as the whole dataset.&quot;"><img src="12-chap_files/figure-html/fig- cursedimans1-1-1.png" class="img-fluid"></a></p>
<p>Figure 12.15: Side length of a \(p\)-dimensional hybercube expected to contain 10 points out of 1 million uniformly distributed ones, as a function of the \(p\). While for \(p=1\), this length is conveniently small, namely \(10/10<sup>6=10</sup>{-5}\), for larger \(p\) it approaches 1, i.,e., becomes the same as the range of each the features. This means that a “local neighborhood” of 10 points encompasses almost the same data range as the whole dataset.</p>
<p>Next, let’s look at the relation between inner regions of the feature space versus its boundary regions. Generally speaking, prediction at the boundaries of feature space is more difficult than in its interior, as it tends to involve extrapolation, rather than interpolation. In the next question you’ll see how this difficulty explodes with feature space dimension.</p>
<p>__</p>
<p>Question 12.13</p>
<p>What fraction of a unit cube’s total volume is closer than 0.01 to any of its surfaces, as a function of the dimension?</p>
<p>__</p>
<p>Solution</p>
<p>__</p>
<p>See code below and Figure 12.16.</p>
<pre><code>tibble(
  p = 1:400,
  volOuterCube = 1 ^ p,
  volInnerCube = 0.98 ^ p,  # 0.98 = 1 - 2 * 0.01
  `V(shell)` = volOuterCube - volInnerCube) |&gt;
ggplot(aes(x = p, y =`V(shell)`)) + geom_line(col = "blue")__</code></pre>
<p><a href="12-chap_files/figure-html/fig-cursedimans2-1-1.png &quot;Figure 12.16: Fraction of a unit cube’s total volume that is in its “shell” (here operationalised as those points that are closer than 0.01 to its surface) as a function of the dimension p.&quot;"><img src="12-chap_files/figure-html/fig- cursedimans2-1-1.png" class="img-fluid"></a></p>
<p>Figure 12.16: Fraction of a unit cube’s total volume that is in its “shell” (here operationalised as those points that are closer than 0.01 to its surface) as a function of the dimension \(p\).</p>
<p>__</p>
<p>Question 12.14</p>
<p>What is the coefficient of variation (ratio of standard deviation over average) of the distance between two randomly picked points in the unit hypercube, as a function of the dimension?</p>
<p>__</p>
<p>Solution</p>
<p>__</p>
<p>We solve this one by simulation. We generate <code>n</code> pairs of random points in the hypercube (<code>x1</code>, <code>x2</code>) and compute their Euclidean distances. See Figure 12.17. This result can also be predicted from the central limit theorem.</p>
<pre><code>n = 1000
df = tibble(
  p = round(10 ^ seq(0, 4, by = 0.25)),
  cv = vapply(p, function(k) {
    x1 = matrix(runif(k * n), nrow = n)
    x2 = matrix(runif(k * n), nrow = n)
    d = sqrt(rowSums((x1 - x2)^2))
    sd(d) / mean(d)
  }, FUN.VALUE = numeric(1)))
ggplot(df, aes(x = log10(p), y = cv)) + geom_line(col = "orange") +
  geom_point()__</code></pre>
<p><a href="12-chap_files/figure-html/fig-cursedimans3-1-1.png &quot;Figure 12.17: Coefficient of variation (CV) of the distance between randomly picked points in the unit hypercube, as a function of the dimension. As the dimension increases, everybody is equally far away from everyone else: there is almost no variation in the distances any more.&quot;"><img src="12-chap_files/figure-html/fig- cursedimans3-1-1.png" class="img-fluid"></a></p>
<p>Figure 12.17: Coefficient of variation (CV) of the distance between randomly picked points in the unit hypercube, as a function of the dimension. As the dimension increases, everybody is equally far away from everyone else: there is almost no variation in the distances any more.</p>
</section>
</section>
<section id="objective-functions" class="level2" data-number="14.4">
<h2 data-number="14.4" class="anchored" data-anchor-id="objective-functions"><span class="header-section-number">14.4</span> 12.5 Objective functions</h2>
<p>We’ve already seen the <strong>misclassification rate</strong> (MCR) used to assess our classification performance in Figures 12.11–12.13. Its population version is defined as</p>
<p>\[ = , = , \]</p>
<p>and for a finite sample</p>
<p>\[ = <em>{i=1}^n 𝟙</em>{ y_i}. \]</p>
<p>This is not the only choice we could make. Perhaps we care more about the misclassification of apples as oranges than vice versa, and we can reflect this by introducing weights that depend on the type of error made into the sum of Equation 12.2 (or the integral of Equation 12.1). This can get even more elaborate if we have more than two classes. Often we want to see the whole <strong>confusion table</strong> , which we can get via</p>
<pre><code>table(truth, response)__</code></pre>
<p>An important special case is binary classification with asymmetric costs – think about, say, a medical test. Here, the <strong>sensitivity</strong> (a.k.a. <strong>true positive rate</strong> or <strong>recall</strong>) is related to the misclassification of healthy as ill, and the <strong>specificity</strong> (or <strong>true negative rate</strong>) depends on the probability of misclassification of ill as healthy. Often, there is a single parameter (e.g., a threshold) that can be moved up and down, allowing a trade- off between sensitivity and specificity (and thus, equivalently, between the two types of misclassification). In those cases, we usually are not content to know the classifier performance at one single choice of threshold, but at many (or all) of them. This leads to <strong>receiver operating characteristic</strong> (<strong>ROC</strong>) or <strong>precision-recall</strong> curves.</p>
<p>__</p>
<p>Question 12.15</p>
<p>What are the exact relationships between the per-class misclassification rates and sensitivity and specificity?</p>
<p>__</p>
<p>Solution</p>
<p>__</p>
<p>The sensitivity or true positive rate is</p>
<p>\[ = , \]</p>
<p>where \(\) is the number of true positives and \(\) the number of all positives. The specificity or true negative rate is</p>
<p>\[ = , \]</p>
<p>where \(\) is the number of true negatives and \(\) the number of all negatives. See also <a href="https://en.wikipedia.org/wiki/Sensitivity_and_specificity" class="uri">https://en.wikipedia.org/wiki/Sensitivity_and_specificity</a></p>
<p>Another cost function can be computed from the <strong>Jaccard index</strong> , which we already saw in <a href="05-chap.html">Chapter 5</a>.</p>
<p>\[ J(A,B) = , \]</p>
<p>where \(A\) is the set of observations for which the true class is 1 (\(A=\{i,|,y_i=1\}\)) and \(B\) is the set of observations for which the predicted class is 1. The number \(J\) is between 0 and 1, and when \(J\) is large, it indicates high overlap of the two sets. Note that \(J\) does not depend on the number of observations for which both true and predicted class is 0 – so it is particularly suitable for measuring the performance of methods that try to find rare events.</p>
<p>We can also consider probabilistic class predictions, which come in the form \((Y,|,X)\). In this case, a possible risk function would be obtained by looking at distances between the true probability distribution and the estimated probability distributions. For two classes, the finite sample version of the \(\) is</p>
<p>\[ = -_{i=1}^n y_i(_i) + (1 - y_i)(1 - _i), \]</p>
<p>where \(_i \) is the prediction, and \(y_i\{0,1\}\) is the truth.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="imgs/devil.png" title="Note that the \log\text{loss} will be infinite if a prediction is totally confident (\hat{p}_i is exactly 0 or 1) but wrong."><img src="imgs/devil.png" class="img-fluid figure-img"></a></p>
<figcaption>Note that the \log\text{loss} will be infinite if a prediction is totally confident (\hat{p}_i is exactly 0 or 1) but wrong.</figcaption>
</figure>
</div>
<p>Note that the \(\) will be infinite if a prediction is totally confident (\(_i\) is exactly \(0\) or \(1\)) but wrong.</p>
<p>For continuous continuous response variables (regression), a natural choice is the <strong>mean squared error</strong> (<strong>MSE</strong>). It is the average squared error,</p>
<p>\[ = _{i=1}^n ( _i - Y_i )^2. \]</p>
<p>The population version is defined analogously, by turning the summation into an integral as in Equations 12.1 and 12.2.</p>
<p>Statisticians call functions like Equations 12.1—12.5 variously (and depending on context and predisposition) <strong>risk function</strong> , <strong>cost function</strong> , <strong>objective function</strong> 7.</p>
<p>7 There is even an R package dedicated to evaluation of statistical learners called <strong><a href="https://cran.r-project.org/web/packages/metrics/">metrics</a></strong>.</p>
</section>
<section id="variancebias-trade-off" class="level2" data-number="14.5">
<h2 data-number="14.5" class="anchored" data-anchor-id="variancebias-trade-off"><span class="header-section-number">14.5</span> 12.6 Variance–bias trade-off</h2>
<p><a href="imgs/TargetBias.png" title="Figure 12.18 (a):"><img src="imgs/TargetBias.png" class="img-fluid"></a></p>
<ol type="a">
<li></li>
</ol>
<p><a href="imgs/TargetVariance.png" title="Figure 12.18 (b):"><img src="imgs/TargetVariance.png" class="img-fluid"></a></p>
<ol start="2" type="a">
<li></li>
</ol>
<p>Figure 12.18: In bull’s eye (a), the estimates are systematically off target, but in a quite reproducible manner. The green segment represents the bias. In bull’s eye (b), the estimates are not biased, as they are centered in the right place, however they have high variance. We can distinguish the two scenarios since we see the result from many shots. If we only had one shot and missed the bull’s eye, we could not easily know whether that’s because of bias or variance.</p>
<p>An important fact that helps us understand the tradeoffs when picking a statistical learning model is that the MSE is the sum of two terms, and often the choices we can make are such that one of those terms goes down while the other one goes up. The bias measures how different the average of all the different estimates is from the truth, and variance, how much an individual one might scatter from the average value (Figure 12.18). In applications, we often only get one shot, therefore being reliably almost on target can beat being right on the long term average but really off today. The decomposition</p>
<p>\[ = <em>{} + </em>{} \]</p>
<p>follows by straightforward algebra.</p>
<p>When trying to minimize the MSE, it is important to realize that sometimes we can pay the price of a small bias to greatly reduce variance, and thus overall improve MSE. We already encountered shrinkage estimation in <a href="08-chap.html">Chapter 8</a>. In classification (i.e., when we have categorical response variables), different objective functions than the MSE are used, and there is usually no such straightforward decomposition as in Equation 12.6. The good news is that we can usually go even much further than in the case of continuous responses with our trading biases for variance. This is because the discreteness of the response absorbs certain biases (<a href="16-chap.html#ref-friedmanbiasvariance01">Friedman 1997</a>), so that the cost of higher bias is almost zero, while we still get the benefit of better (smaller) variance.</p>
<section id="penalization" class="level3" data-number="14.5.1">
<h3 data-number="14.5.1" class="anchored" data-anchor-id="penalization"><span class="header-section-number">14.5.1</span> 12.6.1 Penalization</h3>
<p>In high-dimensional statistics, we are constantly plagued by variance: there is just not enough data to fit all the possible parameters. One of the most fruitful ideas in high-dimensional statistics is <strong>penalization</strong> : a tool to actively control and exploit the variance-bias tradeoff. Penalization is part of a larger class of regularization methods that are used to ensure stable estimates.</p>
<p>Although generalization of LDA to high-dimensional settings is possible (<a href="16-chap.html#ref-clemmensen2012sparse">Clemmensen et al.&nbsp;2011</a>; <a href="16-chap.html#ref-witten2011penalized">Witten and Tibshirani 2011</a>), it turns out that logistic regression is a more general approach8, and therefore we’ll now switch to that, using the <strong><a href="https://cran.r-project.org/web/packages/glmnet/">glmnet</a></strong> package.</p>
<p>8 It fits into the framework of generalized linear models, which we encountered in <a href="08-chap.html">Chapter 8</a>.</p>
<p>For multinomial—or, for the special case of two classes, binomial—logistic regression models, the posterior log-odds between \(k\) classes and can be written in the form (see the section on <em>Logistic Regression</em> in the book by Hastie, Tibshirani, and Friedman (<a href="16-chap.html#ref- HastieTibshiraniFriedman">2008</a>) for a more complete presentation):</p>
<p>\[ = ^0_i + _i x, \]</p>
<p>where \(i=1,…,k-1\) enumerates the different classes and the \(k\)-th class is chosen as a reference. The data matrix \(x\) has dimensions \(np\), where \(n\) is number of observations and \(p\) the number of features. The \(p\)-dimensional vector \(_i\) determines how the classification odds for class \(i\) versus class \(k\) depend on \(x\). The numbers \(^0_i\) are intercepts and depend, among other things, on the classes’ prior probabilities. Instead of the log odds 12.7 (i.e., ratios of class probabilities), we can also write down an equivalent model for the class probabilities themselves, and the fact that we here used the \(k\)-th class as a reference is an arbitrary choice, as the model estimates are equivariant under this choice (<a href="16-chap.html#ref-HastieTibshiraniFriedman">Hastie, Tibshirani, and Friedman 2008</a>). The model is fit by maximising the log-likelihood \((, ^0; x)\), where \(=(<em>1,…,</em>{k-1})\) and analogously for \(^0\).</p>
<p>So far, so good. But as \(p\) gets larger, there is an increasing chance that some of the estimates go wildly off the mark, due to random sampling happenstances in the data (remember Figure 12.1). This is true even if for each individual coordinate of the vector \(_i\), the error distribution is bounded: the probabilty of there being one coordinate that is in the far tails increases the more coordiates there are, i.e., the larger \(p\) is.</p>
<p>A related problem can also occur, not in 12.7, but in other, non-linear models, as the model dimension \(p\) increases while the sample size \(n\) remains the same: the likelihood landscape around its maximum becomes increasingly flat, and the maximum-likelihood estimate of the model parameters becomes more and more variable. Eventually, the maximum is no longer a point, but a submanifold, and the maximum likelihood estimate is unidentifiable. Both of these limitations can be overcome with a modification of the objective: instead of maximising the bare log-likelihood, we maximise a penalized version of it,</p>
<p>\[ = _(, ^0; x) + (), \]</p>
<p>where \(\) is a real number, and \(\) is a convex function, called the <strong>penalty function</strong>. Popular choices are \(()=||^2\) (<strong>ridge regression</strong>) and \(()=||^1\) (<strong>lasso</strong>).</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="imgs/devil.png" title="Here, |\beta|^\nu=\sum_i\beta_i^\nu is the L_\nu-norm of the vector \beta. Variations are possible, for instead we could include in this summation only some but not all of the elements of \beta; or we could scale different elements differently, for instance based on some prior belief of their scale and importance."><img src="imgs/devil.png" class="img-fluid figure-img"></a></p>
<figcaption>Here, |\beta|<sup>\nu=\sum_i\beta_i</sup>\nu is the L_\nu-norm of the vector \beta. Variations are possible, for instead we could include in this summation only some but not all of the elements of \beta; or we could scale different elements differently, for instance based on some prior belief of their scale and importance.</figcaption>
</figure>
</div>
<p>Here, \(||^=_i<em>i^\) is the \(L</em>\)-norm of the vector \(\). Variations are possible, for instead we could include in this summation only some but not all of the elements of \(\); or we could scale different elements differently, for instance based on some prior belief of their scale and importance.</p>
<p>In the <strong>elastic net</strong> , ridge and lasso are hybridized by using the penalty function \(()=(1-)||<sup>1+||</sup>2\) with some further parameter \(\). The crux is, of course, how to choose the right \(\), and we will discuss that in the following.</p>
</section>
<section id="example-predicting-colon-cancer-from-stool-microbiome-composition" class="level3" data-number="14.5.2">
<h3 data-number="14.5.2" class="anchored" data-anchor-id="example-predicting-colon-cancer-from-stool-microbiome-composition"><span class="header-section-number">14.5.2</span> 12.6.2 Example: predicting colon cancer from stool microbiome composition</h3>
<p>Zeller et al.&nbsp;(<a href="16-chap.html#ref-Zeller:MSB:2014">2014</a>) studied metagenome sequencing data from fecal samples of 156 humans that included colorectal cancer patients and tumor-free controls. Their aim was to see whether they could identify biomarkers (presence or abundance of certain taxa) that could help with early tumor detection. The data are available from <a href="https://www.bioconductor.org">Bioconductor</a> through its <strong>ExperimentHub</strong> service under the identifier EH361.</p>
<pre><code>library("ExperimentHub")
eh = ExperimentHub()
zeller = eh[["EH361"]]__


table(zeller$disease)__


       cancer large_adenoma             n small_adenoma 
           53            15            61            27 </code></pre>
<p>__</p>
<p>Question 12.16</p>
<p>Explore the <code>eh</code> object to see what other datasets there are.</p>
<p>__</p>
<p>Solution</p>
<p>__</p>
<p>Type <code>eh</code> into the R prompt and study the output.</p>
<p>For the following, let’s focus on the normal and cancer samples and set the adenomas aside.</p>
<pre><code>zellerNC = zeller[, zeller$disease %in% c("n", "cancer")]__</code></pre>
<p>Before jumping into model fitting, as always it’s a good idea to do some exploration of the data. First, let’s look at the sample annotations. The following code prints the data from three randomly picked samples. (Only looking at the first ones, say with the R function <code>head</code>, is also an option, but may not be representative of the whole dataset).</p>
<pre><code>pData(zellerNC)[ sample(ncol(zellerNC), 3), ]__


                   subjectID age gender bmi country disease tnm_stage
CCIS50148151ST-4-0    FR-503  87 female  15  france  cancer    t2n1m0
CCIS16383318ST-4-0    FR-139  61 female  24  france       n      &lt;NA&gt;
CCIS95097901ST-4-0    FR-696  52   male  24  france       n      &lt;NA&gt;
                   ajcc_stage localization     fobt wif-1_gene_methylation_test
CCIS50148151ST-4-0        iii           rc negative                    negative
CCIS16383318ST-4-0       &lt;NA&gt;         &lt;NA&gt; negative                    negative
CCIS95097901ST-4-0       &lt;NA&gt;         &lt;NA&gt; negative                    negative
                     group bodysite ethnicity number_reads
CCIS50148151ST-4-0     crc    stool     white     54709150
CCIS16383318ST-4-0 control    stool     white     78085760
CCIS95097901ST-4-0 control    stool     white     51567166</code></pre>
<p>Next, let’s explore the feature names:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="imgs/devil.png" title="We define the helper function formatfn to line wrap these long character strings for the available space here."><img src="imgs/devil.png" class="img-fluid figure-img"></a></p>
<figcaption>We define the helper function formatfn to line wrap these long character strings for the available space here.</figcaption>
</figure>
</div>
<p>We define the helper function <code>formatfn</code> to line wrap these long character strings for the available space here.</p>
<pre><code>formatfn = function(x)
   gsub("|", "| ", x, fixed = TRUE) |&gt; lapply(strwrap)

rownames(zellerNC)[1:4]__


[1] "k__Bacteria"                  "k__Viruses"                  
[3] "k__Bacteria|p__Firmicutes"    "k__Bacteria|p__Bacteroidetes"


rownames(zellerNC)[nrow(zellerNC) + (-2:0)] |&gt; formatfn()__


[[1]]
[1] "k__Bacteria| p__Proteobacteria| c__Deltaproteobacteria|"         
[2] "o__Desulfovibrionales| f__Desulfovibrionaceae| g__Desulfovibrio|"
[3] "s__Desulfovibrio_termitidis"                                     

[[2]]
[1] "k__Viruses| p__Viruses_noname| c__Viruses_noname| o__Viruses_noname|"
[2] "f__Baculoviridae| g__Alphabaculovirus|"                              
[3] "s__Bombyx_mori_nucleopolyhedrovirus|"                                
[4] "t__Bombyx_mori_nucleopolyhedrovirus_unclassified"                    

[[3]]
[1] "k__Bacteria| p__Proteobacteria| c__Deltaproteobacteria|"         
[2] "o__Desulfovibrionales| f__Desulfovibrionaceae| g__Desulfovibrio|"
[3] "s__Desulfovibrio_termitidis| t__GCF_000504305"                   </code></pre>
<p>As you can see, the features are a mixture of abundance quantifications at different taxonomic levels, from <em>k</em> ingdom over <em>p</em> hylum to <em>s</em> pecies. We could select only some of these, but here we continue with all of them. Next, let’s look at the distribution of some of the features. Here, we show an arbitrary choice of two, number 510 and 527; in practice, it is helpful to scroll through many such plots quickly to get an impression (Figure 12.19).</p>
<pre><code>ggplot(melt(Biobase::exprs(zellerNC)[c(510, 527), ]), aes(x = value)) +
    geom_histogram(bins = 25) +
    facet_wrap( ~ Var1, ncol = 1, scales = "free")__</code></pre>
<p><a href="12-chap_files/figure- html/fig-zellerHist-1-1.png" title="Figure 12.19: Histograms of the distributions for two randomly selected features. The distributions are highly skewed, with many zero values and a thin, long tail of non-zero values."><img src="12-chap_files/figure-html/fig-zellerHist-1-1.png" class="img-fluid"></a></p>
<p>Figure 12.19: Histograms of the distributions for two randomly selected features. The distributions are highly skewed, with many zero values and a thin, long tail of non-zero values.</p>
<p>In the simplest case, we fit model 12.7 as follows.</p>
<pre><code>library("glmnet")
glmfit = glmnet(x = t(Biobase::exprs(zellerNC)),
                y = factor(zellerNC$disease),
                family = "binomial")__</code></pre>
<p>A remarkable feature of the <code>glmnet</code> function is that it fits 12.7 not only for one choice of \(\), but for all possible \(\)s at once. For now, let’s look at the prediction performance for, say, \(\). The name of the function parameter is <code>s</code>:</p>
<pre><code>predTrsf = predict(glmfit, newx = t(Biobase::exprs(zellerNC)),
                   type = "class", s = 0.04)
table(predTrsf, zellerNC$disease)__


        
predTrsf cancer  n
  cancer     51  0
  n           2 61</code></pre>
<p>Not bad – but remember that this is on the training data, without cross- validation. Let’s have a closer look at <code>glmfit</code>. The <strong><a href="https://cran.r-project.org/web/packages/glmnet/">glmnet</a></strong> package offers a a diagnostic plot that is worth looking at (Figure 12.20).</p>
<pre><code>plot(glmfit, col = RColorBrewer::brewer.pal(8, "Dark2"), lwd = sqrt(3), ylab = "")__</code></pre>
<p><a href="12-chap_files/figure- html/fig-plotglmfit-1-1.png" title="Figure 12.20: Regularization paths for glmfit."><img src="12-chap_files/figure-html/fig-plotglmfit-1-1.png" class="img-fluid"></a></p>
<p>Figure 12.20: Regularization paths for <code>glmfit</code>.</p>
<p>__</p>
<p>Question 12.17</p>
<p>What are the \(x\)- and \(y\)-axes in Figure 12.20? What are the different lines?</p>
<p>__</p>
<p>Solution</p>
<p>__</p>
<p>Consult the manual page of the function <code>plot.glmnet</code> in the <strong><a href="https://cran.r-project.org/web/packages/glmnet/">glmnet</a></strong> package.</p>
<p>Let’s get back to the question of how to choose the parameter \(\). We could try many different choices –and indeed, all possible choices– of \(\), assess classification performance in each case using cross- validation, and then choose the best \(\).</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="imgs/devil.png" title="You’ll already realize from the description of this strategy that if we optimize \lambda in this way, the resulting apparent classification performance will likely be exaggerated. We need a truly independent dataset, or at least another, outer cross-validation loop to get a more realistic impression of the generalizability. We will get back to this question at the end of the chapter."><img src="imgs/devil.png" class="img-fluid figure-img"></a></p>
<figcaption>You’ll already realize from the description of this strategy that if we optimize \lambda in this way, the resulting apparent classification performance will likely be exaggerated. We need a truly independent dataset, or at least another, outer cross-validation loop to get a more realistic impression of the generalizability. We will get back to this question at the end of the chapter.</figcaption>
</figure>
</div>
<p>You’ll already realize from the description of this strategy that if we optimize \(\) in this way, the resulting apparent classification performance will likely be exaggerated. We need a truly independent dataset, or at least another, outer cross-validation loop to get a more realistic impression of the generalizability. We will get back to this question at the end of the chapter.</p>
<p>We could do so by writing a loop as we did in the <code>estimate_mcl_loocv</code> function in Section 12.4.1. It turns out that the <strong><a href="https://cran.r-project.org/web/packages/glmnet/">glmnet</a></strong> package already has built-in functionality for that, with the function <code>cv.glmnet</code>, which we can use instead.</p>
<pre><code>cvglmfit = cv.glmnet(x = t(Biobase::exprs(zellerNC)),
                     y = factor(zellerNC$disease),
                     family = "binomial")
plot(cvglmfit)__</code></pre>
<p><a href="12-chap_files/figure- html/fig-colonCV-1-1.png" title="Figure 12.21: Diagnostic plot for cv.glmnet: shown is a measure of cross-validated prediction performance, the deviance, as a function of \lambda. The dashed vertical lines show lambda.min and lambda.1se."><img src="12-chap_files/figure-html/fig-colonCV-1-1.png" class="img-fluid"></a></p>
<p>Figure 12.21: Diagnostic plot for <code>cv.glmnet</code>: shown is a measure of cross- validated prediction performance, the deviance, as a function of \(\). The dashed vertical lines show <code>lambda.min</code> and <code>lambda.1se</code>.</p>
<p>The diagnostic plot is shown in Figure 12.21. We can access the optimal value with</p>
<pre><code>cvglmfit$lambda.min __


[1] 0.0529391</code></pre>
<p>As this value results from finding a minimum in an estimated curve, it turns out that it is often too small, i.e., that the implied penalization is too weak. A heuristic recommended by the authors of the <strong><a href="https://cran.r-project.org/web/packages/glmnet/">glmnet</a></strong> package is to use a somewhat larger value instead, namely the largest value of \(\) such that the performance measure is within 1 standard error of the minimum.</p>
<pre><code>cvglmfit$lambda.1se __


[1] 0.08830775</code></pre>
<p>__</p>
<p>Question 12.18</p>
<p>How does the confusion table look like for \(=;\)<code>lambda.1se</code>?</p>
<p>__</p>
<p>Solution</p>
<p>__</p>
<pre><code>s0 = cvglmfit$lambda.1se
predict(glmfit, newx = t(Biobase::exprs(zellerNC)),type = "class", s = s0) |&gt;
    table(zellerNC$disease)__


        
         cancer  n
  cancer     38  5
  n          15 56</code></pre>
<p>__</p>
<p>Question 12.19</p>
<p>What features drive the classification?</p>
<p>__</p>
<p>Solution</p>
<p>__</p>
<pre><code>coefs = coef(glmfit)[, which.min(abs(glmfit$lambda - s0))]
topthree = order(abs(coefs), decreasing = TRUE)[1:3]
as.vector(coefs[topthree])__


[1] -71.471393  -8.770704  -1.465249


formatfn(names(coefs)[topthree])__


[[1]]
[1] "k__Bacteria| p__Candidatus_Saccharibacteria|"      
[2] "c__Candidatus_Saccharibacteria_noname|"            
[3] "o__Candidatus_Saccharibacteria_noname|"            
[4] "f__Candidatus_Saccharibacteria_noname|"            
[5] "g__Candidatus_Saccharibacteria_noname|"            
[6] "s__candidate_division_TM7_single_cell_isolate_TM7b"

[[2]]
[1] "k__Bacteria| p__Firmicutes| c__Clostridia| o__Clostridiales|"        
[2] "f__Ruminococcaceae| g__Subdoligranulum| s__Subdoligranulum_variabile"

[[3]]
[1] "k__Bacteria| p__Firmicutes| c__Clostridia| o__Clostridiales|"
[2] "f__Lachnospiraceae| g__Lachnospiraceae_noname|"              
[3] "s__Lachnospiraceae_bacterium_7_1_58FAA"                      </code></pre>
<p>__</p>
<p>Question 12.20</p>
<p>How do the results change if we transform the data, say, with the <code>asinh</code> transformation as we saw in <a href="05-chap.html">Chapter 5</a>?</p>
<p>__</p>
<p>Solution</p>
<p>__</p>
<p>See Figure 12.22.</p>
<pre><code>cv.glmnet(x = t(asinh(Biobase::exprs(zellerNC))),
          y = factor(zellerNC$disease),
          family = "binomial") |&gt; plot()__</code></pre>
<p><a href="12-chap_files/figure- html/fig-colonCVTrsf-1-1.png" title="Figure 12.22: like Figure fig-colonCV-1, but using an \text{asinh} transformation of the data."><img src="12-chap_files/figure-html/fig-colonCVTrsf-1-1.png" class="img-fluid"></a></p>
<p>Figure 12.22: like Figure 12.21, but using an \(\) transformation of the data.</p>
<p>__</p>
<p>Question 12.21</p>
<p>Would a good classification performance on these data mean that this assay is ready for screening and early cancer detection?</p>
<p>__</p>
<p>Solution</p>
<p>__</p>
<p>No.&nbsp;The performance here is measured on a set of samples in which the cases have similar prevalence as the controls. This serves well enough to explore the biology. However, in a real-life application, the cases will be much less frequent. To be practically useful, the assay must have a much higher specificity, i.e., rarely diagnose disease where there is none. To establish specificity, a much larger set of normal samples need to be tested.</p>
</section>
<section id="example-classifying-mouse-cells-from-their-expression-profiles" class="level3" data-number="14.5.3">
<h3 data-number="14.5.3" class="anchored" data-anchor-id="example-classifying-mouse-cells-from-their-expression-profiles"><span class="header-section-number">14.5.3</span> 12.6.3 Example: classifying mouse cells from their expression profiles</h3>
<p>Figures 12.21 and 12.22 are textbook examples of how we expect the dependence of (cross-validated) classification performance versus model complexity (\(\)) to look. Now let’s get back to the mouse embryo cells data. We’ll try to classify the cells from embryonic day <code>E3.25</code> with respect to their genotype.</p>
<pre><code>sx = x[, x$Embryonic.day == "E3.25"]
embryoCellsClassifier = cv.glmnet(t(Biobase::exprs(sx)), sx$genotype,
                family = "binomial", type.measure = "class")
plot(embryoCellsClassifier)__</code></pre>
<p><a href="12-chap_files/figure-html/fig-mousecvglmfit-1-1.png &quot;Figure 12.23: Cross-validated misclassification error versus penalty parameter for the mouse cells data.&quot;"><img src="12-chap_files/figure-html/fig- mousecvglmfit-1-1.png" class="img-fluid"></a></p>
<p>Figure 12.23: Cross-validated misclassification error versus penalty parameter for the mouse cells data.</p>
<p>In Figure 12.23 we see that the misclassification error is (essentially) monotonously increasing with \(\), and is smallest for \(\), i.e., if we apply no penalization at all.</p>
<p>__</p>
<p>Question 12.22</p>
<p>What is going on with these data?</p>
<p>__</p>
<p>Solution</p>
<p>__</p>
<p>It looks that inclusion of more, and even of all features, does not harm the classification performance. In a way, these data are “too easy”. Let’s do a \(t\)-test for all features:</p>
<pre><code>mouse_de = rowttests(sx, "genotype")
ggplot(mouse_de, aes(x = p.value)) +
  geom_histogram(boundary = 0, breaks = seq(0, 1, by = 0.01))__</code></pre>
<p><a href="12-chap_files/figure-html/fig- mousecellsrowttst-1-1.png" title="Figure 12.24: Histogram of p-values for the per- feature t-tests between genotypes in the E3.25 cells."><img src="12-chap_files/figure-html/fig- mousecellsrowttst-1-1.png" class="img-fluid"></a></p>
<p>Figure 12.24: Histogram of p-values for the per-feature \(t\)-tests between genotypes in the E3.25 cells.</p>
<p>The result, shown in Figure 12.24, shows that large number of genes are differentially expressed, and thus informative for the class distinction. We can also compute the pairwise distances between all cells, using all features.</p>
<pre><code>dists = as.matrix(dist(scale(t(Biobase::exprs(x)))))
diag(dists) = +Inf __</code></pre>
<p>and then for each cell determine the class of its nearest neighbor</p>
<pre><code>nn = sapply(seq_len(ncol(dists)), function(i) which.min(dists[, i]))
table(x$sampleGroup, x$sampleGroup[nn]) |&gt; `colnames&lt;-`(NULL)__


                 
                  [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
  E3.25             33    0    0    0    3    0    0    0
  E3.25 (FGF4-KO)    1   15    0    1    0    0    0    0
  E3.5 (EPI)         2    0    3    0    6    0    0    0
  E3.5 (FGF4-KO)     0    0    0    8    0    0    0    0
  E3.5 (PE)          0    0    0    0   11    0    0    0
  E4.5 (EPI)         0    0    0    0    2    2    0    0
  E4.5 (FGF4-KO)     1    0    0    0    0    0    9    0
  E4.5 (PE)          0    0    0    0    2    0    0    2</code></pre>
<p>Using all features, the 1 nearest-neighbor classifier is correct in almost all cases, including for the E3.25 wildtype vs FGF4-KO distinction. This means that for these data, there is no apparent benefit in regularization or feature selection. Limitations of using all features might become apparent with truly new data, but that is out of reach for cross-validation.</p>
</section>
</section>
<section id="a-large-choice-of-methods" class="level2" data-number="14.6">
<h2 data-number="14.6" class="anchored" data-anchor-id="a-large-choice-of-methods"><span class="header-section-number">14.6</span> 12.7 A large choice of methods</h2>
<p>We have now seen three classification methods: linear discriminant analysis (<code>lda</code>), quadratic discriminant analysis (<code>qda</code>) and logistic regression using elastic net penalization (<code>glmnet</code>). In fact, there are hundreds of different learning algorithms9 available in R and its add-on packages. You can get an overview in the CRAN task view <a href="https://cran.r-project.org/web/views/MachineLearning.html">Machine Learning &amp; Statistical Learning</a>. Some examples are:</p>
<p>9 For an introduction to the subject that uses R and provides many examples and exercises, we recommend (<a href="16-chap.html#ref- James:2013">James et al.&nbsp;2013</a>).</p>
<ul>
<li><p>Support vector machines: the function <code>svm</code> in the package <strong><a href="https://cran.r-project.org/web/packages/e1071/">e1071</a></strong> ; <code>ksvm</code> in <strong><a href="https://cran.r-project.org/web/packages/kernlab/">kernlab</a></strong></p></li>
<li><p>Tree based methods in the packages <strong><a href="https://cran.r-project.org/web/packages/rpart/">rpart</a></strong> , <strong><a href="https://cran.r-project.org/web/packages/tree/">tree</a></strong> , <strong><a href="https://cran.r-project.org/web/packages/randomForest/">randomForest</a></strong></p></li>
<li><p>Boosting methods: the functions <code>glmboost</code> and <code>gamboost</code> in package <strong><a href="https://cran.r-project.org/web/packages/mboost/">mboost</a></strong></p></li>
<li><p><code>PenalizedLDA</code> in the package <strong><a href="https://cran.r-project.org/web/packages/PenalizedLDA/">PenalizedLDA</a></strong> , <code>dudi.discr</code> and <code>dist.pcaiv</code> in <strong><a href="https://cran.r-project.org/web/packages/ade4/">ade4</a></strong>).</p></li>
</ul>
<p>The complexity and heterogeneity of choices of learning strategies, tuning parameters and evaluation criteria in each of these packages can be confusing. You will already have noted differences in the interfaces of the <code>lda</code>, <code>qda</code> and <code>glmnet</code> functions, i.e., in how they expect their input data to presented and what they return. There is even greater diversity across all the other packages and functions. At the same time, there are common tasks such as cross-validation, parameter tuning and performance assessment that are more or less the same no matter what specific method is used. As you have seen, e.g., in our <code>estimate_mcl_loocv</code> function, the looping and data shuffling involved led to rather verbose code.</p>
<p>So what to do if you want to try out and explore different learning algorithms? Fortunately, there are several projects that provide unified interfaces to the large number of different machine learning interfaces in R, and also try to provide “best practice” implementations of the common tasks such as parameter tuning and performance assessment. The two most well-known ones are the packages <strong><a href="https://cran.r-project.org/web/packages/caret/">caret</a></strong> and <strong><a href="https://cran.r-project.org/web/packages/mlr/">mlr</a></strong>. Here were have a look at <strong><a href="https://cran.r-project.org/web/packages/caret/">caret</a></strong>. You can get a list of supported methods through its <code>getModelInfo</code> function. There are quite a few, here we just show the first 8.</p>
<pre><code>library("caret")
caretMethods = names(getModelInfo())
head(caretMethods, 8)__


[1] "ada"         "AdaBag"      "AdaBoost.M1" "adaboost"    "amdai"      
[6] "ANFIS"       "avNNet"      "awnb"       


length(caretMethods)__


[1] 239</code></pre>
<p>We will check out a neural network method, the <code>nnet</code> function from the eponymous package. The <code>parameter</code> slot informs us on the the available tuning parameters10.</p>
<p>10 They are described in the manual of the <code>nnet</code> function.</p>
<pre><code>getModelInfo("nnet", regex = FALSE)[[1]]$parameter __


  parameter   class         label
1      size numeric #Hidden Units
2     decay numeric  Weight Decay</code></pre>
<p>Let’s try it out.</p>
<pre><code>trnCtrl = trainControl(
  method = "repeatedcv",
  repeats = 3,
  classProbs = TRUE)
tuneGrid = expand.grid(
  size = c(2, 4, 8),
  decay = c(0, 1e-2, 1e-1))
nnfit = train(
  Embryonic.day ~ Fn1 + Timd2 + Gata4 + Sox7,
  data = embryoCells,
  method = "nnet",
  tuneGrid  = tuneGrid,
  trControl = trnCtrl,
  metric = "Accuracy")__</code></pre>
<p>That’s quite a mouthful, but the nice thing is that this syntax is standardized and applies across many different methods. All you need to do specify the name of the method and the grid of tuning parameters that should be explored via the <code>tuneGrid</code> argument.</p>
<p>Now we can have a look at the output (Figure 12.25).</p>
<pre><code>nnfit __


Neural Network 

66 samples
 4 predictor
 3 classes: 'E3.25', 'E3.5', 'E4.5' 

No pre-processing
Resampling: Cross-Validated (10 fold, repeated 3 times) 
Summary of sample sizes: 60, 59, 60, 60, 59, 59, ... 
Resampling results across tuning parameters:

  size  decay  Accuracy   Kappa    
  2     0.00   0.7083333  0.4279755
  2     0.01   0.7676587  0.5858922
  2     0.10   0.7681349  0.5767463
  4     0.00   0.7515476  0.5638426
  4     0.01   0.8004762  0.6486256
  4     0.10   0.7638889  0.5676798
  8     0.00   0.7385714  0.5393148
  8     0.01   0.7348016  0.5281220
  8     0.10   0.7532540  0.5525435

Accuracy was used to select the optimal model using the largest value.
The final values used for the model were size = 4 and decay = 0.01.


plot(nnfit)
predict(nnfit) |&gt; head(10)__


 [1] E3.25 E3.25 E3.25 E3.25 E3.25 E3.25 E3.25 E3.25 E3.25 E3.25
Levels: E3.25 E3.5 E4.5</code></pre>
<p><a href="12-chap_files/figure- html/fig-ML-nnfit-1.png" title="Figure 12.25: Parameter tuning of the neural net by cross-validation."><img src="12-chap_files/figure-html/fig-ML-nnfit-1.png" class="img-fluid"></a></p>
<p>Figure 12.25: Parameter tuning of the neural net by cross-validation.</p>
<p>__</p>
<p>Question 12.23</p>
<p>Will the accuracy that we obtained above for the optimal tuning parameters generalize to a new dataset? What could you do to address that?</p>
<p>__</p>
<p>Solution</p>
<p>__</p>
<p>No, it is likely to be too optimistic, as we have picked the optimum. To get a somewhat more realistic estimate of prediction performance when generalized, we could formalize (into computer code) all our data preprocessing choices and the above parameter tuning procedure, and embed this in another, outer cross- validation loop (<a href="16-chap.html#ref- ambroise2002selection">Ambroise and McLachlan 2002</a>). However, this is likely still not enough, as we discuss in the next section.</p>
<section id="method-hacking" class="level3" data-number="14.6.1">
<h3 data-number="14.6.1" class="anchored" data-anchor-id="method-hacking"><span class="header-section-number">14.6.1</span> 12.7.1 Method hacking</h3>
<p>In <a href="06-chap.html">Chapter 6</a> we encountered <em>p-value hacking</em>. A similar phenomenon exists in statistical learning: given a dataset, we explore various different methods of preprocessing (such as normalization, outlier detection, transformation, feature selection), try out different machine learning algorithms and tune their parameters until we are content with the result. The measured accuracy is likely to be too optimistic, i.e., will not generalize to a new dataset. Embedding as many of our methodical choices into a computational formalism and having an outer cross-validation loop (not to be confused with the inner loop that does the parameter tuning) will ameliorate the problem. But is unlikely to address it completely, since not all our choices can be formalized.</p>
<p>The gold standard remains validation on truly unseen data. In addition, it is never a bad thing if the classifier is not a black box but can be interpreted in terms of domain knowledge. Finally, report not just summary statistics, such as misclassification rates, but lay open the complete computational workflow, so that anyone (including your future self) can convince themselves of the robustness of the result or of the influence of the preprocessing, model selection and tuning choices (<a href="16-chap.html#ref- Holmes2017">Holmes 2018</a>).</p>
</section>
</section>
<section id="summary-of-this-chapter" class="level2" data-number="14.7">
<h2 data-number="14.7" class="anchored" data-anchor-id="summary-of-this-chapter"><span class="header-section-number">14.7</span> 12.8 Summary of this chapter</h2>
<p>We have seen examples of machine learning applications; we have focused on predicting categorical variables (like diabetes type or cell class). Predicting continuous outcomes is also part of machine learning, although we have not considered it here. There are many parallels and overlaps between <em>machine learning</em> and <em>statistical regression</em> (which we studied in <a href="08-chap.html">Chapter 8</a>). One can consider them two different names for pretty much the same activity, although each has its own flavors: in machine learning, the emphasis is on the prediction of the outcome variables, whereas in regression we often care at least as much about the role of the covariates – which of them have an effect on the outcome, and what is the nature of these effects? In other words, we do not only want predictions, we also want to understand them.</p>
<p>We saw linear and quadratic discriminant analysis, two intuitive methods for partitioning a two-dimensional data plane (or a \(p\)-dimensional space) into regions using either linear or quadratic separation lines (or hypersurfaces). We also saw logistic regression, which takes a slightly different approach but is more amenable to operating in higher dimensions and to regularization.</p>
<p>We encountered the main challenge of machine learning: how to avoid overfitting? We explored why overfitting happens in the context of the so- called curse of dimensionality, and we learned how it may be overcome using regularization.</p>
<p>In other words, machine learning would be easy if we had infinite amounts of data representatively covering the whole space of possible inputs and outputs11. The challenge is to make the best out of a finite amount of training data, and to generalize these to new, unseen inputs. There is a vigorous trade-off between the amount, resolution and coverage of training data and the complexity of the model. Many models have continuous parameters that enable us to “tune” their complexity or the strength of their regularization. Cross-validation can help us with such tuning, although it is not a panacea, and caveats apply, as we saw in Section 12.6.3.</p>
<p>11 It would “just” be a formidable database / data management problem.</p>
</section>
<section id="further-reading" class="level2" data-number="14.8">
<h2 data-number="14.8" class="anchored" data-anchor-id="further-reading"><span class="header-section-number">14.8</span> 12.9 Further reading</h2>
<ul>
<li><p>An introduction to statistical learning that employs many concrete data examples and uses little mathematical formalism is given by James et al.&nbsp;(<a href="16-chap.html#ref-James:2013">2013</a>). An extension, with more mathematical background, is the textbook by Hastie, Tibshirani, and Friedman (<a href="16-chap.html#ref-HastieTibshiraniFriedman">2008</a>).</p></li>
<li><p>The <a href="https://cran.r-project.org/web/views/MachineLearning.html">CRAN task view on machine learning</a> gives an overview over machine learning software in R.</p></li>
<li><p><a href="https://tensorflow.rstudio.com/keras">RStudio’s API for the “deep learning” platforms Keras and TensorFlow</a> and the associated teaching materials and demos are a good place to try out some of the recent developments in this field.</p></li>
</ul>
</section>
<section id="exercises" class="level2" data-number="14.9">
<h2 data-number="14.9" class="anchored" data-anchor-id="exercises"><span class="header-section-number">14.9</span> 12.10 Exercises</h2>
<p>__</p>
<p>Exercise 12.1</p>
<p>Apply a <em>kernel support vector machine</em> , available in the <strong><a href="https://cran.r-project.org/web/packages/kernlab/">kernlab</a></strong> package, to the <code>zeller</code> microbiome data. What kernel function works well?</p>
<p>__</p>
<p>Exercise 12.2</p>
<p>Use <code>glmnet</code> for a <em>prediction of a continuous variable</em> , i.e., for regression. Use the prostate cancer data from Chapter 3 of (<a href="16-chap.html#ref-HastieTibshiraniFriedman">Hastie, Tibshirani, and Friedman 2008</a>). The data are available in the CRAN package <strong><a href="https://cran.r-project.org/web/packages/ElemStatLearn/">ElemStatLearn</a></strong>. Explore the effects of using ridge versus lasso penalty.</p>
<p>__</p>
<p>Exercise 12.3</p>
<p>Consider <em>smoothing as a regression and model selection problem</em> (remember Figure 12.1). What is the equivalent quantity to the penalization parameter \(\) in Equation 12.8? How do you choose it?</p>
<p>__</p>
<p>Solution</p>
<p>__</p>
<p>We refer to Chapter 5 of (<a href="16-chap.html#ref-HastieTibshiraniFriedman">Hastie, Tibshirani, and Friedman 2008</a>)</p>
<p>__</p>
<p>Exercise 12.4</p>
<p><em>Scale invariance</em>. Consider a rescaling of one of the features in the (generalized) linear model 12.7. For instance, denote the \(\)-th column of \(x\) by \(x_{}\), and suppose that \(p\) and that we rescale \(x_{} s, x_{}\) with some number \(s\). What will happen to the estimate \(\) from Equation 12.8 in (a) the unpenalized case (\(\)) and (b) the penalized case (\(&gt;0\))?</p>
<p>__</p>
<p>Solution</p>
<p>__</p>
<p>In the unpenalized case, the estimates will be scaled by \(1/s\), so that the resulting model is, in effect, the same. In the penalized case, the penalty from the \(\)-th component of \(\) will be different. If \(|s|&gt;1\), the amplitude of the feature is increased, smaller \(\)-components are required for it to have the same effect in the prediction, and therefore the feature is more likely to receive a non-zero and/or larger estimate, possibly on the cost of the other features; conversely for \(|s|&lt;1\). Regular linear regression is scale-invariant, whereas penalized regression is scale-dependent. It’s important to remember this when interpreting penalized model fits.</p>
<p>__</p>
<p>Exercise 12.5</p>
<p>It has been quipped that all classification methods are just refinements of <em>two archetypal ideas</em> : discriminant analysis and \(k\) nearest neighbors. In what sense might that be a useful classification?</p>
<p>__</p>
<p>Solution</p>
<p>__</p>
<p>In linear discriminant analysis, we consider our objects as elements of \(^p\), and the learning task is to define regions in this space, or boundary hyperplanes between them, which we use to predict the class membership of new objects. This is archetypal for <em>classification by partition</em>. Generalizations of linear discriminant analysis permit more general spaces and more general boundary shapes.</p>
<p>In \(k\) nearest neighbors, no embedding into a coordinate space is needed, but instead we require a distance (or dissimilarity) measure that can be computed between each pair of objects, and the classification decision for a new object depends on its distances to the training objects and their classes. This is archetypal for <em>kernel-based</em> methods.</p>
<p>Ambroise, Christophe, and Geoffrey J. McLachlan. 2002. “Selection Bias in Gene Extraction on the Basis of Microarray Gene-Expression Data.” <em>PNAS</em> 99 (10): 6562–66.</p>
<p>Bellman, Richard Ernest. 1961. <em>Adaptive Control Processes: A Guided Tour</em>. Princeton University Press.</p>
<p>Clemmensen, Line, Trevor Hastie, Daniela Witten, and Bjarne Ersbøll. 2011. “Sparse Discriminant Analysis.” <em>Technometrics</em> 53: 406–13.</p>
<p>Friedman, Jerome H. 1997. “On Bias, Variance, 0/1—Loss, and the Curse-of- Dimensionality.” <em>Data Mining and Knowledge Discovery</em> 1: 55–77.</p>
<p>Hastie, Trevor, Robert Tibshirani, and Jerome Friedman. 2008. <em>The Elements of Statistical Learning</em>. 2^{} ed.&nbsp;Springer.</p>
<p>Holmes, Susan. 2018. “Statistical Proof? The Problem of Irreproducibility.” <em>Bulletin of the AMS</em> 55 (1): 31–55.</p>
<p>James, Gareth, Daniela Witten, Trevor Hastie, and Robert Tibshirani. 2013. <em>An Introduction to Statistical Learning</em>. Springer.</p>
<p>Neumann, B., T. Walter, J. K. Heriche, J. Bulkescher, H. Erfle, C. Conrad, P. Rogers, et al.&nbsp;2010. “Phenotypic profiling of the human genome by time-lapse microscopy reveals cell division genes.” <em>Nature</em> 464 (7289): 721–27.</p>
<p>Ohnishi, Y., W. Huber, A. Tsumura, M. Kang, P. Xenopoulos, K. Kurimoto, A. K. Oles, et al.&nbsp;2014. “Cell-to-Cell Expression Variability Followed by Signal Reinforcement Progressively Segregates Early Mouse Lineages.” <em>Nature Cell Biology</em> 16 (1): 27–37.</p>
<p>Reaven, GM, and RG Miller. 1979. “An Attempt to Define the Nature of Chemical Diabetes Using a Multidimensional Analysis.” <em>Diabetologia</em> 16 (1): 17–24.</p>
<p>Witten, Daniela M, and Robert Tibshirani. 2011. “Penalized Classification Using Fisher’s Linear Discriminant.” <em>JRSSB</em> 73 (5): 753–72.</p>
<p>Zeller, Georg, Julien Tap, Anita Y Voigt, Shinichi Sunagawa, Jens Roat Kultima, Paul I Costea, Aurélien Amiot, et al.&nbsp;2014. “Potential of Fecal Microbiota for Early-Stage Detection of Colorectal Cancer.” <em>Molecular Systems Biology</em> 10 (11): 766. <a href="https://doi.org/10.15252/msb.20145645" class="uri">https://doi.org/10.15252/msb.20145645</a>.</p>
<p>Page built at 01:33 on 2025-09-01 using R version 4.5.1 (2025-06-13)</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./11-chap.html" class="pagination-link" aria-label="11.1 Goals for this chapter">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">11.1 Goals for this chapter</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./13-chap.html" class="pagination-link" aria-label="13.1 Goals for this chapter">
        <span class="nav-page-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">13.1 Goals for this chapter</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>