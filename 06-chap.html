<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>8&nbsp; 6.1 Goals for this Chapter – Modern Statistics for Modern Biology</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./07-chap.html" rel="next">
<link href="./05-chap.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-22854ec117201859c8a7ba6f538122c9.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="msmb.css">
</head>

<body class="nav-sidebar docked quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./06-chap.html"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">6.1 Goals for this Chapter</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Modern Statistics for Modern Biology</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Home</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./00-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">The challenge: heterogeneity</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">1.1 Goals for this chapter</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">2.1 Goals for this chapter</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">3.1 Goals for this chapter</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">4.1 Goals for this chapter</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">5.1 Goals for this chapter</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06-chap.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">6.1 Goals for this Chapter</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">7.1 Goals for this chapter</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./08-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">8.1 Goals of this chapter</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./09-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">9.1 Goals for this chapter</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./10-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">10.1 Goals for this chapter</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./11-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">11.1 Goals for this chapter</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./12-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">12.1 Goals for this chapter</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./13-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">13.1 Goals for this chapter</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./14-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">14-chap.html</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./15-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">15-chap.html</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./16-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">16-chap.html</span></span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#drinking-from-the-firehose" id="toc-drinking-from-the-firehose" class="nav-link active" data-scroll-target="#drinking-from-the-firehose"><span class="header-section-number">8.0.1</span> 6.1.1 Drinking from the firehose</a></li>
  <li><a href="#testing-versus-classification" id="toc-testing-versus-classification" class="nav-link" data-scroll-target="#testing-versus-classification"><span class="header-section-number">8.0.2</span> 6.1.2 Testing versus classification</a></li>
  <li><a href="#false-discovery-rate-or-p-value" id="toc-false-discovery-rate-or-p-value" class="nav-link" data-scroll-target="#false-discovery-rate-or-p-value"><span class="header-section-number">8.0.3</span> 6.1.3 False discovery rate or p-value?</a></li>
  <li><a href="#the-multiple-testing-opportunity" id="toc-the-multiple-testing-opportunity" class="nav-link" data-scroll-target="#the-multiple-testing-opportunity"><span class="header-section-number">8.0.4</span> 6.1.4 The multiple testing opportunity</a></li>
  <li><a href="#an-example-coin-tossing" id="toc-an-example-coin-tossing" class="nav-link" data-scroll-target="#an-example-coin-tossing"><span class="header-section-number">8.1</span> 6.2 An example: coin tossing</a></li>
  <li><a href="#the-five-steps-of-hypothesis-testing" id="toc-the-five-steps-of-hypothesis-testing" class="nav-link" data-scroll-target="#the-five-steps-of-hypothesis-testing"><span class="header-section-number">8.2</span> 6.3 The five steps of hypothesis testing</a>
  <ul class="collapse">
  <li><a href="#the-rejection-region" id="toc-the-rejection-region" class="nav-link" data-scroll-target="#the-rejection-region"><span class="header-section-number">8.2.1</span> 6.3.1 The rejection region</a></li>
  </ul></li>
  <li><a href="#types-of-error" id="toc-types-of-error" class="nav-link" data-scroll-target="#types-of-error"><span class="header-section-number">8.3</span> 6.4 Types of error</a></li>
  <li><a href="#the-t-test" id="toc-the-t-test" class="nav-link" data-scroll-target="#the-t-test"><span class="header-section-number">8.4</span> 6.5 The t-test</a>
  <ul class="collapse">
  <li><a href="#permutation-tests" id="toc-permutation-tests" class="nav-link" data-scroll-target="#permutation-tests"><span class="header-section-number">8.4.1</span> 6.5.1 Permutation tests</a></li>
  </ul></li>
  <li><a href="#p-value-hacking" id="toc-p-value-hacking" class="nav-link" data-scroll-target="#p-value-hacking"><span class="header-section-number">8.5</span> 6.6 P-value hacking</a></li>
  <li><a href="#multiple-testing" id="toc-multiple-testing" class="nav-link" data-scroll-target="#multiple-testing"><span class="header-section-number">8.6</span> 6.7 Multiple testing</a></li>
  <li><a href="#the-family-wise-error-rate" id="toc-the-family-wise-error-rate" class="nav-link" data-scroll-target="#the-family-wise-error-rate"><span class="header-section-number">8.7</span> 6.8 The family wise error rate</a>
  <ul class="collapse">
  <li><a href="#bonferroni-method" id="toc-bonferroni-method" class="nav-link" data-scroll-target="#bonferroni-method"><span class="header-section-number">8.7.1</span> 6.8.1 Bonferroni method</a></li>
  </ul></li>
  <li><a href="#the-false-discovery-rate" id="toc-the-false-discovery-rate" class="nav-link" data-scroll-target="#the-false-discovery-rate"><span class="header-section-number">8.8</span> 6.9 The false discovery rate</a>
  <ul class="collapse">
  <li><a href="#the-p-value-histogram" id="toc-the-p-value-histogram" class="nav-link" data-scroll-target="#the-p-value-histogram"><span class="header-section-number">8.8.1</span> 6.9.1 The p-value histogram</a></li>
  <li><a href="#the-benjamini-hochberg-algorithm-for-controlling-the-fdr" id="toc-the-benjamini-hochberg-algorithm-for-controlling-the-fdr" class="nav-link" data-scroll-target="#the-benjamini-hochberg-algorithm-for-controlling-the-fdr"><span class="header-section-number">8.8.2</span> 6.9.2 The Benjamini-Hochberg algorithm for controlling the FDR</a></li>
  </ul></li>
  <li><a href="#the-local-fdr" id="toc-the-local-fdr" class="nav-link" data-scroll-target="#the-local-fdr"><span class="header-section-number">8.9</span> 6.10 The local FDR</a>
  <ul class="collapse">
  <li><a href="#local-versus-total" id="toc-local-versus-total" class="nav-link" data-scroll-target="#local-versus-total"><span class="header-section-number">8.9.1</span> 6.10.1 Local versus total</a></li>
  <li><a href="#terminology" id="toc-terminology" class="nav-link" data-scroll-target="#terminology"><span class="header-section-number">8.9.2</span> 6.10.2 Terminology</a></li>
  </ul></li>
  <li><a href="#independent-hypothesis-weighting" id="toc-independent-hypothesis-weighting" class="nav-link" data-scroll-target="#independent-hypothesis-weighting"><span class="header-section-number">8.10</span> 6.11 Independent hypothesis weighting</a></li>
  <li><a href="#summary-of-this-chapter" id="toc-summary-of-this-chapter" class="nav-link" data-scroll-target="#summary-of-this-chapter"><span class="header-section-number">8.11</span> 6.12 Summary of this chapter</a></li>
  <li><a href="#further-reading" id="toc-further-reading" class="nav-link" data-scroll-target="#further-reading"><span class="header-section-number">8.12</span> 6.13 Further reading</a></li>
  <li><a href="#exercises" id="toc-exercises" class="nav-link" data-scroll-target="#exercises"><span class="header-section-number">8.13</span> 6.14 Exercises</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">6.1 Goals for this Chapter</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p><a href="imgs/xkcdmulttest- newspapertitle.png"><img src="imgs/xkcdmulttest-newspapertitle.png" class="img-fluid"></a></p>
<p>Hypothesis testing is one of the workhorses of science. It is how we can draw conclusions or make decisions based on finite samples of data. For instance, new treatments for a disease are usually approved on the basis of clinical trials that aim to decide whether the treatment has better efficacy compared to the other available options, and an acceptable trade-off of side effects. Such trials are expensive and can take a long time. Therefore, the number of patients we can enroll is limited, and we need to base our inference on a limited sample of observed patient responses. The data are noisy, since a patient’s response depends not only on the treatment, but on many other factors outside of our control. The sample size needs to be large enough to enable us to make a reliable conclusion. On the other hand, it also must not be too large, so that we do not waste precious resources or time, e.g., by making drugs more expensive than necessary, or by denying patients that would benefit from the new drug access to it. The machinery of hypothesis testing was developed largely with such applications in mind, although today it is used much more widely.</p>
<p>In biological data analysis (and in many other fields1) we see hypothesis testing applied to screen thousands or millions of possible hypotheses to find the ones that are worth following up. For instance, researchers screen genetic variants for associations with a phenotype, or gene expression levels for associations with disease. Here, “worthwhile” is often interpreted as “statistically significant”, although the two concepts are clearly not the same. It is probably fair to say that statistical significance is a necessary condition for making a data-driven decision to find something interesting, but it’s clearly not sufficient. In any case, such large-scale association screening is closely related to multiple hypothesis testing.</p>
<p>1 Detecting credit card fraud, email spam detection, \(…\)</p>
<p>In this chapter we will:</p>
<ul>
<li><p>Familiarize ourselves with the statistical machinery of hypothesis testing, its vocabulary, its purpose, and its strengths and limitations.</p></li>
<li><p>Understand what multiple testing means.</p></li>
<li><p>See that multiple testing is not a problem – but rather, an opportunity, as it overcomes many of the limitations of single testing.</p></li>
<li><p>Understand the false discovery rate.</p></li>
<li><p>Learn how to make diagnostic plots.</p></li>
<li><p>Use hypothesis weighting to increase the power of our analyses.</p></li>
</ul>
<section id="drinking-from-the-firehose" class="level3" data-number="8.0.1">
<h3 data-number="8.0.1" class="anchored" data-anchor-id="drinking-from-the-firehose"><span class="header-section-number">8.0.1</span> 6.1.1 Drinking from the firehose</h3>
<p><a href="imgs/active- substance-discovery-robot-screening-robot.jpg" title="Figure 6.1: High-throughput data in modern biology are screened for associations with millions of hypothesis tests. (Source: Bayer)"><img src="imgs/active-substance-discovery-robot-screening-robot.jpg" class="img-fluid"></a></p>
<p>Figure 6.1: High-throughput data in modern biology are screened for associations with millions of hypothesis tests. (<a href="https://www.research.bayer.com/en/automated-search-for-active-%20ingredients-with-robots.aspx">Source: Bayer</a>)</p>
<p>If statistical testing—decision making with uncertainty—seems a hard task when making a single decision, then brace yourself: in genomics, or more generally with “big data”, we need to accomplish it not once, but thousands or millions of times. In <a href="02-chap.html">Chapter 2</a>, we saw the example of epitope detection and the challenges from considering not only one, but several positions. Similarly, in whole genome sequencing, we scan every position in the genome for evidence of a difference in the DNA sequencing data at hand and a reference sequence (or, another set of sequencing data): that’s in the order of six billion tests if we are looking at human data! In genetic or chemical compound screening, we test each of the reagents for an effect in the assay, compared to a control: that’s again tens of thousands, if not millions of tests. In <a href="08-chap.html">Chapter 8</a>, we will analyse RNA-Seq data for differential expression by applying a hypothesis test to each of the thousands of genes assayed.</p>
</section>
<section id="testing-versus-classification" class="level3" data-number="8.0.2">
<h3 data-number="8.0.2" class="anchored" data-anchor-id="testing-versus-classification"><span class="header-section-number">8.0.2</span> 6.1.2 Testing versus classification</h3>
<p>Suppose we measured the abundance level of a marker molecule to decide whether some cells we are studying are in cell state A or B. First, let’s consider that we have no prior assumption, and that we just want to use the data to make a more or less symmetric choice between the two outcomes. This is a <em>classification</em> task. We’ll cover classification in <a href="12-chap.html">Chapter 12</a>. In this chapter, we consider the asymmetric case: based on what we already know (we could call this our <em>prior</em> knowledge), cell state A is predominant, the “default”. We’ll only call B if there is strong enough evidence for it. Maybe B is rare, unusual, interesting, and if we find it, we are going to commit resources to study it further. Whereas A is uninteresting and demands no futher follow-up. In such cases, the machinery of hypothesis testing is for us.</p>
<p>Formally, there are many similarities between hypothesis testing and classification. In both cases, we aim to use data to choose between several possible decisions. The distinction can be a fuzzy, and it is even possible to think of hypothesis testing as a special case of classification. However, these two approaches are geared towards different objectives and underlying assumptions. When you encounter a statistical decision problem, it can be useful to check which approach is more appropriate.</p>
</section>
<section id="false-discovery-rate-or-p-value" class="level3" data-number="8.0.3">
<h3 data-number="8.0.3" class="anchored" data-anchor-id="false-discovery-rate-or-p-value"><span class="header-section-number">8.0.3</span> 6.1.3 False discovery rate or p-value?</h3>
<p><a href="06-chap_files/figure-html/fig-testing- FDRvspstatic1-1.png" title="Figure 6.2: Making a binary (yes/no) decision. Here, we call the two possible decisions “positive” and “negative” based on some continuous-valued score x, shown along the x-axis. The curve shaded in blue shows the distribution density of x for one of the classes (the negatives), the curve shaded in red, for the other class (the positives). The distributions are distinctive (the red values are generally lower), but have some overlap. The vertical black bar marks some choice of a decision boundary, which results in four possible outcomes highlighted by the color key."><img src="06-chap_files/figure-html/fig-testing- FDRvspstatic1-1.png" class="img-fluid"></a></p>
<p>Figure 6.2: Making a binary (yes/no) decision. Here, we call the two possible decisions “positive” and “negative” based on some continuous-valued score \(x\), shown along the \(x\)-axis. The curve shaded in blue shows the distribution density of \(x\) for one of the classes (the negatives), the curve shaded in red, for the other class (the positives). The distributions are distinctive (the red values are generally lower), but have some overlap. The vertical black bar marks some choice of a decision boundary, which results in four possible outcomes highlighted by the color key.</p>
<p><a href="06-chap_files/figure-html/fig-testing- FDRvspstatic2-1.png" title="Figure 6.3: Analogous to Figure fig-testing- FDRvspstatic1, but now we have transformed x from its original range to the range [0,1] using a non-linear, strictly increasing transformation function p=f(x), which we chose such that the resulting blue distribution is uniform. Such a function always exists: it is the cumulative distribution function of x (we have seen it in sec-graphics-ecdf). We call the result a p-value. The definition of the FDR in Equation eq-testing-simplefdr applies equally well in Figure fig-testing-FDRvspstatic1 and here."><img src="06-chap_files/figure-html/fig-testing- FDRvspstatic2-1.png" class="img-fluid"></a></p>
<p>Figure 6.3: Analogous to Figure 6.2, but now we have transformed \(x\) from its original range to the range \([0,1]\) using a non-linear, strictly increasing transformation function \(p=f(x)\), which we chose such that the resulting blue distribution is uniform. Such a function always exists: it is the cumulative distribution function of \(x\) (we have seen it in <a href="03-chap.html#sec-graphics-ecdf">Section 3.6.7</a>). We call the result a <strong>p-value</strong>. The definition of the FDR in Equation 6.2 applies equally well in Figure 6.2 and here.</p>
<p><a href="06-chap_files/figure-html/fig-testing-FDRvspanim-1.gif &quot;Figure 6.4: The animation highlights the analogies between using a generic score x (as in Figure fig-testing-FDRvspstatic1) and a p-value from a formal hypothesis test (as in Figure fig-testing-FDRvspstatic2) for decision making. We will come back to these concepts in terms of the two-group model in sec-testing-localfdr and Figure fig-testing-lfdr.&quot;"><img src="06-chap_files/figure-html/fig-testing- FDRvspanim-1.gif" class="img-fluid"></a></p>
<p>Figure 6.4: The animation highlights the analogies between using a generic score \(x\) (as in Figure 6.2) and a p-value from a formal hypothesis test (as in Figure 6.3) for decision making. We will come back to these concepts in terms of the two-group model in Section 6.10 and Figure 6.17.</p>
<p>Hypothesis testing has traditionally been taught with p-values first, introducing them as the primal, basic concept. Multiple testing and false discovery rates were then presented as derived, additional ideas. There are good mathematical and practical reasons for doing so, and the rest of this chapter follows this tradition. However, in this prefacing section we would like to point out that the false discovery rate is in fact the more intuitive concept, and that it also tends to be more useful in practice. A p-value is something more abstract, and it is often not quite clear what to do with it, and thus keeps confusing those who want to use it for decision making. So here is an attempt to be more pedagogical, revert the order, and learn about false discovery rates first. We can then think of p-values as something second-best, which we have to resort to if the false discovery rate is not accessible.</p>
<p>Consider Figure 6.2, which represents a binary decision problem. Let’s say we call a <em>discovery</em> whenever the summary statistic \(x\) is particularly small, i.e., when it falls to the left of the vertical black bar2. Then the <em>false discovery rate</em> 3 (FDR) is simply the fraction of false discoveries among all discoveries, i.e.:</p>
<p>2 This is “without loss of generality”: we could also flip the \(x\)-axis and call something with a high score a discovery.</p>
<p>3 This is a rather informal definition. For more precise definitions, see for instance (<a href="16-chap.html#ref-Storey:AnnStat:2003">Storey 2003</a>; <a href="16-chap.html#ref-Efron2010">Efron 2010</a>) and Section 6.10.</p>
<p>\[ =. \]</p>
<p>The FDR depends not only on the position of the decision threshold (the vertical bar), but also on the shape and location of the two distributions, and on their relative sizes. In Figures 6.2 and 6.3, the overall blue area is twice as big as the overall red area, reflecting the fact that the blue class is (in this example) twice as prevalent (or: a priori, twice as likely) as the red class.</p>
<p>Note that this definition does not require the concept or even the calculation of a p-value. It works for any arbitrarily defined score \(x\). However, it requires knowledge of three things:</p>
<ol type="1">
<li><p>the distribution of \(x\) in the blue class (the blue curve),</p></li>
<li><p>the distribution of \(x\) in the red class (the red curve),</p></li>
<li><p>the relative sizes of the blue and the red classes.</p></li>
</ol>
<p>If we know these, then we are basically done at this point; or we can move on to supervised classification in <a href="12-chap.html">Chapter 12</a>, which deals with the extension of Figure 6.2 to multivariate \(x\).</p>
<p>Very often, however, we do not know all of these, and this is the realm of hypothesis testing. In particular, suppose that one of the two classes (say, the blue one) is easier than the other, and we can figure out its distribution, either from first principles or simulations. We use that fact to transform our score \(x\) to a standardized range between 0 and 1 (see Figures 6.2—6.4), which we call the <em>p-value</em>. We give the class a fancier name: <em>null hypothesis</em>. This addresses Point 1 in the above list. We do not insist on knowing Point 2 (and we give another fancy name, <em>alternative hypothesis</em> , to the red class). As for Point 3, we can use the conservative upper limit that the null hypothesis is far more prevalent (or: likely) than the alternative and do our calculations under the condition that the null hypothesis is true. This is the traditional approach to hypothesis testing.</p>
<p>Thus, instead of basing our decision-making on the intuitive FDR (Equation 6.2), we base it on the</p>
<p>\[ =. \]</p>
<p>In other words, the p-value is the precise and often relatively easy-to- compute answer to a rather convoluted question (and perhaps the wrong question). The FDR answers the right question, but requires a lot more input, which we often do not have.</p>
</section>
<section id="the-multiple-testing-opportunity" class="level3" data-number="8.0.4">
<h3 data-number="8.0.4" class="anchored" data-anchor-id="the-multiple-testing-opportunity"><span class="header-section-number">8.0.4</span> 6.1.4 The multiple testing opportunity</h3>
<p>Here is the good news about multiple testing: even if we do not know Items 2 and 3 from the bullet list above explicitly for our tests (and perhaps even if we are unsure about Point 1 (<a href="16-chap.html#ref-Efron2010">Efron 2010</a>)), we may be able to infer this information from the multiplicity—and thus convert p-values into estimates of the FDR!</p>
<p>Thus, multiple testing tends to make our inference better, and our task simpler. Since we have so much data, we do not only have to rely on abstract assumptions. We can check empirically whether the requirements of the tests are actually met by the data. All this can be incredibly helpful, and we get it <em>because</em> of the multiplicity. So we should think about multiple testing not as a “problem” or a “burden”, but as an opportunity!</p>
</section>
<section id="an-example-coin-tossing" class="level2" data-number="8.1">
<h2 data-number="8.1" class="anchored" data-anchor-id="an-example-coin-tossing"><span class="header-section-number">8.1</span> 6.2 An example: coin tossing</h2>
<p>So now let’s dive into hypothesis testing, starting with single testing. To really understand the mechanics, we use one of the simplest possible examples: suppose we are flipping a coin to see if it is fair4. We flip the coin 100 times and each time record whether it came up heads or tails. So, we have a record that could look something like this:</p>
<p>4 We don’t look at coin tossing because it’s inherently important, but because it is an easy “model system” (just as we use model systems in biology): everything can be calculated easily, and you do not need a lot of domain knowledge to understand what coin tossing is. All the important concepts come up, and we can apply them, only with more additional details, to other applications.</p>
<p>HHTTHTHTT…</p>
<p>which we can simulate in R. Let’s assume we are flipping a biased coin, so we set <code>probHead</code> different from 1/2:</p>
<pre><code>set.seed(0xdada)
numFlips = 100
probHead = 0.6
coinFlips = sample(c("H", "T"), size = numFlips,
  replace = TRUE, prob = c(probHead, 1 - probHead))
head(coinFlips)__


[1] "T" "T" "H" "T" "H" "H"</code></pre>
<p>Now, if the coin were fair, we would expect half of the time to get heads. Let’s see.</p>
<pre><code>table(coinFlips)__


coinFlips
 H  T 
59 41 </code></pre>
<p>So that is different from 50/50. Suppose we showed the data to a friend without telling them whether the coin is fair, and their prior assumption, i.e., their null hypothesis, is that coins are, by and large, fair. Would the data be strong enough to make them conclude that this coin isn’t fair? They know that random sampling differences are to be expected. To decide, let’s look at the sampling distribution of our test statistic – the total number of heads seen in 100 coin tosses – for a fair coin5. As we saw in <a href="01-chap.html">Chapter 1</a>, the number, \(k\), of heads, in \(n\) independent tosses of a coin is</p>
<p>5 We haven’t really defined what we mean be fair – a reasonable definition would be that head and tail are equally likely, and that the outcome of each coin toss does not depend on the previous ones. For more complex applications, nailing down the most suitable null hypothesis can take some thought.</p>
<p>\[ P(K=k,|,n, p) = (]</p>
<p>where \(p\) is the probability of heads (0.5 if we assume a fair coin). We read the left hand side of the above equation as “the probability that the observed value for \(K\) is \(k\), given the values of \(n\) and \(p\)”. Statisticians like to make a difference between all the possible values of a statistic and the one that was observed6, and we use the upper case \(K\) for the possible values (so \(K\) can be anything between 0 and 100), and the lower case \(k\) for the observed value.</p>
<p>6 In other words, \(K\) is the abstract random variable in our probabilistic model, whereas \(k\) is its realization, that is, a specific data point.</p>
<p>We plot Equation 6.3 in Figure 6.5; for good measure, we also mark the observed value <code>numHeads</code> with a vertical blue line.</p>
<pre><code>library("dplyr")
k = 0:numFlips
numHeads = sum(coinFlips == "H")
binomDensity = tibble(k = k,
     p = dbinom(k, size = numFlips, prob = 0.5))__


library("ggplot2")
ggplot(binomDensity) +
  geom_bar(aes(x = k, y = p), stat = "identity") +
  geom_vline(xintercept = numHeads, col = "blue")__</code></pre>
<p><a href="06-chap_files/figure-html/fig-testing-dbinom-1.png" title="Figure 6.5: The binomial distribution for the parameters n=100 and p=0.5, according to Equation eq-testing-dbinom."><img src="06-chap_files/figure-html/fig-testing- dbinom-1.png" class="img-fluid"></a></p>
<p>Figure 6.5: The binomial distribution for the parameters \(n=100\) and \(p=0.5\), according to Equation 6.3.</p>
<p>Suppose we didn’t know about Equation 6.3. We can still use Monte Carlo simulation to give us something to compare with:</p>
<pre><code>numSimulations = 10000
outcome = replicate(numSimulations, {
  coinFlips = sample(c("H", "T"), size = numFlips,
                     replace = TRUE, prob = c(0.5, 0.5))
  sum(coinFlips == "H")
})
ggplot(tibble(outcome)) + xlim(-0.5, 100.5) +
  geom_histogram(aes(x = outcome), binwidth = 1, center = 50) +
  geom_vline(xintercept = numHeads, col = "blue")__</code></pre>
<p><a href="06-chap_files/figure- html/fig-rbinom-1.png" title="Figure 6.6: An approximation of the binomial distribution from 10000 simulations (same parameters as Figure fig-testing- dbinom)."><img src="06-chap_files/figure-html/fig-rbinom-1.png" class="img-fluid"></a></p>
<p>Figure 6.6: An approximation of the binomial distribution from \(10000\) simulations (same parameters as Figure 6.5).</p>
<p>As expected, the most likely number of heads is 50, that is, half the number of coin flips. But we see that other numbers near 50 are also quite likely. How do we quantify whether the observed value, 59, is among those values that we are likely to see from a fair coin, or whether its deviation from the expected value is already large enough for us to conclude with enough confidence that the coin is biased? We divide the set of all possible \(k\) (0 to 100) in two complementary subsets, the <strong>rejection region</strong> and the region of no rejection. Our choice here7 is to fill up the rejection region with as many \(k\) as possible while keeping their total probability, assuming the null hypothesis, below some threshold \(\) (say, 0.05).</p>
<p>7 More on this in Section 6.3.1.</p>
<p>In the code below, we use the function <code>arrange</code> from the <strong><a href="https://cran.r-project.org/web/packages/dplyr/">dplyr</a></strong> package to sort the p-values from lowest to highest, then pass the result to <code>mutate</code>, which adds another dataframe column <code>reject</code> that is defined by computing the cumulative sum (<code>cumsum</code>) of the p-values and thresholding it against <code>alpha</code>. The logical vector <code>reject</code> therefore marks with <code>TRUE</code> a set of <code>k</code>s whose total probability is less than <code>alpha</code>. These are marked in Figure 6.7, and we can see that our rejection region is not contiguous – it comprises both the very large and the very small values of <code>k</code>.</p>
<pre><code>library("dplyr")
alpha = 0.05
binomDensity = arrange(binomDensity, p) |&gt;
        mutate(reject = (cumsum(p) &lt;= alpha))

ggplot(binomDensity) +
  geom_bar(aes(x = k, y = p, col = reject), stat = "identity") +
  scale_colour_manual(
    values = c(`TRUE` = "red", `FALSE` = "darkgrey")) +
  geom_vline(xintercept = numHeads, col = "blue") +
  theme(legend.position = "none")__</code></pre>
<p><a href="06-chap_files/figure-html/fig-testing-findrej-1.png &quot;Figure 6.7: As Figure fig-testing-dbinom, with rejection region (red) that has been chosen such that it contains the maximum number of bins whose total area is at most \alpha=0.05.&quot;"><img src="06-chap_files/figure-html/fig-testing- findrej-1.png" class="img-fluid"></a></p>
<p>Figure 6.7: As Figure 6.5, with rejection region (red) that has been chosen such that it contains the maximum number of bins whose total area is at most \(\).</p>
<p>The explicit summation over the probabilities is clumsy, we did it here for pedagogic value. For one-dimensional distributions, R provides not only functions for the densities (e.g., <code>dbinom</code>) but also for the cumulative distribution functions (<code>pbinom</code>), which are more precise and faster than <code>cumsum</code> over the probabilities. These should be used in practice.</p>
<p>__</p>
<p>Task</p>
<p>Do the computations for the rejection region and produce a plot like Figure 6.7 without using <code>dbinom</code> and <code>cumsum</code>, and with using <code>pbinom</code> instead.</p>
<p>We see in Figure 6.7 that the observed value, 59, lies in the grey shaded area, so we would <em>not</em> reject the null hypothesis of a fair coin from these data at a significance level of \(\).</p>
<p>__</p>
<p>Question 6.1</p>
<p>Does the fact that we don’t reject the null hypothesis mean that the coin is fair?</p>
<p>__</p>
<p>Question 6.2</p>
<p>Would we have a better chance of detecting that the coin is not fair if we did more coin tosses? How many?</p>
<p>__</p>
<p>Question 6.3</p>
<p>If we repeated the whole procedure and again tossed the coin 100 times, might we <em>then</em> reject the null hypothesis?</p>
<p>__</p>
<p>Question 6.4</p>
<p>The rejection region in Figure 6.7 is asymmetric – its left part ends with \(k=40\), while its right part starts with \(k=61\). Why is that? Which other ways of defining the rejection region might be useful?</p>
<p>We have just gone through the steps of a binomial test. In fact, this is such a frequent activity in R that it has been wrapped into a single function, and we can compare its output to our results.</p>
<pre><code>binom.test(x = numHeads, n = numFlips, p = 0.5)__


    Exact binomial test

data:  numHeads and numFlips
number of successes = 59, number of trials = 100, p-value = 0.08863
alternative hypothesis: true probability of success is not equal to 0.5
95 percent confidence interval:
 0.4871442 0.6873800
sample estimates:
probability of success 
                  0.59 </code></pre>
</section>
<section id="the-five-steps-of-hypothesis-testing" class="level2" data-number="8.2">
<h2 data-number="8.2" class="anchored" data-anchor-id="the-five-steps-of-hypothesis-testing"><span class="header-section-number">8.2</span> 6.3 The five steps of hypothesis testing</h2>
<p>Let’s summarise the general principles of hypothesis testing:</p>
<ol type="1">
<li><p>Decide on the effect that you are interested in, design a suitable experiment or study, pick a data summary function and <strong>test statistic</strong>.</p></li>
<li><p>Set up a <strong>null hypothesis</strong> , which is a simple, computationally tractable model of reality that lets you compute the <strong>null distribution</strong> , i.e., the possible outcomes of the test statistic and their probabilities under the assumption that the null hypothesis is true.</p></li>
<li><p>Decide on the <strong>rejection region</strong> , i.e., a subset of possible outcomes whose total probability is small8.</p></li>
<li><p>Do the experiment and collect the data9; compute the test statistic.</p></li>
<li><p>Make a decision: reject the null hypothesis10 if the test statistic is in the rejection region.</p></li>
</ol>
<p>8 More on this in Section 6.3.1.</p>
<p>9 Or if someone else has already done it, download their data.</p>
<p>10 That is, conclude that it is unlikely to be true.</p>
<p>Note how in this idealized workflow, we make all the important decisions in Steps 1–3 before we have even seen the data. As we already alluded to in the Introduction (Figures <a href="00-chap.html#fig-Fisher">1</a> and <a href="00-chap.html#fig- iterative">2</a>), this is often not realistic. We will also come back to this question in Section 6.6.</p>
<p>There was also idealization in our null hypothesis that we used in the example above: we postulated that a fair coin should have a probability of exactly 0.5 (not, say, 0.500001) and that there should be absolutely no dependence between tosses. We did not worry about any possible effects of air drag, elasticity of the material on which the coin falls, and so on. This gave us the advantage that the null hypothesis was computationally tractable, namely, with the binomial distribution. Here, these idealizations may not seem very controversial, but in other situations the trade-off between how tractable and how realistic a null hypothesis is can be more substantial. The problem is that if a null hypothesis is too idealized to start with, rejecting it is not all that interesting. The result may be misleading, and certainly we are wasting our time.</p>
<p>The test statistic in our example was the total number of heads. Suppose we observed 50 tails in a row, and then 50 heads in a row. Our test statistic ignores the order of the outcomes, and we would conclude that this is a perfectly fair coin. However, if we used a different test statistic, say, the number of times we see two tails in a row, we might notice that there is something funny about this coin.</p>
<p>__</p>
<p>Question 6.5</p>
<p>What is the null distribution of this different test statistic?</p>
<p>__</p>
<p>Question 6.6</p>
<p>Would a test based on that statistic be generally preferable?</p>
<p>__</p>
<p>Solution</p>
<p>__</p>
<p>No, while it has more power to detect such correlations between coin tosses, it has <em>less</em> power to detect bias in the outcome.</p>
<p>What we have just done is look at two different classes of <strong>alternative hypotheses</strong>. The first class of alternatives was that subsequent coin tosses are still independent of each other, but that the probability of heads differed from 0.5. The second one was that the overall probability of heads may still be 0.5, but that subsequent coin tosses were correlated.</p>
<p>__</p>
<p>Question 6.7</p>
<p>Recall the concept of sufficient statistics from <a href="01-chap.html">Chapter 1</a>. Is the total number of heads a sufficient statistic for the binomial distribution? Why might it be a good test statistic for our first class of alternatives, but not for the second?</p>
<p>So let’s remember that we typically have multiple possible choices of test statistic (in principle it could be any numerical summary of the data). Making the right choice is important for getting a test with good power11. What the right choice is will depend on what kind of alternatives we expect. This is not always easy to know in advance.</p>
<p>11 See <a href="01-chap.html#sec-generative-SimulatingForPower">Section 1.4.1</a> and 6.4.</p>
<p>12 The assumptions don’t need to be <em>exactly</em> true – it is sufficient that the theory’s predictions are an acceptable approximation of the truth.</p>
<p>Once we have chosen the test statistic we need to compute its null distribution. You can do this either with pencil and paper or by computer simulations. A pencil and paper solution is parametric and leads to a closed form mathematical expression (like Equation 6.3), which has the advantage that it holds for a range of model parameters of the null hypothesis (such as \(n\), \(p\)). It can also be quickly computed for any specific set of parameters. But it is not always as easy as in the coin tossing example. Sometimes a pencil and paper solution is impossibly difficult to compute. At other times, it may require simplifying assumptions. An example is a null distribution for the \(t\)-statistic (which we will see later in this chapter). We can compute this if we assume that the data are independent and normally distributed: the result is called the \(t\)-distribution. Such modelling assumptions may be more or less realistic. Simulating the null distribution offers a potentially more accurate, more realistic and perhaps even more intuitive approach. The drawback of simulating is that it can take a rather long time, and we need extra work to get a systematic understanding of how varying parameters influence the result. Generally, it is more elegant to use the parametric theory when it applies12. When you are in doubt, simulate – or do both.</p>
<section id="the-rejection-region" class="level3" data-number="8.2.1">
<h3 data-number="8.2.1" class="anchored" data-anchor-id="the-rejection-region"><span class="header-section-number">8.2.1</span> 6.3.1 The rejection region</h3>
<p>How to choose the right rejection region for your test? First, what should its size be? That is your choice of the <strong>significance level</strong> or false positive rate \(\), which is the total probability of the test statistic falling into this region even if the null hypothesis is true13.</p>
<p>13 Some people at some point in time for a particular set of questions colluded on \(\) as being “small”. But there is nothing special about this number, and in any particular case the best choice for a decision threshold may very much depend on context (<a href="16-chap.html#ref-Wasserstein2016:ASA">Wasserstein and Lazar 2016</a>; <a href="16-chap.html#ref-Altman:PoS:2017">Altman and Krzywinski 2017</a>).</p>
<p>Given the size, the next question is about its shape. For any given size, there are usually multiple possible shapes. It makes sense to require that the probability of the test statistic falling into the rejection region is as large possible if the alternative hypothesis is true. In other words, we want our test to have high <strong>power</strong> , or true positive rate.</p>
<p>The criterion that we used in the code for computing the rejection region for Figure 6.7 was to make the region contain as many <code>k</code> as possible. That is because in absence of any information about the alternative distribution, one <code>k</code> is as good as any other, and we maximize their total number.</p>
<p>A consequence of this is that in Figure 6.7 the rejection region is split between the two tails of the distribution. This is because we anticipate that unfair coins could have a bias either towards head or toward tail; we don’t know. If we did know, we would instead concentrate our rejection region all on the appropriate side, e.g., the right tail if we think the bias would be towards head. Such choices are also referred to as <em>two-sided</em> and <em>one-sided</em> tests. More generally, if we have assumptions about the alternative distribution, this can influence our choice of the shape of the rejection region.</p>
</section>
</section>
<section id="types-of-error" class="level2" data-number="8.3">
<h2 data-number="8.3" class="anchored" data-anchor-id="types-of-error"><span class="header-section-number">8.3</span> 6.4 Types of error</h2>
<p>Having set out the mechanics of testing, we can assess how well we are doing. Table 6.1 compares reality (whether or not the null hypothesis is in fact true) with our decision whether or not to reject the null hypothesis after we have seen the data.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th>Test vs reality</th>
<th>Null hypothesis is true</th>
<th>\(…\) is false</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Reject null hypothesis</strong></td>
<td>Type I error (false positive)</td>
<td>True positive</td>
</tr>
<tr class="even">
<td><strong>Do not reject</strong></td>
<td>True negative</td>
<td>Type II error (false negative)</td>
</tr>
</tbody>
</table>
<p>Table 6.1: Types of error in a statistical test.</p>
<p>It is always possible to reduce one of the two error types at the cost of increasing the other one. The real challenge is to find an acceptable trade- off between both of them. This is exemplified in Figure 6.2. We can always decrease the <strong>false positive rate</strong> (FPR) by shifting the threshold to the right. We can become more “conservative”. But this happens at the price of higher <strong>false negative rate</strong> (FNR). Analogously, we can decrease the FNR by shifting the threshold to the left. But then again, this happens at the price of higher FPR. A bit on terminology: the FPR is the same as the probability \(\) that we mentioned above. \(1 - \) is also called the <strong>specificity</strong> of a test. The FNR is sometimes also called \(\), and \(1 - \) the <strong>power</strong> , <strong>sensitivity</strong> or <strong>true positive rate</strong> of a test.</p>
<p>__</p>
<p>Question 6.8</p>
<p>At the end of Section 6.3, we learned about one- and two-sided tests. Why does this distinction exist? Why don’t we always just use the two-sided test, which is sensitive to a larger class of alternatives?</p>
</section>
<section id="the-t-test" class="level2" data-number="8.4">
<h2 data-number="8.4" class="anchored" data-anchor-id="the-t-test"><span class="header-section-number">8.4</span> 6.5 The t-test</h2>
<p>Many experimental measurements are reported as rational numbers, and the simplest comparison we can make is between two groups, say, cells treated with a substance compared to cells that are not. The basic test for such situations is the \(t\)-test. The test statistic is defined as</p>
<p>\[ t = c ; , \]</p>
<p>where \(m_1\) and \(m_2\) are the mean of the values in the two groups, \(s\) is the pooled standard deviation and \(c\) is a constant that depends on the sample sizes, i.e., the numbers of observations \(n_1\) and \(n_2\) in the two groups. In formulas14,</p>
<p>14 Everyone should try to remember Equation 6.4, whereas many people get by with looking up Equation 6.5 when they need it.</p>
<p>\[ <span class="math display">\[\begin{align} m_g &amp;= \frac{1}{n_g} \sum_{i=1}^{n_g} x_{g, i}
\quad\quad\quad g=1,2\\\ s^2 &amp;= \frac{1}{n_1+n_2-2} \left( \sum_{i=1}^{n_1}
\left(x_{1,i} - m_1\right)^2 + \sum_{j=1}^{n_2} \left(x_{2,j} - m_2\right)^2
\right)\\\ c &amp;= \sqrt{\frac{n_1n_2}{n_1+n_2}} \end{align}\]</span> \]</p>
<p>where \(x_{g, i}\) is the \(i^{}\) data point in the \(g^{}\) group. Let’s try this out with the <code>PlantGrowth</code> data from R’s <strong>datasets</strong> package.</p>
<pre><code>library("ggbeeswarm")
data("PlantGrowth")
ggplot(PlantGrowth, aes(y = weight, x = group, col = group)) +
  geom_beeswarm() + theme(legend.position = "none")
tt = with(PlantGrowth, 
       t.test(weight[group =="ctrl"],
              weight[group =="trt2"],
              var.equal = TRUE))
tt __


    Two Sample t-test

data:  weight[group == "ctrl"] and weight[group == "trt2"]
t = -2.134, df = 18, p-value = 0.04685
alternative hypothesis: true difference in means is not equal to 0
95 percent confidence interval:
 -0.980338117 -0.007661883
sample estimates:
mean of x mean of y 
    5.032     5.526 </code></pre>
<p><a href="06-chap_files/figure-html/fig-testing-plantgrowth-1.png &quot;Figure 6.8: The PlantGrowth data.&quot;"><img src="06-chap_files/figure-html/fig-testing- plantgrowth-1.png" class="img-fluid"></a></p>
<p>Figure 6.8: The <code>PlantGrowth</code> data.</p>
<p>__</p>
<p>Question 6.9</p>
<p>What do you get from the comparison with <code>trt1</code>? What for <code>trt1</code> versus <code>trt2</code>?</p>
<p>To compute the p-value, the <code>t.test</code> function uses the asymptotic theory for the \(t\)-statistic Equation 6.4; this theory states that under the null hypothesis of equal means in both groups, the statistic follows a known, mathematical distribution, the so-called \(t\)-distribution with \(n_1+n_2-2\) degrees of freedom. The theory uses additional technical assumptions, namely that the data are independent and come from a normal distribution with the same standard deviation. We could be worried about these assumptions. Clearly they do not hold: weights are always positive, while the normal distribution extends over the whole real axis. The question is whether this deviation from the theoretical assumption makes a real difference. We can use a permutation test to figure this out (we will discuss the idea behind permutation tests in a bit more detail in Section 6.5.1).</p>
<p>__</p>
<p>Question 6.10</p>
<p>Plot the theoretical and simulated null distribution for the above \(t\)-test, in a similar fashion as in Figure 6.5 and Figure 6.6 for the coin flips.</p>
<p>__</p>
<p>Solution</p>
<p>__</p>
<pre><code>plgr = dplyr::filter(PlantGrowth, group %in% c("ctrl", "trt2"))

alpha  = 0.05
xrange = 5 * c(-1, 1)
deckel = function(x) ifelse(x &lt; xrange[1], xrange[1], ifelse(x &gt; xrange[2], xrange[2], x))

sim_null = tibble(
  t = replicate(10000, t.test(weight ~ sample(group), var.equal = TRUE, data = plgr)$statistic)
)
sim_thresh = quantile(sim_null$t, c(alpha/2, 1-alpha/2))
sim_null = mutate(sim_null, 
  t = deckel(t),        # avoid warnings about out of range data
  reject = ifelse(t &lt;= sim_thresh[1], "low", ifelse(t &gt; sim_thresh[2], "high", "none"))
) 

theo_thresh = qt(c(alpha/2, 1-alpha/2), df =  nrow(plgr) - 2)
theo_null = tibble(
  t = seq(-5, 5, by = 0.05),
  density = dt (x = t, df = nrow(plgr)  - 2),
  reject = ifelse(t &lt;= theo_thresh[1], "low", ifelse(t &gt; theo_thresh[2], "high", "none"))
)

p1 = ggplot(sim_null, aes(x = t, col = reject, fill = reject)) +
       geom_bar(stat = "bin", breaks = seq(-5, 5, by = 0.2)) 
p2 = ggplot(theo_null, aes(x = t, y = density, col = reject, fill = reject)) +
       geom_area() 

for (p in list(p1, p2))
  print(p + 
        geom_vline(xintercept = tt$statistic, col = "#101010") +
        scale_colour_manual(values = c(low = "blue", high = "red", none = "darkgrey")) +
        scale_fill_manual(values = c(low = "blue", high = "red", none = "darkgrey")) + 
        xlim(xrange) + theme(legend.position = "none"))__</code></pre>
<p><a href="06-chap_files/figure- html/fig-testing-tnull-1.png" title="Figure 6.9:"><img src="06-chap_files/figure-html/fig-testing-tnull-1.png" class="img-fluid"></a></p>
<p>Figure 6.9</p>
<p><a href="06-chap_files/figure- html/fig-testing-tnull-2.png" title="Figure 6.10:"><img src="06-chap_files/figure-html/fig-testing-tnull-2.png" class="img-fluid"></a></p>
<p>Figure 6.10</p>
<p>__</p>
<p>Question 6.11</p>
<p>Would the solution to the preceding question get simpler if we considered the absolute value of \(t\) instead of \(t\) itself?</p>
<p>__</p>
<p>Solution</p>
<p>__</p>
<p>Yes, if we are not interested in the sign of the difference, we can directly work on \((t)\), and have only a single rejection region instead of a lower and an upper one.</p>
<p>The \(t\)-test comes in multiple flavors, all of which can be chosen through parameters of the <code>t.test</code> function. What we did above is called a two-sided two-sample unpaired test with equal variance. <em>Two-sided</em> refers to the fact that we were open to reject the null hypothesis if the weight of the treated plants was either larger or smaller than that of the untreated ones.</p>
<p><em>Two-sample</em> 15 indicates that we compared the means of two groups to each other; another option is to compare the mean of one group against a given, fixed number.</p>
<p>15 It can be confusing that the term <em>sample</em> has a different meaning in statistics than in biology. In biology, a sample is a single specimen on which an assay is performed; in statistics, it is a set of measurements, e.g., the \(n_1\)-tuple \((x_{1,1},…,x_{1,n_1})\) in Equation 6.5, which can comprise several biological samples. In contexts where this double meaning might create confusion, we refer to the data from a single biological sample as an <em>observation</em>.</p>
<p><em>Unpaired</em> means that there was no direct 1:1 mapping between the measurements in the two groups. If, on the other hand, the data had been measured on the same plants before and after treatment, then a paired test would be more appropriate, as it looks at the change of weight within each plant, rather than their absolute weights.</p>
<p><em>Equal variance</em> refers to the way the statistic Equation 6.4 is calculated. That expression is most appropriate if the variances within each group are about the same. If they are very different, an alternative form (Welch’s \(t\)-test) and associated asymptotic theory exist.</p>
<p><strong>The independence assumption</strong>. Now let’s try something peculiar: duplicate the data.</p>
<pre><code>with(rbind(PlantGrowth, PlantGrowth),
       t.test(weight[group == "ctrl"],
              weight[group == "trt2"],
              var.equal = TRUE))__


    Two Sample t-test

data:  weight[group == "ctrl"] and weight[group == "trt2"]
t = -3.1007, df = 38, p-value = 0.003629
alternative hypothesis: true difference in means is not equal to 0
95 percent confidence interval:
 -0.8165284 -0.1714716
sample estimates:
mean of x mean of y 
    5.032     5.526 </code></pre>
<p>Note how the estimates of the group means (and thus, of the difference) are unchanged, but the p-value is now much smaller! We can conclude two things from this:</p>
<ul>
<li><p>The power of the \(t\)-test depends on the sample size. Even if the underlying biological differences are the same, a dataset with more observations tends to give more significant results16.</p></li>
<li><p>The assumption of independence between the measurements is really important. Blatant duplication of the same data is an extreme form of dependence, but to some extent the same thing happens if you mix up different levels of replication. For instance, suppose you had data from 8 plants, but measured the same thing twice on each plant (technical replicates), then pretending that these are now 16 independent measurements is wrong.</p></li>
</ul>
<p>16 You can also see this from the way the numbers \(n_1\) and \(n_2\) appear in Equation 6.5.</p>
<section id="permutation-tests" class="level3" data-number="8.4.1">
<h3 data-number="8.4.1" class="anchored" data-anchor-id="permutation-tests"><span class="header-section-number">8.4.1</span> 6.5.1 Permutation tests</h3>
<p>What happened above when we contrasted the outcome of the parametric \(t\)-test with that of the permutation test applied to the \(t\)-statistic? It’s important to realize that these are two different tests, and the similarity of their outcomes is desirable, but coincidental. In the parametric test, the null distribution of the \(t\)-statistic follows from the assumed null distribution of the data, a multivariate normal distribution with unit covariance in the \((n_1+n_2)\)-dimensional space \(^{n_1+n_2}\), and is continuous: the \(t\)-distribution. In contrast, the permutation distribution of our test statistic is discrete, as it is obtained from the finite set of \((n_1+n_2)!\) permutations17 of the observation labels, from a single instance of the data (the \(n_1+n_2\) observations). All we assume here is that under the null hypothesis, the variables \(X_{1,1},…,X_{1,n_1},X_{2,1},…,X_{2,n_2}\) are exchangeable. Logically, this assumption is implied by that of the parametric test, but is weaker. The permutation test employs the \(t\)-statistic, but not the \(t\)-distribution (nor the normal distribution). The fact that the two tests gave us a very similar result is a consequence of the Central Limit Theorem.</p>
<p>17 Or a random subset, in case we want to save computation time.</p>
</section>
</section>
<section id="p-value-hacking" class="level2" data-number="8.5">
<h2 data-number="8.5" class="anchored" data-anchor-id="p-value-hacking"><span class="header-section-number">8.5</span> 6.6 P-value hacking</h2>
<p>Let’s go back to the coin tossing example. We did not reject the null hypothesis (that the coin is fair) at a level of 5%—even though we “knew” that it is unfair. After all, <code>probHead</code> was chosen as 0.6 in Section 6.2. Let’s suppose we now start looking at different test statistics. Perhaps the number of consecutive series of 3 or more heads. Or the number of heads in the first 50 coin flips. And so on. At some point we will find a test that happens to result in a small p-value, even if just by chance (after all, the probability for the p-value to be less than 0.05 under the null hypothesis—fair coin—is one in twenty). We just did what is called <strong>p-value hacking</strong> 18 (<a href="16-chap.html#ref-Head:PLoSBiol:2015:pvaluehacking">Head et al.&nbsp;2015</a>). You see what the problem is: in our zeal to prove our point we tortured the data until some statistic did what we wanted. A related tactic is <strong>hypothesis switching</strong> or <strong>HARKing</strong> – hypothesizing after the results are known: we have a dataset, maybe we have invested a lot of time and money into assembling it, so we need results. We come up with lots of different null hypotheses and test statistics, test them, and iterate, until we can report something.</p>
<p>18 <a href="http://fivethirtyeight.com/features/science-isnt-broken" class="uri">http://fivethirtyeight.com/features/science-isnt-broken</a></p>
<p>These tactics violate the rules of hypothesis testing, as described in Section 6.3, where we laid out one sequential procedure of choosing the hypothesis and the test, and then collecting the data. But, as we saw in <a href="02-chap.html">Chapter 2</a>, such tactics can be tempting in reality. With biological data, we tend to have so many different choices for “normalising” the data, transforming the data, trying to adjust for batch effects, removing outliers, …. The topic is complex and open-ended. Wasserstein and Lazar (<a href="16-chap.html#ref-Wasserstein2016:ASA">2016</a>) give a readable short summary of the problems with how p-values are used in science, and of some of the misconceptions. They also highlight how p-values can be fruitfully used. The essential message is: be completely transparent about your data, what analyses were tried, and how they were done. Provide the analysis code. Only with such contextual information can a p-value be useful.</p>
<p><strong>Avoid fallacy</strong>. Keep in mind that our statistical test is never attempting to prove our null hypothesis is true - we are simply saying whether or not there is evidence for it to be false. If a high p-value <em>were</em> indicative of the truth of the null hypothesis, we could formulate a completely crazy null hypothesis, do an utterly irrelevant experiment, collect a small amount of inconclusive data, find a p-value that would just be a random number between 0 and 1 (and so with some high probability above our threshold \(\)) and, whoosh, our hypothesis would be demonstrated!</p>
</section>
<section id="multiple-testing" class="level2" data-number="8.6">
<h2 data-number="8.6" class="anchored" data-anchor-id="multiple-testing"><span class="header-section-number">8.6</span> 6.7 Multiple testing</h2>
<p>__</p>
<p>Question 6.12</p>
<p>Look up <a href="http://xkcd.com/882">xkcd cartoon 882</a>. Why didn’t the newspaper report the results for the other colors?</p>
<p>The quandary illustrated in the cartoon occurs with high-throughput data in biology. And with force! You will be dealing not only with 20 colors of jellybeans, but, say, with 20,000 genes that were tested for differential expression between two conditions, or with 6 billion positions in the genome where a DNA mutation might have happened. So how do we deal with this? Let’s look again at our table relating statistical test results with reality (Table 6.1), this time framing everything in terms of many hypotheses.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th>Test vs reality</th>
<th>Null hypothesis is true</th>
<th>\(…\) is false</th>
<th>Total</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Rejected</strong></td>
<td>\(V\)</td>
<td>\(S\)</td>
<td>\(R\)</td>
</tr>
<tr class="even">
<td><strong>Not rejected</strong></td>
<td>\(U\)</td>
<td>\(T\)</td>
<td>\(m-R\)</td>
</tr>
<tr class="odd">
<td><strong>Total</strong></td>
<td>\(m_0\)</td>
<td>\(m-m_0\)</td>
<td>\(m\)</td>
</tr>
</tbody>
</table>
<p>Table 6.2: Types of error in multiple testing. The letters designate the number of times each type of error occurs.</p>
<ul>
<li><p>\(m\): total number of tests (and null hypotheses)</p></li>
<li><p>\(m_0\): number of true null hypotheses</p></li>
<li><p>\(m-m_0\): number of false null hypotheses</p></li>
<li><p>\(V\): number of false positives (a measure of type I error)</p></li>
<li><p>\(T\): number of false negatives (a measure of type II error)</p></li>
<li><p>\(S\), \(U\): number of true positives and true negatives</p></li>
<li><p>\(R\): number of rejections</p></li>
</ul>
<p>In the rest of this chapter, we look at different ways of taking care of the type I and II errors.</p>
</section>
<section id="the-family-wise-error-rate" class="level2" data-number="8.7">
<h2 data-number="8.7" class="anchored" data-anchor-id="the-family-wise-error-rate"><span class="header-section-number">8.7</span> 6.8 The family wise error rate</h2>
<p>The <strong>family wise error rate</strong> (FWER) is the probability that \(V&gt;0\), i.e., that we make one or more false positive errors. We can compute it as the complement of making no false positive errors at all19.</p>
<p>19 Assuming independence.</p>
<p>\[ <span class="math display">\[\begin{align} P(V&gt;0) &amp;= 1 - P(\text{no rejection of any of $m_0$ nulls})
\\\ &amp;= 1 - (1 - \alpha)^{m_0} \to 1 \quad\text{as } m_0\to\infty. \end{align}\]</span> \]</p>
<p>For any fixed \(\), this probability is appreciable as soon as \(m_0\) is in the order of \(1/\), and it tends towards 1 as \(m_0\) becomes larger. This relationship can have serious consequences for experiments like DNA matching, where a large database of potential matches is searched. For example, if there is a one in a million chance that the DNA profiles of two people match by random error, and your DNA is tested against a database of 800000 profiles, then the probability of a random hit with the database (i.e., without you being in it) is:</p>
<pre><code>1 - (1 - 1/1e6)^8e5 __


[1] 0.5506712</code></pre>
<p>That’s pretty high. And once the database contains a few million profiles more, a false hit is virtually unavoidable.</p>
<p>__</p>
<p>Question 6.13</p>
<p>Prove that the probability Equation 6.6 does indeed become very close to 1 when \(m_0\) is large.</p>
<section id="bonferroni-method" class="level3" data-number="8.7.1">
<h3 data-number="8.7.1" class="anchored" data-anchor-id="bonferroni-method"><span class="header-section-number">8.7.1</span> 6.8.1 Bonferroni method</h3>
<p>How are we to choose the per-hypothesis \(\) if we want FWER control? The above computations suggest that the product of \(\) with \(m_0\) may be a reasonable ballpark estimate. Usually we don’t know \(m_0\), but we know \(m\), which is an upper limit for \(m_0\), since \(m_0m\). The Bonferroni method is simply that if we want FWER control at level \(<em>{}\), we should choose the per hypothesis threshold \(= </em>{}/m\). Let’s check this out on an example.</p>
<pre><code>m = 10000
ggplot(tibble(
  alpha = seq(0, 7e-6, length.out = 100),
  p     = 1 - (1 - alpha)^m),
  aes(x = alpha, y = p)) +  geom_line() +
  xlab(expression(alpha)) +
  ylab("Prob( no false rejection )") +
  geom_hline(yintercept = 0.05, col = "red")__</code></pre>
<p><a href="06-chap_files/figure-html/fig-testing-bonferroni-1.png &quot;Figure 6.11: Bonferroni method. The plot shows the graph of eq-testing- bonferroni for m=10000 as a function of \alpha.&quot;"><img src="06-chap_files/figure-html/fig-testing- bonferroni-1.png" class="img-fluid"></a></p>
<p>Figure 6.11: Bonferroni method. The plot shows the graph of 6.6 for \(m=10000\) as a function of \(\).</p>
<p>In Figure 6.11, the black line intersects the red line (which corresponds to a value of 0.05) at \(^{-6}\), which is just a little bit more than the value of \(0.05/m\) implied by the Bonferroni method.</p>
<p>__</p>
<p>Question 6.14</p>
<p>Why are the two values not exactly the same?</p>
<p>A potential drawback of this method, however, is that if \(m_0\) is large, the rejection threshold is very small. This means that the individual tests need to be very powerful if we want to have any chance of detecting something. Often FWER control is too stringent, and would lead to an ineffective use of the time and money that was spent to generate and assemble the data. We will now see that there are more nuanced methods of controlling our type I error.</p>
</section>
</section>
<section id="the-false-discovery-rate" class="level2" data-number="8.8">
<h2 data-number="8.8" class="anchored" data-anchor-id="the-false-discovery-rate"><span class="header-section-number">8.8</span> 6.9 The false discovery rate</h2>
<p>Let’s look at some data. We load up the RNA-Seq dataset <code>airway</code>, which contains gene expression measurements (gene-level counts) of four primary human airway smooth muscle cell lines with and without treatment with dexamethasone, a synthetic glucocorticoid. We’ll use the <strong><a href="https://bioconductor.org/packages/DESeq2/">DESeq2</a></strong> method that we’ll discuss in more detail in <a href="08-chap.html">Chapter 8</a> For now it suffices to say that it performs a test for differential expression for each gene. Conceptually, the tested null hypothesis is similar to that of the \(t\)-test, although the details are slightly more involved since we are dealing with count data.</p>
<pre><code>library("DESeq2")
library("airway")
data("airway")
aw   = DESeqDataSet(se = airway, design = ~ cell + dex)
aw   = DESeq(aw)
awde = as.data.frame(results(aw)) |&gt; dplyr::filter(!is.na(pvalue))__</code></pre>
<p>__</p>
<p>Task</p>
<p>Have a look at the content of <code>awde</code>.</p>
<p>__</p>
<p>Task</p>
<p>(Optional) Consult the <strong><a href="https://bioconductor.org/packages/DESeq2/">DESeq2</a></strong> vignette and/or <a href="08-chap.html">Chapter 8</a> for more information on what the above code chunk does.</p>
<section id="the-p-value-histogram" class="level3" data-number="8.8.1">
<h3 data-number="8.8.1" class="anchored" data-anchor-id="the-p-value-histogram"><span class="header-section-number">8.8.1</span> 6.9.1 The p-value histogram</h3>
<p>The <strong>p-value histogram</strong> is an important sanity check for any analysis that involves multiple tests. It is a mixture composed of two components:</p>
<p><strong>null:</strong> the p-values resulting from the tests for which the null hypothesis is true.</p>
<p><strong>alt:</strong> the p-values resulting from the tests for which the null hypothesis is not true. The relative size of these two components depends on the fraction of true nulls and true alternatives (i.e., on \(m_0\) and \(m\)), and it can often be visually estimated from the histogram. If our analysis has high statistical power, then the second component (“alt”) consists of mostly small p-values, i.e., appears as a peak near 0 in the histogram; if the power is not high for some of the alternatives, we expect that this peak extends towards the right, i.e., has a “shoulder”. For the “null” component, we expect (by definition of the p-value for continuous data and test statistics) a uniform distribution in \([0,1]\). Let’s plot the histogram of p-values for the airway data.</p>
<pre><code>ggplot(awde, aes(x = pvalue)) +
  geom_histogram(binwidth = 0.025, boundary = 0)__</code></pre>
<p><a href="06-chap_files/figure-html/fig-testing-awpvhist-1.png &quot;Figure 6.12: p-value histogram of for the airway data.&quot;"><img src="06-chap_files/figure-html/fig-testing- awpvhist-1.png" class="img-fluid"></a></p>
<p>Figure 6.12: p-value histogram of for the <code>airway</code> data.</p>
<p>In Figure 6.12 we see the expected mixture. We also see that the null component is not exactly flat (uniform): this is because the data are counts. While these appear quasi-continuous when high, for the tests with low counts the discreteness of the data and the resulting p-values shows up in the spikes towards the right of the histogram.</p>
<p>Now suppose we reject all tests with a p-value less than \(\). We can visually determine an estimate of the false discovery proportion with a plot such as in Figure 6.13, generated by the following code.</p>
<pre><code>alpha = binw = 0.025
pi0 = 2 * mean(awde$pvalue &gt; 0.5)
ggplot(awde,
  aes(x = pvalue)) + geom_histogram(binwidth = binw, boundary = 0) +
  geom_hline(yintercept = pi0 * binw * nrow(awde), col = "blue") +
  geom_vline(xintercept = alpha, col = "red")__</code></pre>
<p><a href="06-chap_files/figure-html/fig-testing-awpvvisfdr-1.png &quot;Figure 6.13: Visual estimation of the FDR with the p-value histogram.&quot;"><img src="06-chap_files/figure-html/fig-testing- awpvvisfdr-1.png" class="img-fluid"></a></p>
<p>Figure 6.13: Visual estimation of the FDR with the p-value histogram.</p>
<p>We see that there are 4772 p-values in the first bin \([0,]\), among which we expect around 945 to be nulls (as indicated by the blue line). Thus we can estimate the fraction of false rejections as</p>
<pre><code>pi0 * alpha / mean(awde$pvalue &lt;= alpha)__


[1] 0.1980092</code></pre>
<p>The <strong>false discovery rate</strong> (FDR) is defined as</p>
<p>\[ = \!, \]</p>
<p>where \(R\) and \(V\) are as in Table 6.2. The expression in the denominator makes sure that the FDR is well-defined even if \(R=0\) (in that case, \(V=0\) by implication). Note that the FDR becomes identical to the FWER if all null hypotheses are true, i.e., if \(V=R\). \(\) stands for the <strong>expected value</strong>. That means that the FDR is not a quantity associated with a specific outcome of \(V\) and \(R\) for one particular experiment. Rather, given our choice of tests and associated rejection rules for them, it is the average20 proportion of type I errors out of the rejections made, where the average is taken (at least conceptually) over many replicate instances of the experiment.</p>
<p>20 Since the FDR is an expectation value, it does not provide worst case control: in any single experiment, the so-called false discovery proportion (FDP), that is the realized value \(v/r\) (without the \(\)), could be much higher or lower.</p>
</section>
<section id="the-benjamini-hochberg-algorithm-for-controlling-the-fdr" class="level3" data-number="8.8.2">
<h3 data-number="8.8.2" class="anchored" data-anchor-id="the-benjamini-hochberg-algorithm-for-controlling-the-fdr"><span class="header-section-number">8.8.2</span> 6.9.2 The Benjamini-Hochberg algorithm for controlling the FDR</h3>
<p>There is a more elegant alternative to the “visual FDR” method of the last section. The procedure, introduced by Benjamini and Hochberg (<a href="16-chap.html#ref-BH:1995">1995</a>) has these steps:</p>
<ul>
<li><p>First, order the p-values in increasing order, \(p_{(1)} … p_{(m)}\)</p></li>
<li><p>Then for some choice of \(\) (our target FDR), find the largest value of \(k\) that satisfies: \(p_{(k)} , k / m\)</p></li>
<li><p>Finally reject the hypotheses \(1, …, k\)</p></li>
</ul>
<p>We can see how this procedure works when applied to our RNA-Seq p-values through a simple graphical illustration:</p>
<pre><code>phi  = 0.10
awde = mutate(awde, rank = rank(pvalue))
m    = nrow(awde)

ggplot(dplyr::filter(awde, rank &lt;= 7000), aes(x = rank, y = pvalue)) +
  geom_line() + geom_abline(slope = phi / m, col = "red")__</code></pre>
<p><a href="06-chap_files/figure- html/fig-testing-BH-1.png" title="Figure 6.14: Visualization of the Benjamini- Hochberg procedure. Shown is a zoom-in to the 7000 lowest p-values."><img src="06-chap_files/figure-html/fig-testing-BH-1.png" class="img-fluid"></a></p>
<p>Figure 6.14: Visualization of the Benjamini-Hochberg procedure. Shown is a zoom-in to the 7000 lowest p-values.</p>
<p>The method finds the rightmost point where the black (our p-values) and red lines (slope \(/ m\)) intersect. Then it rejects all tests to the left.</p>
<pre><code>kmax = with(arrange(awde, rank),
         last(which(pvalue &lt;= phi * rank / m)))
kmax __


[1] 4099</code></pre>
<p>__</p>
<p>Question 6.15</p>
<p>Compare the value of <code>kmax</code> with the number of 4772 from above (Figure 6.13). Why are they different?</p>
<p>__</p>
<p>Question 6.16</p>
<p>Look at the code associated with the option <code>method="BH"</code> of the <code>p.adjust</code> function that comes with R. How does it compare to what we did above?</p>
<p>__</p>
<p>Question 6.17</p>
<p><strong>Schweder and Spj øtvoll plot</strong>: check out Figures 1–3 in Schweder and Spjøtvoll (<a href="16-chap.html#ref-SchwederSpjotvoll1982">1982</a>). Make a similar plot for the data in <code>awde</code>. How does it relate to Figures 6.14 and 6.13?</p>
<p>__</p>
<p>Solution</p>
<p>__</p>
<p>Thirteen years before Benjamini and Hochberg (<a href="16-chap.html#ref- BH:1995">1995</a>), Schweder and Spjøtvoll (<a href="16-chap.html#ref- SchwederSpjotvoll1982">1982</a>) suggested a diagnostic plot of the observed \(p\)-values that permits estimation of the fraction of true null hypotheses. For a series of hypothesis tests \(H_1, …, H_m\) with \(p\)-values \(p_i\), they suggested plotting</p>
<p>\[ ( 1-p_i, N(p_i) ) i , …, m, \]</p>
<p>where \(N(p)\) is the number of \(p\)-values greater than \(p\). An application of this diagnostic plot to <code>awde$pvalue</code> is shown in Figure 6.15. When all null hypotheses are true, each of the \(p\)-values is uniformly distributed in \([0,1]\), Consequently, the empirical cumulative distribution of the sample \((p_1, …, p_m)\) is expected to be close to the line \(F(t)=t\). By symmetry, the same applies to \((1 - p_1, …, 1 - p_m)\). When (without loss of generality) the first \(m_0\) null hypotheses are true and the other \(m-m_0\) are false, the empirical cumulative distribution of \((1-p_1, …, 1-p_{m_0})\) is again expected to be close to the line \(F_0(t)=t\). The empirical cumulative distribution of \((1-p_{m_0+1}, …, 1-p_{m})\), on the other hand, is expected to be close to a function \(F_1(t)\) which stays below \(F_0\) but shows a steep increase towards 1 as \(t\) approaches \(1\). In practice, we do not know which of the null hypotheses are true, so we only observe a mixture whose empirical cumulative distribution is expected to be close to</p>
<p>\[ F(t) = F_0(t) + F_1(t). \]</p>
<p>Such a situation is shown in Figure 6.15. If \(F_1(t)/F_0(t)\) is small for small \(t\) (i.e., the tests have reasonable power), then the mixture fraction \(\) can be estimated by fitting a line to the left- hand portion of the plot, and then noting its height on the right. Such a fit is shown by the red line. Here, we focus on those tests for which the count data are not all very small numbers (<code>baseMean&gt;=1</code>), since for these the p-value null distribution is sufficiently close to uniform (i.e., does not show the discreteness mentioned above), but you could try the making the same plot on all of the genes.</p>
<pre><code>awdef = awde |&gt;
  dplyr::filter(baseMean &gt;=1) |&gt; 
  arrange(pvalue) |&gt;
  mutate(oneminusp = 1 - pvalue,
         N = n() - row_number())
jj = round(nrow(awdef) * c(1, 0.5))
slope = with(awdef, diff(N[jj]) / diff(oneminusp[jj]))
ggplot(awdef) +
  geom_point(aes(x = oneminusp, y = N), size = 0.15) + 
  xlab(expression(1-p[i])) +
  ylab(expression(N(p[i]))) +
  geom_abline(intercept = 0, slope = slope, col = "red3") +
  geom_hline(yintercept = slope, linetype = "dotted") +
  geom_vline(xintercept = 1, linetype = "dotted") +
  geom_text(x = 0, y = slope, label = paste(round(slope)), 
            hjust = -0.1, vjust = -0.25) __</code></pre>
<p><a href="06-chap_files/figure-html/fig-testing- SchwederSpjotvoll-1.png" title="Figure 6.15: Schweder and Spjtvoll plot, as described in the answer to Question wrn-testing-SchwederSpjotvoll."><img src="06-chap_files/figure-html/fig-testing- SchwederSpjotvoll-1.png" class="img-fluid"></a></p>
<p>Figure 6.15: Schweder and Spjtvoll plot, as described in the answer to Question 6.17.</p>
<p>There are 22853 rows in <code>awdef</code>, thus, according to this simple estimate, there are 22853-17302=5551 alternative hypotheses.</p>
</section>
</section>
<section id="the-local-fdr" class="level2" data-number="8.9">
<h2 data-number="8.9" class="anchored" data-anchor-id="the-local-fdr"><span class="header-section-number">8.9</span> 6.10 The local FDR</h2>
<p><a href="imgs/xkcd1132.png" title="Figure 6.16: From http://xkcd.com/1132 – While the frequentist only has the currently available data, the Bayesian can draw on her understanding of the world or on previous experience. As a Bayesian, she would know enough about physics to understand that our sun’s mass is too small to become a nova. Even if she does not know physics, she might be an empirical Bayesian and draw her prior from a myriad previous days where the sun did not go nova."><img src="imgs/xkcd1132.png" class="img-fluid"></a></p>
<p>Figure 6.16: From <a href="http://xkcd.com/1132" class="uri">http://xkcd.com/1132</a> – While the frequentist only has the currently available data, the Bayesian can draw on her understanding of the world or on previous experience. As a Bayesian, she would know enough about physics to understand that our sun’s mass is too small to become a nova. Even if she does not know physics, she might be an <strong>empirical Bayesian</strong> and draw her prior from a myriad previous days where the sun did not go nova.</p>
<p>While the xkcd cartoon in the chapter’s opening figure ends with a rather sinister interpretation of the multiple testing problem as a way to accumulate errors, Figure 6.16 highlights the multiple testing opportunity: when we do many tests, we can use the multiplicity to increase our understanding beyond what’s possible with a single test.</p>
<p><a href="06-chap_files/figure- html/fig-testing-lfdr-1.png" title="Figure 6.17: Local false discovery rate and the two-group model, with some choice of f_{\text{alt}}(p), and \pi_0=0.6; densities (top) and distribution functions (bottom)."><img src="06-chap_files/figure-html/fig-testing-lfdr-1.png" class="img-fluid"></a></p>
<p>Figure 6.17: Local false discovery rate and the two-group model, with some choice of \(f_{}(p)\), and \(_0=0.6\); densities (top) and distribution functions (bottom).</p>
<p>Let’s get back to the histogram in Figure 6.13. Conceptually, we can think of it in terms of the so-called two-groups model (<a href="16-chap.html#ref- Efron2010">Efron 2010</a>):</p>
<p>\[ f(p)= _0 + (1-<em>0) f</em>{}(p), \]</p>
<p>Here, \(f(p)\) is the density of the distribution (what the histogram would look like with an infinite amount of data and infinitely small bins), \(<em>0\) is a number between 0 and 1 that represents the size of the uniform component, and \(f</em>{}\) is the alternative component. This is a mixture model, as we already saw in <a href="04-chap.html">Chapter 4</a>. The mixture densities and the marginal density \(f(p)\) are visualized in the upper panel of Figure 6.17: the blue areas together correspond to the graph of \(f_{}(p)\), the grey areas to that of \(f_{}(p) = _0\). If we now consider one particular cutoff \(p\) (say, \(p=0.1\) as in Figure 6.17), then we can compute the probability that a hypothesis that we reject at this cutoff is a false positive, as follows. We decompose the value of \(f\) at the cutoff (red line) into the contribution from the nulls (light red, \(_0\)) and from the alternatives (darker red, \((1-<em>0) f</em>{}(p)\)). The <strong>local false discovery rate</strong> is then</p>
<p>\[ (p) = . \]</p>
<p>By definition this quantity is between 0 and 1. Note how the \(\) in Figure 6.17 is a monotonically increasing function of \(p\), and this goes with our intuition that the fdr should be lowest for the smallest \(p\) and then gradually get larger, until it reaches 1 at the very right end. We can make a similar decomposition not only for the red line, but also for the area under the curve. This is</p>
<p>\[ F(p) = _0^p f(t),dt, \]</p>
<p>and the ratio of the dark grey area (that is, \(_0\) times \(p\)) to the overall area \(F(p)\) is the <strong>tail area false discovery rate</strong> (Fdr21),</p>
<p>21 The convention is to use the lower case abbreviation fdr for the local, and the abbreviation Fdr for the tail-area false discovery rate in the context of the two-groups model Equation 6.10. The abbreviation FDR is used for the original definition Equation 6.7, which is a bit more general, namely, it does not depend on the modelling assumptions of Equation 6.10.</p>
<p>\[ (p) = . \]</p>
<p>We’ll use the data version of \(F\) for diagnostics in Figure 6.21.</p>
<p>The packages <strong><a href="https://bioconductor.org/packages/qvalue/">qvalue</a></strong> and <strong><a href="https://cran.r-project.org/web/packages/fdrtool/">fdrtool</a></strong> offer facilities to fit these models to data.</p>
<pre><code>library("fdrtool")
ft = fdrtool(awde$pvalue, statistic = "pvalue")__</code></pre>
<p>In <strong><a href="https://cran.r-project.org/web/packages/fdrtool/">fdrtool</a></strong> , what we called \(_0\) above is called <code>eta0</code>:</p>
<pre><code>ft$param[,"eta0"]__


     eta0 
0.8822922 </code></pre>
<p>__</p>
<p>Question 6.18</p>
<p>What do the plots that are produced by the above call to <code>fdrtool</code> show?</p>
<p>__</p>
<p>Task</p>
<p>Explore the other elements of the <em>list</em> <code>ft</code>.</p>
<p>__</p>
<p>Question 6.19</p>
<p>What does the <em>empirical</em> in empirical Bayes methods stand for?</p>
<section id="local-versus-total" class="level3" data-number="8.9.1">
<h3 data-number="8.9.1" class="anchored" data-anchor-id="local-versus-total"><span class="header-section-number">8.9.1</span> 6.10.1 Local versus total</h3>
<p>The FDR (or the Fdr) is a set property. It is a single number that applies to a whole set of rejections made in the course of a multiple testing analysis. In contrast, the fdr is a local property. It applies to an individual hypothesis. Recall Figure 6.17, where the fdr was computed for each point along the \(x\)-axis of the density plot, whereas the Fdr depends on the areas to the left of the red line.</p>
<p>__</p>
<p>Question 6.20</p>
<p>Check out the concepts of <em>total cost</em> and <em>marginal cost</em> in economics. Can you see an analogy with Fdr and fdr?</p>
<p>__</p>
<p>Solution</p>
<p>__</p>
<p>For a production process that produces a set of \(m\) products, the total cost is the sum of the all costs involved. The average cost of a product is a hypothetical quantity, computed as the total cost divided by \(m\). The marginal cost is the cost of making one additional product, and is often very different from the average cost. For instance, learning to play a single Beethoven sonata on the piano may take an uninitiated person a substantial amount of time, but then playing it once more requires comparatively little additional effort: the marginal costs are much less than the fixed (and thus the total) costs. An example for marginal costs that are higher than the average costs is running: putting on your shoes and going out for a 10km run may be quite tolerable (perhaps even fun) to most people, whereas each additional 10km could add disproportional discomfort.</p>
</section>
<section id="terminology" class="level3" data-number="8.9.2">
<h3 data-number="8.9.2" class="anchored" data-anchor-id="terminology"><span class="header-section-number">8.9.2</span> 6.10.2 Terminology</h3>
<p>Historically, the terms <em>multiple testing correction</em> and <em>adjusted p-value</em> have been used for process and output. In the context of false discovery rates, these terms are not helpful, if not confusing. We advocate avoiding them. They imply that we start out with a set of p-values \((p_1,…,p_m)\), apply some canonical procedure, and obtain a set of “corrected” or “adjusted” p-values \((p_1<sup>{},…,p_m</sup>{})\). However, the output of the Benjamini-Hochberg method is not p-values, and neither are the FDR, Fdr or the fdr. Remember that FDR and Fdr are set properties, and associating them with an individual test makes as much sense as confusing average and marginal costs. Fdr and fdr also depend on a substantial amount of modelling assumptions. In the next session, you will also see that the method of Benjamini-Hochberg is not the only game in town, and that there are important and useful extensions, which further displace any putative direct correspondence between the set of hypotheses and p-values that are input into a multiple testing procedure, and its outputs.</p>
</section>
</section>
<section id="independent-hypothesis-weighting" class="level2" data-number="8.10">
<h2 data-number="8.10" class="anchored" data-anchor-id="independent-hypothesis-weighting"><span class="header-section-number">8.10</span> 6.11 Independent hypothesis weighting</h2>
<p>The Benjamini-Hochberg method and the two-groups model, as we have seen them so far, implicitly assume <em>exchangeability</em> of the hypotheses: all we use are the p-values. Beyond these, we do not take into account any additional information. This is not always optimal, and here we’ll study ways of how to improve on this.</p>
<p>Let’s look at an example. Intuitively, the signal-to-noise ratio for genes with larger numbers of reads mapped to them should be better than for genes with few reads, and that should affect the power of our tests. We look at the mean of normalized counts across observations. In the <strong><a href="https://bioconductor.org/packages/DESeq2/">DESeq2</a></strong> package this quantity is called the <code>baseMean</code>.</p>
<pre><code>awde$baseMean[1]__


[1] 708.6022


cts = counts(aw, normalized = TRUE)[1, ]
cts __


SRR1039508 SRR1039509 SRR1039512 SRR1039513 SRR1039516 SRR1039517 SRR1039520 
  663.3142   499.9070   740.1528   608.9063   966.3137   748.3722   836.2487 
SRR1039521 
  605.6024 


mean(cts)__


[1] 708.6022</code></pre>
<p>Next we produce the histogram of this quantity across genes, and plot it against the p-values (Figures 6.18 and 6.19).</p>
<pre><code>ggplot(awde, aes(x = asinh(baseMean))) +
  geom_histogram(bins = 60)__</code></pre>
<p><a href="06-chap_files/figure-html/fig-testing-basemean-hist-1.png &quot;Figure 6.18: Histogram of baseMean. We see that it covers a large dynamic range, from close to 0 to around 330000.&quot;"><img src="06-chap_files/figure-html/fig-testing-basemean- hist-1.png" class="img-fluid"></a></p>
<p>Figure 6.18: Histogram of <code>baseMean</code>. We see that it covers a large dynamic range, from close to 0 to around 330000.</p>
<pre><code>ggplot(awde, aes(x = rank(baseMean), y = -log10(pvalue))) +
  geom_hex(bins = 60) +
  theme(legend.position = "none")__</code></pre>
<p><a href="06-chap_files/figure-html/fig-testing-basemean-scp-1.png &quot;Figure 6.19: Scatterplot of the rank of baseMean versus the negative logarithm of the p-value. For small values of baseMean, no small p-values occur. Only for genes whose read counts across all observations have a certain size, the test for differential expression has power to come out with a small p-value.&quot;"><img src="06-chap_files/figure-html/fig-testing-basemean- scp-1.png" class="img-fluid"></a></p>
<p>Figure 6.19: Scatterplot of the rank of <code>baseMean</code> versus the negative logarithm of the p-value. For small values of <code>baseMean</code>, no small p-values occur. Only for genes whose read counts across all observations have a certain size, the test for differential expression has power to come out with a small p-value.</p>
<p>__</p>
<p>Question 6.21</p>
<p>Why did we use the \(\) transformation for the histogram? How does it look like with no transformation, the logarithm, the shifted logarithm, i.e., \((x+)\)?</p>
<p>__</p>
<p>Question 6.22</p>
<p>In the scatterplot, why did we use \(-_{10}\) for the p-values? Why the rank transformation for the <code>baseMean</code>?</p>
<p>For convenience, we discretize <code>baseMean</code> into a factor variable <code>group</code>, which corresponds to six equal-sized groups.</p>
<pre><code>awde = mutate(awde, stratum = cut(baseMean, include.lowest = TRUE,
  breaks = signif(quantile(baseMean,probs=seq(0,1,length.out=7)),2)))__</code></pre>
<p>In Figures 6.20 and 6.21 we see the histograms of p-values and the ECDFs stratified by <code>stratum</code>.</p>
<pre><code>ggplot(awde, aes(x = pvalue)) + facet_wrap( ~ stratum, nrow = 4) +
  geom_histogram(binwidth = 0.025, boundary = 0)__</code></pre>
<p><a href="06-chap_files/figure-html/fig-testing-awde-stratified-hist-1.png &quot;Figure 6.20: p-value histograms of the airway data, stratified into equally sized groups defined by increasing value of baseMean.&quot;"><img src="06-chap_files/figure-html/fig-testing-awde-stratified- hist-1.png" class="img-fluid"></a></p>
<p>Figure 6.20: p-value histograms of the airway data, stratified into equally sized groups defined by increasing value of <code>baseMean</code>.</p>
<pre><code>ggplot(awde, aes(x = pvalue, col = stratum)) +
  stat_ecdf(geom = "step") + theme(legend.position = "bottom")__</code></pre>
<p><a href="06-chap_files/figure-html/fig-testing-awde-stratified-ecdf-1.png &quot;Figure 6.21: Same data as in Figure fig-testing-awde-stratified-hist, shown with ECDFs.&quot;"><img src="06-chap_files/figure-html/fig-testing-awde-stratified- ecdf-1.png" class="img-fluid"></a></p>
<p>Figure 6.21: Same data as in Figure 6.20, shown with ECDFs.</p>
<p>If we were to fit the two-group model to these strata separately, we would get quite different estimates for \(<em>0\) and \(f</em>{}\). For the most lowly expressed genes, the power of the <strong><a href="https://bioconductor.org/packages/DESeq2/">DESeq2</a></strong> -test is low, and the p-values essentially all come from the null component. As we go higher in average expression, the height of the small-p-values peak in the histograms increases, reflecting the increasing power of the test.</p>
<p>Can we use that to improve our handling of the multiple testing? It turns out that this is possible. One approach is <strong>independent hypothesis weighting</strong> (IHW) (<a href="16-chap.html#ref-Ignatiadis:2016">Ignatiadis et al.&nbsp;2016</a>; <a href="16-chap.html#ref-Ignatiadis:JRSSB:2021">Ignatiadis and Huber 2021</a>)22.</p>
<p>22 There are a number of other approaches, see e.g., a benchmark study by Korthauer et al.&nbsp;(<a href="16-chap.html#ref-Korthauer:GB:2019">2019</a>) or the citations in the paper by Ignatiadis and Huber (<a href="16-chap.html#ref- Ignatiadis:JRSSB:2021">2021</a>).</p>
<pre><code>library("IHW")
ihw_res = ihw(awde$pvalue, awde$baseMean, alpha = 0.1)
rejections(ihw_res)__


[1] 4892</code></pre>
<p>Let’s compare this to what we get from the ordinary (unweighted) Benjamini- Hochberg method:</p>
<pre><code>padj_BH = p.adjust(awde$pvalue, method = "BH")
sum(padj_BH &lt; 0.1)__


[1] 4099</code></pre>
<p>With hypothesis weighting, we get more rejections. For these data, the difference is notable though not spectacular; this is because their signal-to- noise ratio is already quite high. In other situations, where there is less power to begin with (e.g., where there are fewer replicates, the data are more noisy, or the effect of the treatment is less drastic), the difference from using IHW can be more pronounced.</p>
<p>We can have a look at the weights determined by the <code>ihw</code> function (Figure 6.22).</p>
<pre><code>plot(ihw_res)__</code></pre>
<p><a href="06-chap_files/figure-html/fig-testing-ihwplot-1.png &quot;Figure 6.22: Hypothesis weights determined by the ihw function. Here the function’s default settings chose 22 strata, while in our manual exploration above (Figures fig-testing-awde-stratified-hist, fig-testing-awde-stratified- ecdf) we had used 6; in practice, this is a minor detail.&quot;"><img src="06-chap_files/figure-html/fig-testing- ihwplot-1.png" class="img-fluid"></a></p>
<p>Figure 6.22: Hypothesis weights determined by the <code>ihw</code> function. Here the function’s default settings chose 22 strata, while in our manual exploration above (Figures 6.20, 6.21) we had used 6; in practice, this is a minor detail.</p>
<p>Intuitively, what happens here is that IHW chooses to put more weight on the hypothesis strata with higher <code>baseMean</code>, and low weight on those with very low counts. The Benjamini-Hochberg method has a certain type-I error budget, and rather than spreading it equally among all hypotheses, here we take it away from those strata that have little change of small fdr anyway, and “invest” it in strata where many hypotheses can be rejected at small fdr.</p>
<p>__</p>
<p>Question 6.23</p>
<p>Why does Figure 6.22 show 5 curves, rather than only one?</p>
<p>Such possibilities for stratification by an additional summary statistic besides the p-value—in our case, the <code>baseMean</code>—exist in many multiple testing situations. Informally, we need such a so-called <em>covariate</em> to be</p>
<ul>
<li><p>statistically independent from our p-values under the null, but</p></li>
<li><p>informative of the prior probability \(<em>0\) and/or the power of the test (the shape of the alternative density, \(f</em>{}\)) in the two-groups model.</p></li>
</ul>
<p>These requirements can be assessed through diagnostic plots as in Figures 6.18—6.21.</p>
</section>
<section id="summary-of-this-chapter" class="level2" data-number="8.11">
<h2 data-number="8.11" class="anchored" data-anchor-id="summary-of-this-chapter"><span class="header-section-number">8.11</span> 6.12 Summary of this chapter</h2>
<p>We have explored the concepts behind <em>single hypothesis testing</em> and then moved on to <em>multiple testing</em>. We have seen how some of the limitations of interpreting a single p-value from a single test can be overcome once we are able to consider a whole distribution of outcomes from many tests. We have also seen that there are often additional summary statistics of our data, besides the p-values. We called them informative covariates, and we saw how we can use them to weigh the p-values and overall get more (or better) discoveries.</p>
<p>The usage of hypothesis testing in the <em>multiple testing</em> scenario is quite different from that in the <em>single test</em> case: for the latter, the hypothesis test might literally be the final result, the culmination of a long and expensive data acquisition campaign (ideally, with a prespecified hypothesis and data analysis plan). In the multiple testing case, its outcome will often just be an intermediate step: a subset of most worthwhile hypotheses selected by screening a large initial set. This subset is then followed up by more careful analyses.</p>
<p>We have seen the concept of the <em>false discovery rate</em> (FDR). It is important to keep in mind that this is an average property, for the subset of hypotheses that were selected. Like other averages, it does not say anything about the individual hypotheses. Then there is the concept of the <em>local false discovery rate</em> (fdr), which indeed does apply to an individual hypothesis. The local false discovery rate is however quite unrelated to the p-value, as the two- group model showed us. Much of the confusion and frustration about p-values seems to come from the fact that people would like to use them for purposes that the fdr is made for. It is perhaps a historical aberration that so much of applied sciences focuses on p-values and not local false discovery rate. On the other hand, there are also practical reasons, since a p-value is readily computed, whereas a fdr is difficult to estimate or control from data without making strong modelling assumptions.</p>
<p>We saw the importance of diagnostic plots, in particular, to always look at the p-value histograms when encountering a multiple testing analysis.</p>
</section>
<section id="further-reading" class="level2" data-number="8.12">
<h2 data-number="8.12" class="anchored" data-anchor-id="further-reading"><span class="header-section-number">8.12</span> 6.13 Further reading</h2>
<ul>
<li><p>A comprehensive text book treatment of multiple testing is given by Efron (<a href="16-chap.html#ref-Efron2010">2010</a>).</p></li>
<li><p>Outcome switching in clinical trials: <a href="http://compare-trials.org" class="uri">http://compare-trials.org</a></p></li>
<li><p>For hypothesis weighting, the <strong><a href="https://bioconductor.org/packages/IHW/">IHW</a></strong> vignette, the IHW paper (<a href="16-chap.html#ref-Ignatiadis:2016">Ignatiadis et al.&nbsp;2016</a>) and the references therein.</p></li>
</ul>
</section>
<section id="exercises" class="level2" data-number="8.13">
<h2 data-number="8.13" class="anchored" data-anchor-id="exercises"><span class="header-section-number">8.13</span> 6.14 Exercises</h2>
<p>__</p>
<p>Exercise 6.1</p>
<p>Identify an application from your scientific field of expertise that relies on multiple testing. Find an exemplary dataset and plot the histogram of p-values. Are the hypotheses all exchangeable, or is there one or more informative covariates? Plot the stratified histograms.</p>
<p>__</p>
<p>Exercise</p>
<p>Why do mathematical statisticians focus so much on the null hypothesis of a test, compared to the alternative hypothesis?</p>
<p>__</p>
<p>Exercise 6.2</p>
<p>How can we ever prove that the null hypothesis is true? Or that the alternative is true?</p>
<p>__</p>
<p>Exercise 6.3</p>
<p>Make a less extreme example of correlated test statistics than the data duplication at the end of Section 6.5. Simulate data with true null hypotheses only, and let the data morph from having completely independent replicates (columns) to highly correlated as a function of some continuous-valued control parameter. Check type-I error control (e.g., with the p-value histogram) as a function of this control parameter.</p>
<p>__</p>
<p>Exercise 6.4</p>
<p>Find an example in the published literature that looks as if p-value hacking, outcome switching, HARKing played a role.</p>
<p>__</p>
<p>Exercise 6.5</p>
<p>The FDR is an expectation value, i.e., it is used if we want to control the average behavior of a procedure. Are there methods for worst case control?</p>
<p>__</p>
<p>Exercise 6.6</p>
<p>What is the memory and time complexity of the Benjamini-Hochberg algorithm? How about the IHW method? Can you fit polynomial functions as a function of the number of tests \(m\)? Hint: Simulate data with increasing numbers of hypothesis tests, measure time and memory consumption with functions such as <code>pryr::object_size</code> or <code>microbenchmark</code> from the eponymous package, and plot these against \(m\) in a double-logarithmic plot.</p>
<p>Altman, Naomi, and Martin Krzywinski. 2017. “Points of Significance: Interpreting p Values.” <em>Nature Methods</em> 14 (3): 213–14. <a href="https://doi.org/10.1038/nmeth.4210" class="uri">https://doi.org/10.1038/nmeth.4210</a>.</p>
<p>Benjamini, Yoav, and Yosef Hochberg. 1995. “Controlling the False Discovery Rate: A Practical and Powerful Approach to Multiple Testing.” <em>Journal of the Royal Statistical Society B</em> 57: 289–300.</p>
<p>Efron, Bradley. 2010. <em>Large-Scale Inference: Empirical Bayes Methods for Estimation, Testing, and Prediction</em>. Cambridge University Press.</p>
<p>Head, Megan L, Luke Holman, Rob Lanfear, Andrew T Kahn, and Michael D Jennions. 2015. “The Extent and Consequences of p-Hacking in Science.” <em>PLoS Biology</em> 13 (3): e1002106.</p>
<p>Ignatiadis, Nikolaos, and Wolfgang Huber. 2021. “Covariate Powered Cross- Weighted Multiple Testing.” <em>Journal of the Royal Statistical Society: Series B</em> 83: 720–51. <a href="https://doi.org/10.1111/rssb.12411" class="uri">https://doi.org/10.1111/rssb.12411</a>.</p>
<p>Ignatiadis, Nikolaos, Bernd Klaus, Judith Zaugg, and Wolfgang Huber. 2016. “Data-Driven Hypothesis Weighting Increases Detection Power in Genome-Scale Multiple Testing.” <em>Nature Methods</em> 13: 577–80.</p>
<p>Korthauer, K., P. K. Kimes, C. Duvallet, A. Reyes, A. Subramanian, M. Teng, C. Shukla, E. J. Alm, and S. C. Hicks. 2019. “A practical guide to methods controlling false discoveries in computational biology.” <em>Genome Biology</em> 20 (1): 118.</p>
<p>Schweder, T., and E. Spjøtvoll. 1982. “Plots of P-values to Evaluate Many Tests Simultaneously.” <em>Biometrika</em> 69: 493–502. <a href="https://doi.org/10.1093/biomet/69.3.493" class="uri">https://doi.org/10.1093/biomet/69.3.493</a>.</p>
<p>Storey, John D. 2003. “The Positive False Discovery Rate: A Bayesian Interpretation and the q-Value.” <em>The Annals of Statistics</em> 31 (6). <a href="https://doi.org/10.1214/aos/1074290335" class="uri">https://doi.org/10.1214/aos/1074290335</a>.</p>
<p>Wasserstein, Ronald L, and Nicole A Lazar. 2016. “The ASA’s Statement on p-Values: Context, Process, and Purpose.” <em>The American Statistician</em>.</p>
<p>Page built at 01:33 on 2025-09-01 using R version 4.5.1 (2025-06-13)</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./05-chap.html" class="pagination-link" aria-label="5.1 Goals for this chapter">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">5.1 Goals for this chapter</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./07-chap.html" class="pagination-link" aria-label="7.1 Goals for this chapter">
        <span class="nav-page-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">7.1 Goals for this chapter</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>