<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>12&nbsp; 10.1 이 장의 목표 – Modern Statistics for Modern Biology</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./11-chap.html" rel="next">
<link href="./09-chap.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-ed96de9b727972fe78a7b5d16c58bf87.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-7bf12d62aa84b4fa538b342f1416a45b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="msmb.css">
</head>

<body class="nav-sidebar docked quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./10-chap.html"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">10.1 이 장의 목표</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Modern Statistics for Modern Biology</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">홈</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./00-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">주제: 이질성</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">1.1 이 장의 목표</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">2.1 이 장의 목표</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">3.1 이 장의 목표</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">4.1 이 장의 목표</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">5.1 이 장의 목표</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">6.1 이 장의 목표</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">7.1 이 장의 목표</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./08-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">8.1 이 장의 목표</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./09-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">9.1 이 장의 목표</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./10-chap.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">10.1 이 장의 목표</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./11-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">11.1 이 장의 목표</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./12-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">12.1 Goals for this chapter</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./13-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">13.1 Goals for this chapter</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./14-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">14-chap.html</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./15-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">15-chap.html</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./16-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">16-chap.html</span></span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#그래프graphs" id="toc-그래프graphs" class="nav-link active" data-scroll-target="#그래프graphs"><span class="header-section-number">12.1</span> 10.2 그래프(Graphs)</a>
  <ul class="collapse">
  <li><a href="#그래프란-무엇이며-어떻게-인코딩할-수-있는가" id="toc-그래프란-무엇이며-어떻게-인코딩할-수-있는가" class="nav-link" data-scroll-target="#그래프란-무엇이며-어떻게-인코딩할-수-있는가"><span class="header-section-number">12.1.1</span> 10.2.1 그래프란 무엇이며 어떻게 인코딩할 수 있는가?</a></li>
  <li><a href="#여러-레이어가-있는-그래프-에지와-노드의-레이블" id="toc-여러-레이어가-있는-그래프-에지와-노드의-레이블" class="nav-link" data-scroll-target="#여러-레이어가-있는-그래프-에지와-노드의-레이블"><span class="header-section-number">12.1.2</span> 10.2.2 여러 레이어가 있는 그래프: 에지와 노드의 레이블</a></li>
  </ul></li>
  <li><a href="#유전자-세트-농축에서-네트워크로" id="toc-유전자-세트-농축에서-네트워크로" class="nav-link" data-scroll-target="#유전자-세트-농축에서-네트워크로"><span class="header-section-number">12.2</span> 10.3 유전자 세트 농축에서 네트워크로</a>
  <ul class="collapse">
  <li><a href="#사전-정의된-유전자-세트를-사용하는-방법gsea" id="toc-사전-정의된-유전자-세트를-사용하는-방법gsea" class="nav-link" data-scroll-target="#사전-정의된-유전자-세트를-사용하는-방법gsea"><span class="header-section-number">12.2.1</span> 10.3.1 사전 정의된 유전자 세트를 사용하는 방법(GSEA)</a></li>
  <li><a href="#원-분할표-검정을-이용한-유전자-세트-분석" id="toc-원-분할표-검정을-이용한-유전자-세트-분석" class="nav-link" data-scroll-target="#원-분할표-검정을-이용한-유전자-세트-분석"><span class="header-section-number">12.2.2</span> 10.3.2 2원 분할표 검정을 이용한 유전자 세트 분석</a></li>
  <li><a href="#유의미한-하위-그래프-및-고득점-모듈" id="toc-유의미한-하위-그래프-및-고득점-모듈" class="nav-link" data-scroll-target="#유의미한-하위-그래프-및-고득점-모듈"><span class="header-section-number">12.2.3</span> 10.3.3 유의미한 하위 그래프 및 고득점 모듈</a></li>
  <li><a href="#bionet-구현-예시" id="toc-bionet-구현-예시" class="nav-link" data-scroll-target="#bionet-구현-예시"><span class="header-section-number">12.2.4</span> 10.3.4 BioNet 구현 예시</a></li>
  </ul></li>
  <li><a href="#계통수-phylogenetic-trees" id="toc-계통수-phylogenetic-trees" class="nav-link" data-scroll-target="#계통수-phylogenetic-trees"><span class="header-section-number">12.3</span> 10.4 계통수 (Phylogenetic Trees)</a>
  <ul class="collapse">
  <li><a href="#진화를-위한-마르코프-모델-markovian-models-for-evolution" id="toc-진화를-위한-마르코프-모델-markovian-models-for-evolution" class="nav-link" data-scroll-target="#진화를-위한-마르코프-모델-markovian-models-for-evolution"><span class="header-section-number">12.3.1</span> 10.4.1 진화를 위한 마르코프 모델 (Markovian models for evolution)</a></li>
  <li><a href="#estimating-a-phylogenetic-tree" id="toc-estimating-a-phylogenetic-tree" class="nav-link" data-scroll-target="#estimating-a-phylogenetic-tree"><span class="header-section-number">12.3.2</span> 10.4.3 Estimating a phylogenetic tree</a></li>
  <li><a href="#application-to-16s-rrna-data" id="toc-application-to-16s-rrna-data" class="nav-link" data-scroll-target="#application-to-16s-rrna-data"><span class="header-section-number">12.3.3</span> 10.4.4 Application to 16S rRNA data</a></li>
  </ul></li>
  <li><a href="#combining-phylogenetic-trees-into-a-data-analysis" id="toc-combining-phylogenetic-trees-into-a-data-analysis" class="nav-link" data-scroll-target="#combining-phylogenetic-trees-into-a-data-analysis"><span class="header-section-number">12.4</span> 10.5 Combining phylogenetic trees into a data analysis</a>
  <ul class="collapse">
  <li><a href="#hierarchical-multiple-testing" id="toc-hierarchical-multiple-testing" class="nav-link" data-scroll-target="#hierarchical-multiple-testing"><span class="header-section-number">12.4.1</span> 10.5.1 Hierarchical multiple testing</a></li>
  </ul></li>
  <li><a href="#minimum-spanning-trees" id="toc-minimum-spanning-trees" class="nav-link" data-scroll-target="#minimum-spanning-trees"><span class="header-section-number">12.5</span> 10.6 Minimum spanning trees</a>
  <ul class="collapse">
  <li><a href="#mst-based-testing-the-friedmanrafsky-test" id="toc-mst-based-testing-the-friedmanrafsky-test" class="nav-link" data-scroll-target="#mst-based-testing-the-friedmanrafsky-test"><span class="header-section-number">12.5.1</span> 10.6.1 MST based testing: the Friedman–Rafsky test</a></li>
  <li><a href="#example-bacteria-sharing-between-mice" id="toc-example-bacteria-sharing-between-mice" class="nav-link" data-scroll-target="#example-bacteria-sharing-between-mice"><span class="header-section-number">12.5.2</span> 10.6.2 Example: Bacteria sharing between mice</a></li>
  <li><a href="#friedmanrafsky-test-with-nested-covariates" id="toc-friedmanrafsky-test-with-nested-covariates" class="nav-link" data-scroll-target="#friedmanrafsky-test-with-nested-covariates"><span class="header-section-number">12.5.3</span> 10.6.3 Friedman–Rafsky test with nested covariates</a></li>
  </ul></li>
  <li><a href="#summary-of-this-chapter" id="toc-summary-of-this-chapter" class="nav-link" data-scroll-target="#summary-of-this-chapter"><span class="header-section-number">12.6</span> 10.7 Summary of this chapter</a></li>
  <li><a href="#further-reading" id="toc-further-reading" class="nav-link" data-scroll-target="#further-reading"><span class="header-section-number">12.7</span> 10.8 Further reading</a></li>
  <li><a href="#exercises" id="toc-exercises" class="nav-link" data-scroll-target="#exercises"><span class="header-section-number">12.8</span> 10.9 Exercises</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">10.1 이 장의 목표</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p><img src="imgs/Darwin_Tree_1837_web.png" class="img-fluid"></p>
<p>네트워크와 트리는 생물학적 시스템에 대한 지식을 표현하는 데 종종 사용됩니다. 또한 실험이나 연구로부터 얻은 관측치를 직접 인코딩하는 데에도 사용될 수 있습니다. 계통수(Phylogenetic trees)는 종들 사이의 가족 및 유사성 관계를 표현하기 위해 그려졌으며, 심지어 이러한 트리에 기계론적이고 인과적인 해석을 부여한 다윈의 유명한 노트북 스케치 이전부터 존재했습니다. 네트워크에서 노드(nodes)와 에지(edges)의 의미는 다를 수 있으며 명시되어야 합니다. 예를 들어, 네트워크는 <a href="10-chap.html#fig-chemo-1">그림 10.1</a>에서처럼 단백질들 사이의 관계를 도식화할 수 있는데, 여기서 노드는 유전자나 그들이 인코딩하는 단백질을 나타낼 수 있고, 에지는 직접적인 물리적 상호작용이거나 실험 결과를 나타내는 좀 더 추상적인 “기능적” 또는 “유전적” 상호작용일 수 있습니다. 이 책에서 우리는 _그래프(graph)_와 _네트워크(network)_라는 용어를 거의 혼용하여 사용합니다. 전자는 수학적 구조를 좀 더 연상시키고, 후자는 생물학적 해석을 좀 더 연상시킵니다.</p>
<p><a href="10-chap_files/figure- html/fig-chemo-1.png" title="그림 10.1: 단백질 사이의 쌍별 관계를 나타내는 작은 단백질-단백질 네트워크."><img src="10-chap_files/figure-html/fig-chemo-1.png" class="img-fluid"></a></p>
<p>그림 10.1: 단백질 사이의 쌍별 관계를 나타내는 작은 단백질-단백질 네트워크.</p>
<p>리는 <a href="02-chap.html">2장</a>에서 상태 전이의 시퀀스를 마르코프 체인으로 모델링할 수 있음을 보았으며, 이는 에지에 가중치가 있는 유향 그래프(directed graphs)로 표현될 수 있습니다. 노드가 화학적 대사산물이고 에지가 화학 반응을 나타내는 대사 경로(Metabolic pathways)가 그 예입니다. 암 유전체학에서는 돌연변이의 계통을 나타내기 위해 돌연변이 이력 트리(Mutation history trees)가 사용됩니다.</p>
<p>전염 네트워크(Transmission networks)는 감염병의 역학을 연구하는 데 중요합니다. 실제 네트워크는 매우 클 수 있으므로, 이를 표현하고 시각화하기 위한 특수한 방법들이 필요할 것입니다. 이 장은 데이터 분석 워크플로에 그래프를 통합하는 방법들에 초점을 맞출 것입니다.</p>
<p>이 장에서 우리는 다음을 수행할 것입니다:</p>
<ul>
<li><p>에지, 정점(vertices), 레이아웃(layout)과 같은 그래프 구성 요소의 공식적인 정의를 사용하여, 인접 행렬(adjacency matrices)과 에지 리스트(lists of edges)를 모두 이용해 R에서 이들을 어떻게 조작할 수 있는지 살펴봅니다.</p></li>
<li><p><strong><a href="https://cran.r-project.org/web/packages/igraph/">igraph</a></strong>의 그래프 객체를 <strong><a href="https://cran.r-project.org/web/packages/ggraph/">ggraph</a></strong>를 사용하여 <strong><a href="https://bioconductor.org/packages/ggplot2/">ggplot2</a></strong>의 레이어 접근 방식에 따라 시각화할 수 있는 객체로 변환합니다. 그래프의 에지와 노드에 부착하는 공변량(covariates)을 실험해 봅니다.</p></li>
<li><p>그래프는 시스템에 대한 사전 지식을 인코딩하는 유용한 방법입니다. 우리는 그래프가 어떻게 단순한 유전자 세트 분석을 넘어, 네트워크 상에 유의성 점수(significance scores)를 매핑하여 섭동 <strong>핫스팟(hotspots)</strong>을 탐지함으로써 의미 있는 생물학적 권고안을 제시할 수 있게 해주는지 살펴볼 것입니다.</p></li>
<li><p>DNA 서열로부터 계통수(phylogenetic trees)를 구축하고, 이를 위해 특별히 설계된 R 패키지인 <strong><a href="https://cran.r-project.org/web/packages/ape/">ape</a></strong>와 <strong><a href="https://cran.r-project.org/web/packages/ggtree/">ggtree</a></strong>를 사용하여 시각화합니다.</p></li>
<li><p>마이크로바이옴 16S rRNA 데이터로부터 구축된 계통수와 공변량을 결합하여, 분류군(taxa) 간의 계층적 관계가 어떻게 다중 가설 검정의 검정력을 높일 수 있는지 보여줍니다.</p></li>
<li><p>최소 신장 트리(minimum spanning tree, MST)라고 불리는 특수한 트리는 그래프와 다른 공변량 사이의 관계를 테스트하는 데 매우 유용합니다. 프리드먼-라프스키(Friedman-Rafsky) 검정이라 알려진 방법의 서로 다른 버전들을 어떻게 구현하는지 살펴볼 것입니다. 생쥐 집단에서의 박테리아 공동 발생과 HIV 전염 네트워크에서의 균주 유사성을 모두 연구할 것입니다.</p></li>
</ul>
<section id="그래프graphs" class="level2" data-number="12.1">
<h2 data-number="12.1" class="anchored" data-anchor-id="그래프graphs"><span class="header-section-number">12.1</span> 10.2 그래프(Graphs)</h2>
<section id="그래프란-무엇이며-어떻게-인코딩할-수-있는가" class="level3" data-number="12.1.1">
<h3 data-number="12.1.1" class="anchored" data-anchor-id="그래프란-무엇이며-어떻게-인코딩할-수-있는가"><span class="header-section-number">12.1.1</span> 10.2.1 그래프란 무엇이며 어떻게 인코딩할 수 있는가?</h3>
<p><strong>그래프(graph)</strong>는 흔히 \((V,E)\)로 표시되는 두 세트의 조합으로 정의됩니다. 여기서 \(V\)는 <strong>노드(nodes)</strong> 또는 <strong>정점(vertices)</strong>의 세트이고, \(E\)는 정점들 사이의 <strong>에지(edges)</strong> 세트입니다. \(E\)의 각 원소는 노드 쌍으로, 즉 \(V\)의 두 원소로 구성됩니다. 그래프를 표현하는 직관적인 방법은 <strong>출발-도착(from-to)</strong> 표현입니다. 정점 세트를 \(V=(, , , )\)라고 하면, 출발-도착(또는 <strong>에지 리스트</strong>) 표현은 다음과 같은 형태의 표입니다.</p>
<pre><code>  from to
1    A  B
2    B  C
3    A  E
4    C  D
5    E  F</code></pre>
<p>출발-도착 표에서 행의 순서는 아무런 역할을 하지 않습니다. <strong>유향 그래프(directed graph)</strong> 또는 <strong>지향 그래프(oriented graph)</strong>에서 에지는 순서가 있는 쌍입니다. 즉, 위 표의 첫 번째 줄은 A에서 B로 가는 에지가 있음을 나타내지만, B에서 A로 가는 에지도 있는지는 말해주지 않습니다 — 이는 표의 별도 행에 표시되어야 합니다.</p>
<p><strong>무향 그래프(undirected graph)</strong>에서 에지는 순서가 없는 쌍입니다. 즉, A에서 B로 가는 에지는 B에서 A로 가는 에지와 구분되지 않습니다. 무향 그래프는 노드 사이의 대칭적인 관계를 인코딩하고, 유향 그래프는 비대칭적인 관계를 나타냅니다.</p>
<p>그래프를 그 시각화와 혼동하지 않는 것이 중요합니다. <a href="10-chap.html#fig-chemo-1">그림 10.1</a>에서처럼 그래프를 2차원 영역에 그리는 것이 가능하지만, 이는 선택 사항이며 유일하지 않습니다 — 동일한 그래프를 그리는 방법은 항상 여러 가지가 있습니다. 또한 그러한 시각화에서 에지가 겹치지 않는다는 보장도 없습니다. 그래프에 따라 그런 일이 발생할 수 있습니다. 그래프는 물리적 공간(2D든 3D든)에 살고 있는 것이 아니라 말 그대로 노드와 에지의 세트일 뿐입니다.</p>
<p>출발-도착 표와 동등한 대안적인 표현은 <strong>인접 행렬(adjacency matrix)</strong>입니다. 이는 그래프의 노드 수만큼의 행(및 열)을 가진 정사각 행렬입니다. 행렬의 \(i\)번째 행과 \(j\)번째 열에 0이 아닌 항목이 있으면 이는 \(i\)번째 정점과 \(j\)번째 정점 사이에 에지가 있음을 인코딩합니다.</p>
<p>__</p>
<p>질문 10.1</p>
<p>무향 그래프의 경우, 인접 행렬 \(A\)의 어떤 점이 특별한가요?</p>
<p>__</p>
<p>해결책</p>
<p>__</p>
<p>인접 행렬은 대칭입니다. 즉, \(M = M^T\)입니다. 예시가 그림 10.2와 10.3에 나와 있습니다. <code>g1</code>은 아래 코드를 통해 출발-도착 표(2열 행렬 <code>edges</code>에 인코딩됨)로부터 생성되었습니다.</p>
<pre><code>library("igraph")
edges = matrix(c(1,3, 2,3, 3,4, 4,5, 4,6), byrow = TRUE, ncol = 2)
g1 = graph_from_edgelist(edges, directed = FALSE)
vertex_attr(g1, name = "name") = 1:6
plot(g1, vertex.size = 25, edge.width = 5, vertex.color = "coral")__</code></pre>
<p><a href="10-chap_files/figure- html/fig-igraphplot-1.png" title="그림 10.2: 번호가 매겨진 노드가 있는 작은 무향 그래프."><img src="10-chap_files/figure-html/fig-igraphplot-1.png" class="img-fluid"></a></p>
<p>그림 10.2: 번호가 매겨진 노드가 있는 작은 무향 그래프.</p>
<p><a href="10-chap_files/figure- html/fig-adjmatrix-1.png" title="그림 10.3: 그림 10.2에 표시된 그래프의 인접 행렬은 0과 1로 구성된 대칭 n x n 행렬이며, 여기서 n은 노드의 수입니다."><img src="10-chap_files/figure-html/fig-adjmatrix-1.png" class="img-fluid"></a></p>
<p>그림 10.3: 그림 10.2에 표시된 그래프의 인접 행렬은 0과 1로 구성된 대칭 \(n n\) 행렬이며, 여기서 \(n\)은 노드의 수입니다.</p>
<p>__</p>
<p>질문 10.2</p>
<p>위의 질문 10.1의 답변에 나온 방법 외에, 에지 리스트 데이터 프레임으로부터 그래프를 생성하는 대안적인 방법을 제시할 수 있나요?</p>
<p>__</p>
<p>해결책</p>
<p>__</p>
<pre><code>edges = "1,3\n2,3\n3,4\n4,6\n4,5"
df = read.csv(textConnection(edges), header = FALSE)
sg = graph_from_data_frame(df, directed = FALSE)
sg __


IGRAPH 1467322 UN-- 6 5 -- 
+ attr: name (v/c)
+ edges from 1467322 (vertex names):
[1] 1--3 2--3 3--4 4--6 4--5</code></pre>
<p>일반적으로 여러분은 별도의 파일에서 출발-도착 표를 읽기 위해 <code>read.csv</code> 함수를 사용할 것입니다. 여기서는 예제를 더 간결하게 유지하기 위해 책의 저자들이 즉석에서 문자열 <code>edges</code>를 만들고 <code>textConnection</code> 함수를 사용하여 이를 파일과 동등하게 만들기로 결정했습니다. 표기법 <code>"\n"</code>은 줄바꿈을 나타냅니다.</p>
<section id="단순-그래프의-요소들" class="level4" data-number="12.1.1.1">
<h4 data-number="12.1.1.1" class="anchored" data-anchor-id="단순-그래프의-요소들"><span class="header-section-number">12.1.1.1</span> 단순 그래프의 요소들</h4>
<ul>
<li><p>노드 또는 정점. 이들은 그림 10.2에서 번호가 들어 있는 색칠된 원들입니다.</p></li>
<li><p>에지 또는 연결, 노드들을 잇는 세그먼트이며 방향이 있을 수도 있고 없을 수도 있습니다.</p></li>
<li><p>에지 속성(edge length 등). 별도로 지정되지 않으면 에지 길이는 모두 동일하게 대개 1이라고 가정합니다. 예를 들어, 그래프 상의 두 노드 사이의 거리를 계산하려면 최단 경로를 따라 에지들의 길이를 합산합니다.</p></li>
<li><p>에지 및 노드 속성: 선택적으로, 각 에지나 각 노드는 유형, 색상, 가중치, 에지 너비, 노드 크기 등과 같은 추가적인 연속형 또는 범주형 변수들에 매핑될 수 있습니다. 응용 분야와 의도된 계산에 따라 거의 모든 것이 가능합니다.</p></li>
</ul>
<p>우리는 또한 에지 길이가 있는 유향 그래프를 <strong>네트워크(network)</strong>라고 부릅니다. 네트워크의 인접 행렬은 에지 길이에 대응하는 양수들로 이루어진 \(nn\) 행렬입니다.</p>
</section>
<section id="기본-개념들" class="level4" data-number="12.1.1.2">
<h4 data-number="12.1.1.2" class="anchored" data-anchor-id="기본-개념들"><span class="header-section-number">12.1.1.2</span> 기본 개념들</h4>
<p>노드의 _차수(degree)_는 그 노드에 연결된 에지의 수입니다. 유향 그래프에서는 들어오는 에지와 나가는 에지에 대해 _진입 차수(in-degree)_와 _진출 차수(out-degree)_를 구분합니다. 또한 사이클(cycles)을 포함하는 유향 그래프와 그렇지 않은 그래프(순환 및 비순환 그래프라고 함)를 추가로 구분할 수 있습니다.</p>
<p>큰 그래프의 경우, 정점 차수의 분포를 살펴봄으로써 전체적인 그래프 구조를 요약할 수 있으며, 중심성(centrality)이나 매개 중심성(betweenness)과 같은 척도를 사용하여 그래프에서 특히 흥미로운 영역이나 특정 노드 및 에지를 식별할 수 있습니다. 이러한 척도들은 <strong><a href="https://cran.r-project.org/web/packages/network/">network</a></strong> , <strong><a href="https://cran.r-project.org/web/packages/igraph/">igraph</a></strong>와 같은 다양한 패키지에서 사용할 수 있습니다.</p>
<p>만약 에지의 수가 노드의 수와 같은 규모(order of magnitude)라면(\(#EO(#V)\)라고 씀), 우리는 그 그래프가 <strong>희소(sparse)</strong>하다고 말합니다. 일부 그래프는 노드가 매우 많습니다. 예를 들어, <strong><a href="https://bioconductor.org/packages/ppiData/">ppiData</a></strong> 패키지에는 약 20,000개의 에지를 가진 약 2,500개의 단백질에 대한 예측된 단백질 상호작용(<code>ppipred</code>) 그래프가 들어 있습니다1. 그러한 그래프에 대한 완전한 인접 행렬은 600만 개 이상의 메모리 단위를 필요로 하며, 그 중 대부분은 0을 포함합니다. 이는 불필요한 낭비입니다. 동일한 그래프의 에지 리스트 표현은 더 콤팩트합니다: 에지가 있는 곳에만 저장 공간을 사용하며, 우리 예제에서는 20,000개의 메모리 단위에 해당합니다. 에지 리스트 표현의 한 가지 구체적인 선택은 <strong><a href="https://cran.r-project.org/web/packages/Matrix/">Matrix</a></strong> 패키지에 구현된 것과 같은 희소 행렬 인코딩입니다.</p>
<p>1 유전자 및 종 계통수(phylogenies)는 이보다 훨씬 더 클 수도 있습니다.</p>
<p>반면에 <strong>조밀한(dense)</strong> 그래프에서는 에지의 수가 잠재적인 에지의 수, 즉 노드 수의 제곱(\(#EO(#V^2)\)라고 씀)과 같은 규모입니다. 크고 조밀한 그래프의 경우 저장 메모리 공간이 문제가 될 수 있습니다.</p>
</section>
<section id="그래프-레이아웃graph-layout" class="level4" data-number="12.1.1.3">
<h4 data-number="12.1.1.3" class="anchored" data-anchor-id="그래프-레이아웃graph-layout"><span class="header-section-number">12.1.1.3</span> 그래프 레이아웃(Graph layout)</h4>
<p>우리는 미적 또는 실무적인 이유로 동일한 그래프가 서로 다른 방식으로 그려지는 여러 예시를 보게 될 것입니다. 이는 <strong>그래프 레이아웃</strong>의 선택을 통해 이루어집니다.</p>
<p>에지가 거리를 나타내는 길이를 가질 때, 그래프의 2D 표현 문제는 <a href="09-chap.html">9장</a>에서 보았던 다차원 척도법과 동일합니다. 이는 종종 정점 지점들을 가능한 한 멀리 퍼뜨림으로써 유사한 방식으로 해결됩니다. 길이가 없는 에지의 단순한 경우, 알고리즘은 서로 다른 기준을 선택할 수 있습니다. 프루히터만과 라잉골드(Fruchterman and Reingold) 방법이 기본적인 선택입니다. 이는 마치 (뉴턴의) 물리적 힘의 영향을 받는 것처럼 유사한 점들이 서로 끌어당기고 밀어내는 물리 기반 모델에 기초합니다.</p>
<p>__</p>
<p>태스크</p>
<p><strong><a href="https://cran.r-project.org/web/packages/igraph/">igraph</a></strong> 패키지를 사용하여 다음을 수행하세요.</p>
<ul>
<li><p>12개의 노드와 50개 이상의 에지를 가진 조밀한 무작위 그래프를 만듭니다.</p></li>
<li><p>서로 다른 레이아웃으로 그래프를 그리는 실험을 해보세요: 노드들을 원형으로 배치하거나, 그래프를 가능한 한 대칭적으로 표현하고 노드나 에지가 겹치지 않게 해보세요.</p></li>
</ul>
</section>
<section id="데이터로부터의-그래프" class="level4" data-number="12.1.1.4">
<h4 data-number="12.1.1.4" class="anchored" data-anchor-id="데이터로부터의-그래프"><span class="header-section-number">12.1.1.4</span> 데이터로부터의 그래프</h4>
<p>대개 데이터는 그래프 형태로 도착하지 않습니다. 그래픽이나 네트워크 표현은 종종 다른 데이터 유형으로부터 변환된 결과입니다.</p>
<p><strong>거리나 유사성으로부터:</strong> 그래프는 거리나 유사성 관계를 이진화(binarising)함으로써 이를 단순화할 수 있습니다. 노드들이 비슷하거나 가까우면 연결하고, 그렇지 않으면 연결하지 않습니다. 따라서 입력값은 관심 있는 모든 객체 쌍(유전자, 단백질, 종, 표현형, \(…\)) 사이의 유사성 또는 거리 척도이며, 여기에 임계값(threshold)이 적용됩니다. 척도 세트는 조밀한 행렬로 구현되거나 즉석에서 계산될 수 있습니다.</p>
<p><strong>이분 그래프(Bipartite graphs):</strong> 일부 데이터는 갈라파고스 제도의 핀치새 종과 섬들(그림 10.4), 또는 전사 인자와 그들이 결합하는 것으로 간주되는 유전자 조절 영역 사이의 관계처럼 두 가지 유형의 객체 사이의 존재 또는 부재 관계로 자연스럽게 나타납니다. 그러한 관계는 직사각형 행렬에서 0/1 값으로 인코딩될 수 있으며, 여기서 행은 한 객체 유형을 나타내고 열은 다른 유형을 나타냅니다. 결과로 나오는 그래프는 두 가지 유형의 노드(예: 핀치새 노드와 섬 노드)를 가지며, 에지는 서로 다른 유형의 노드 사이에만 존재할 수 있습니다(예: 분류군과 섬 사이에는 존재하지만 분류군 사이나 섬 사이에는 존재하지 않음). 그림 10.4의 에지는 _~에 산다_는 관계를 나타냅니다.</p>
<p><a href="imgs/BipartiteTaxa.png" title="그림 10.4: 이 이분 그래프는 각 분류군을 그것이 관찰된 사이트들과 연결합니다."><img src="imgs/BipartiteTaxa.png" class="img-fluid"></a></p>
<p>그림 10.4: 이 <strong>이분(bipartite)</strong> 그래프는 각 분류군을 그것이 관찰된 사이트들과 연결합니다.</p>
<p>__</p>
<p>질문 10.3</p>
<p><code>finch.csv</code> 데이터를 불러오고, 이것이 이분 네트워크를 나타냄을 강조하도록 그리는 실험을 해보세요.</p>
<p>__</p>
<p>해결책</p>
<p>__</p>
<p>다음 코드의 출력은 그림 10.5에 나와 있습니다.</p>
<pre><code>finch = readr::read_csv("../data/finch.csv", comment = "#", col_types = "cc")
finch __


# A tibble: 122 × 2
   .tail .head             
   &lt;chr&gt; &lt;chr&gt;             
 1 C     Large ground finch
 2 D     Large ground finch
 3 E     Large ground finch
 4 F     Large ground finch
 5 G     Large ground finch
 6 H     Large ground finch
 7 I     Large ground finch
 8 J     Large ground finch
 9 L     Large ground finch
10 M     Large ground finch
# ℹ 112 more rows


library("network")
finch.nw  = as.network(finch, bipartite = TRUE, directed = FALSE)
is.island = nchar(network.vertex.names(finch.nw)) == 1
plot(finch.nw, vertex.cex = 2.5, displaylabels = TRUE, 
     vertex.col = ifelse(is.island, "forestgreen", "gold3"),
     label= sub(" finch", "", network.vertex.names(finch.nw)))
finch.nw |&gt; as.matrix() |&gt; t() |&gt; (\(x) x[, order(colnames(x))])()__


                          A B C D E F G H I J K L M N O P Q
Large ground finch        0 0 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1
Medium ground finch       1 1 1 1 1 1 1 1 1 1 0 1 0 1 1 0 0
Small ground finch        1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 0 0
Sharp-beaked ground finch 0 0 1 1 1 0 0 1 0 1 0 1 1 0 1 1 1
Cactus ground finch       1 1 1 0 1 1 1 1 1 1 0 1 0 1 1 0 0
Large cactus ground finch 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0
Large tree finch          0 0 1 1 1 1 1 1 1 0 0 1 0 1 1 0 0
Medium tree finch         0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0
Small tree finch          0 0 1 1 1 1 1 1 1 1 0 1 0 0 1 0 0
Vegetarian finch          0 0 1 1 1 1 1 1 1 1 0 1 0 1 1 0 0
Woodpecker finch          0 0 1 1 1 0 1 1 0 1 0 0 0 0 0 0 0
Mangrove finch            0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0
Warbler finch             1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1</code></pre>
<p><a href="10-chap_files/figure- html/fig-finches-1-1.png" title="Figure 10.5: The finches graph. There are many ways to improve the layout, including better taking into account the bipartite nature of the graph."><img src="10-chap_files/figure-html/fig-finches-1-1.png" class="img-fluid"></a></p>
<p>Figure 10.5: The <code>finches</code> graph. There are many ways to improve the layout, including better taking into account the bipartite nature of the graph.</p>
<p>__</p>
<p>Question 10.4</p>
<p>Make a plot of the graph <code>g1</code> using the <strong><a href="https://cran.r-project.org/web/packages/ggraph/">ggraph</a></strong> package, with a choice of layout and provided geoms such as <code>geom_edge_link</code>, <code>geom_node_point</code> and <code>geom_node_text</code>.</p>
<p>__</p>
<p>Solution</p>
<p>__</p>
<p>The output of the following code is shown in Figure 10.6.</p>
<pre><code>library("ggraph")
ggraph(g1, layout = "nicely") + 
  geom_edge_link() + 
  geom_node_point(size=6,color="#8856a7") + 
  geom_node_text(label=vertex_attr(g1)$name,  color="white")__</code></pre>
<p><a href="10-chap_files/figure-html/fig-ggnetworkong1-1-1.png &quot;Figure 10.6: A ggraph example.&quot;"><img src="10-chap_files/figure-html/fig- ggnetworkong1-1-1.png" class="img-fluid"></a></p>
<p>Figure 10.6: A <strong><a href="https://cran.r-project.org/web/packages/ggraph/">ggraph</a></strong> example.</p>
</section>
<section id="an-example-a-four-state-markov-chain" class="level4" data-number="12.1.1.5">
<h4 data-number="12.1.1.5" class="anchored" data-anchor-id="an-example-a-four-state-markov-chain"><span class="header-section-number">12.1.1.5</span> An example: a four state Markov chain</h4>
<p>In <a href="02-chap.html">Chapter 2</a>, we saw how a Markov chain can summarize transitions between nucleotides (considered the states of the system). This is often schematized by a graph. The <strong><a href="https://cran.r-project.org/web/packages/igraph/">igraph</a></strong> package provides many choices for graph “decoration”:</p>
<pre><code>library("markovchain")
statesNames = c("A", "C", "G","T")
T1MC = new("markovchain", states = statesNames, transitionMatrix =
  matrix(c(0.2,0.1,0.4,0.3,0,1,0,0,0.1,0.2,0.2,0.5,0.1,0.1,0.8,0.0),
         nrow = 4,byrow = TRUE, dimnames = list(statesNames, statesNames)))
plot(T1MC, edge.arrow.size = 0.4, vertex.color = "purple",
     edge.arrow.width = 2.2, edge.width = 5, edge.color = "blue",
     edge.curved = TRUE, edge.label.cex = 2.5, vertex.size= 32,
     vertex.label.cex = 3.5, edge.loop.angle = 3,
     vertex.label.family = "sans", vertex.label.color = "white")__</code></pre>
<p><a href="imgs/MarkovACGT.png" title="Figure 10.7: A four state Markov chain with arrows representing possible transitions between states."><img src="imgs/MarkovACGT.png" class="img-fluid"></a></p>
<p>Figure 10.7: A four state Markov chain with arrows representing possible transitions between states.</p>
<p>Markov chains are simple models of dynamical systems, and the states are represented by the nodes in the graph. The transition matrix gives us the weights on the <strong>directed</strong> edges (arrows) between the states.</p>
<p>__</p>
<p>Question 10.5</p>
<p>Which state do you think this Markov chain will end up in?</p>
<p>__</p>
<p>해결책</p>
<p>__</p>
<p>C를 제외한 모든 노드는 나가는 에지(outgoing edges)를 가지고 있으며, C는 들어오는 에지와 자기 자신으로 향하는 에지만을 가집니다. 따라서 C는 흡수 상태(absorbing state)입니다. 이 체인의 모든 프로세스는 조만간 C에 도달하여 머물게 됩니다.</p>
<p>__</p>
<p>태스크</p>
<ol type="1">
<li><p><code>set.seed</code> 함수의 입력값을 바꾸어 보고 플롯이 변하는지 확인해 보세요.</p></li>
<li><p>이 특정 <code>plot</code> 함수에 대한 도움말에 접속해 보세요.</p></li>
<li><p>그래프를 다시 그리고, 전이 확률(transition probabilities) 레이블은 녹색으로, 정점(vertices)은 갈색으로 표시해 보세요.</p></li>
</ol>
<p>연습 문제 10.3에서 어노테이션이 달린 상태 공간 마르코프 체인 그래프의 완전한 예시를 구축하는 방법을 살펴볼 것입니다.</p>
</section>
</section>
<section id="여러-레이어가-있는-그래프-에지와-노드의-레이블" class="level3" data-number="12.1.2">
<h3 data-number="12.1.2" class="anchored" data-anchor-id="여러-레이어가-있는-그래프-에지와-노드의-레이블"><span class="header-section-number">12.1.2</span> 10.2.2 여러 레이어가 있는 그래프: 에지와 노드의 레이블</h3>
<p>여기에 정점에 어노테이션이 달린, <a href="https://string-db.org">STRING</a> 데이터베이스에서 다운로드한 그래프를 그리는 예시가 있습니다.</p>
<pre><code>datf = read.table("../data/string_graph.txt", header = TRUE)
grs = graph_from_data_frame(datf[, c("node1", "node2")], directed = FALSE)
E(grs)$weight = 1
V(grs)$size = centr_degree(grs)$res
ggraph(grs) +
  geom_edge_arc(color = "black",  strength = 0.05, alpha = 0.8)+
  geom_node_point(size = 2.5, alpha = 0.5, color = "orange") +
  geom_node_label(aes(label=vertex_attr(grs)$name), size = 3, alpha = 0.9, color = "#8856a7", repel = TRUE) __</code></pre>
<p><a href="10-chap_files/figure-html/fig- completechemokine-1.png" title="그림 10.8: @YuGXNA에서 정렬된 T 세포의 차등 유전자 발현 패턴을 사용하여 발견된 섭동된 케모카인 하위 네트워크. 오른쪽 모서리에 있는 CXCR3, CXCL13, CCL19, CSCR5 및 CCR7 유전자의 클릭(clique)과 유사한 구조에 주목하세요."><img src="10-chap_files/figure-html/fig- completechemokine-1.png" class="img-fluid"></a></p>
<p>그림 10.8: Yu 등 (<a href="16-chap.html#ref-YuGXNA">2012</a>)에서 정렬된 T 세포의 차등 유전자 발현 패턴을 사용하여 발견된 섭동된 케모카인 하위 네트워크. 오른쪽 모서리에 있는 CXCR3, CXCL13, CCL19, CSCR5 및 CCR7 유전자의 클릭(clique)과 유사한 구조에 주목하세요.</p>
<p>그림 10.8은 (<a href="16-chap.html#ref-GXNA">Nacu et al.&nbsp;2007</a>)에서 GXNA를 사용하여 유방암 전이 연구에서 발견되고 Yu 등 (<a href="16-chap.html#ref-YuGXNA">2012</a>)에 의해 보고된 전체 섭동 케모카인 하위 네트워크를 보여줍니다.</p>
</section>
</section>
<section id="유전자-세트-농축에서-네트워크로" class="level2" data-number="12.2">
<h2 data-number="12.2" class="anchored" data-anchor-id="유전자-세트-농축에서-네트워크로"><span class="header-section-number">12.2</span> 10.3 유전자 세트 농축에서 네트워크로</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="imgs/devil.png" title="차등 발현될 가능성이 있는 유전자들의 길고 구조화되지 않은 세탁물 리스트(laundry list)는 위협적일 수 있습니다."><img src="imgs/devil.png" class="img-fluid figure-img"></a></p>
<figcaption>차등 발현될 가능성이 있는 유전자들의 길고 구조화되지 않은 세탁물 리스트(laundry list)는 위협적일 수 있습니다.</figcaption>
</figure>
</div>
<p>차등 발현될 가능성이 있는 유전자들의 길고 구조화되지 않은 세탁물 리스트(laundry list)는 위협적일 수 있습니다.</p>
<p><a href="08-chap.html">8장</a>에서 우리는 차등 발현된 유전자 리스트를 찾는 방법들을 공부했습니다. 적은 표본 크기와 낮은 FDR을 유지하려는 노력은 종종 차등 발현을 감지하는 낮은 검정력으로 이어집니다. 따라서 차등 발현된 것으로 자신 있게 선언할 수 있는 긴 유전자 리스트를 얻는 것은 초기에는 승리입니다. 그러나 기저의 생물학을 이해하려면 생물학적 시스템에서 유의미한 행위자들의 단순한 리스트 이상의 것이 필요합니다.</p>
<section id="사전-정의된-유전자-세트를-사용하는-방법gsea" class="level3" data-number="12.2.1">
<h3 data-number="12.2.1" class="anchored" data-anchor-id="사전-정의된-유전자-세트를-사용하는-방법gsea"><span class="header-section-number">12.2.1</span> 10.3.1 사전 정의된 유전자 세트를 사용하는 방법(GSEA)</h3>
<p>가장 초기 접근 방식 중 하나는 유의미한 유전자 리스트에서 <strong>과다하게 나타나거나(overrepresented)</strong> <strong>농축된(enriched)</strong> 유전자 속성을 찾는 것이었습니다. 이러한 유전자 클래스들은 종종 유전자 온톨로지(Gene Ontology, GO) 범주에 기반합니다(예: 기관 성장에 관여하는 유전자, 또는 섭식 행동에 관여하는 유전자). 유전자 온톨로지(GO)는 유전자와 유전자 산물을 설명하는 세 가지 온톨로지의 모음입니다. 이러한 온톨로지들은 유향 비순환 그래프(DAGS) 구조를 가진 제한된 어휘들입니다. 가장 구체적인 용어들이 그래프의 잎(leaves)이 됩니다. GO 그래프는 노드(여기서는 유전자 온톨로지 용어)와 더 구체적인 용어(자식)에서 덜 구체적인 용어(부모)로 가는 에지들로 구성되며, 흔히 이러한 에지들은 방향성이 있습니다. 노드와 에지는 시각화될 수 있는 여러 속성을 가질 수 있습니다. 실험에서 유의미한 것으로 지정된 특정 유전자 세트에 대해 GO 어노테이션을 사용하는 주된 목적은 이 리스트에서 특정 GO 용어의 <strong>농축(enrichment)</strong>을 찾는 것이며, 우리는 아래에서 이 용어에 통계적 의미를 부여할 것입니다. 다른 많은 유용한 중요 유전자 세트 리스트들이 존재합니다.</p>
<p>__</p>
<p>태스크</p>
<p>유용한 유전자 세트 데이터베이스를 찾아보세요.</p>
<p>예를 들어, <code>MsigDB</code> 분자 시그니처 데이터베이스(<a href="16-chap.html#ref-MSigDB">Liberzon et al.&nbsp;2011</a>)에는 많은 유전자 세트가 포함되어 있으며, 이는 Bioconductor 패키지 <strong><a href="https://bioconductor.org/packages/GSEABase/">GSEABase</a></strong>의 <code>getBroadSets</code> 함수를 사용하여 R 내부에서 대략 다음과 같이 액세스할 수 있습니다:</p>
<pre><code>library("GSEABase")
## 웹사이트 로그인이 필요합니다.
fl   =  "/path/to/msigdb_v5.1.xml"
gss  =  getBroadSets(fl) 
organism(gss[[1]])
table(sapply(gss, organism))__</code></pre>
</section>
<section id="원-분할표-검정을-이용한-유전자-세트-분석" class="level3" data-number="12.2.2">
<h3 data-number="12.2.2" class="anchored" data-anchor-id="원-분할표-검정을-이용한-유전자-세트-분석"><span class="header-section-number">12.2.2</span> 10.3.2 2원 분할표 검정을 이용한 유전자 세트 분석</h3>
<p>표 10.1: <em>유의미한</em> 세트에서 각 범주의 유전자 수가 동일하더라도, 아래의 시뮬레이션과 2원 분할표(two-way tables)의 검정 이론은 모두 파란색 범주가 농축되었음을 보여줍니다.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>노란색</th>
<th>파란색</th>
<th>빨간색</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>유의미함</td>
<td>25</td>
<td>25</td>
<td>25</td>
</tr>
<tr class="even">
<td>전체(Universe)</td>
<td>500</td>
<td>100</td>
<td>400</td>
</tr>
</tbody>
</table>
<p>여기서는 흔히 <strong>피셔의 “정확” 검정(Fisher’s “exact” test)</strong> 또는 <strong>초기하 검정(hypergeometric test)</strong>이라 불리는 기본적인 접근 방식을 설명하는 것부터 시작하겠습니다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="imgs/devil.png" title="소위 '정확' 검정이라고 불리는 이유는 비모수적이며 전수 조사(exhaustive enumerations)에 기반하기 때문이지, 답이 확실하기 때문은 아닙니다. 결국 이것은 통계학이니까요."><img src="imgs/devil.png" class="img-fluid figure-img"></a></p>
<figcaption>소위 ‘정확’ 검정이라고 불리는 이유는 비모수적이며 전수 조사(exhaustive enumerations)에 기반하기 때문이지, 답이 확실하기 때문은 아닙니다. 결국 이것은 통계학이니까요.</figcaption>
</figure>
</div>
<p>소위 ‘정확’ 검정이라고 불리는 이유는 비모수적이며 전수 조사(exhaustive enumerations)에 기반하기 때문이지, 답이 확실하기 때문은 <strong>아닙니다</strong>. 결국 이것은 통계학이니까요.</p>
<p>잠재적으로 유의미할 수 있는 후보 유전자들의 전체 집합(universe)을 정의하십시오; 이 유니버스의 크기를 \(N\)이라고 합시다. 우리는 또한 실제로 유의미하게 <strong>나타난</strong> 유전자들의 기록을 가지고 있는데, 그 수가 \(m\)개라고 가정해 봅시다.</p>
<p>우리는 유전자 유니버스에서 식별된 유전자들에 대응하는 총 \(N\)개의 공이 상자 안에 들어 있는 장난감 모델을 만듭니다. 이 유전자들은 서로 다른 기능적 범주로 나뉘어 있습니다. \(N=1,000\)개의 유전자가 있고 그중 500개는 노란색, 100개는 파란색, 400개는 빨간색이라고 가정해 봅시다. 그런 다음 \(m=75\)개의 유전자 하위 집합에 <strong>유의미함(significant)</strong>이라는 레이블이 붙습니다. 이 유의미하게 흥미로운 유전자들 중에 노란색 25개, 빨간색 25개, 파란색 25개가 있다고 가정합시다. 파란색 범주가 농축되었거나 과다하게 나타났다고 할 수 있을까요?</p>
<p>우리는 일부 범주는 매우 수가 많고 다른 범주는 드물다는 사실을 고려하기 위해 이 초기하 2원 분할표 검정을 사용합니다.</p>
<p>__</p>
<p>질문 10.6</p>
<p>20,000번의 시뮬레이션을 통해 몬테카를로 실험을 실행하고, 유의미한 세트에서 어떤 범주도 과다하게 나타나지 않는다는 귀무 가설하에서 파란색이 25개일 때의 유의성 p-값을 계산하세요.</p>
<p>__</p>
<p>해결책</p>
<p>__</p>
<p>귀무 가설하에서 75개는 다음과 같이 우리의 균등하지 않은 상자들로부터 무작위로 샘플링됩니다:</p>
<pre><code>universe = c(rep("Yellow", 500), rep("Blue", 100), rep("Red", 400))
countblue = replicate(20000, {
  pick75 = sample(universe, 75, replace = FALSE)
  sum(pick75 == "Blue")
})
summary(countblue)__


   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  0.000   6.000   7.000   7.496   9.000  20.000 </code></pre>
<p>그림 10.9의 히스토그램은 귀무 모델하에서 25만큼 큰 값을 갖는 것이 매우 드물 것임을 보여줍니다.</p>
<p><a href="10-chap_files/figure- html/fig-histblue-1.png" title="그림 10.9: 20,000번의 시뮬레이션에서도 파란색 카운트가 25에 근접하는 경우가 없음을 볼 수 있습니다. 우리는 그러한 사건이 우연히 일어났을 가능성을 기각하고 파란색이 농축되었다고 결론 내릴 수 있습니다."><img src="10-chap_files/figure-html/fig-histblue-1.png" class="img-fluid"></a></p>
<p>그림 10.9: 20,000번의 시뮬레이션에서도 파란색 카운트가 25에 근접하는 경우가 없음을 볼 수 있습니다. 우리는 그러한 사건이 우연히 일어났을 가능성을 기각하고 파란색이 <strong>농축되었다</strong>고 결론 내릴 수 있습니다.</p>
<p>일반적인 경우, 유전자 유니버스는 \(N\)개의 공이 들어 있는 항아리이며, 만약 우리가 \(m\)개의 공을 무작위로 뽑고 파란색 공의 비율이 \(k/N\)이라면, \(k\)개 크기의 추출에서 \(km/N\)개의 파란색 공을 볼 것으로 기대합니다.</p>
<section id="goplot을-이용한-유전자-농축-네트워크-플로팅" class="level4" data-number="12.2.2.1">
<h4 data-number="12.2.2.1" class="anchored" data-anchor-id="goplot을-이용한-유전자-농축-네트워크-플로팅"><span class="header-section-number">12.2.2.1</span> <strong><a href="https://cran.r-project.org/web/packages/GOplot/">GOplot</a></strong>을 이용한 유전자 농축 네트워크 플로팅</h4>
<p>여기서는 유전자 기능 범주와 유의미한 유전자 세트 사이의 연결을 요약하는 매력적인 방법을 보여줍니다.</p>
<pre><code>library("GOplot")
data("EC")
circ  =  circle_dat(EC$david, EC$genelist)
chord =  chord_dat(circ, EC$genes, EC$process)
GOChord(chord, limit = c(0, 5))__</code></pre>
<p><a href="10-chap_files/figure- html/fig-GOplotEC-1.jpeg" title="그림 10.10: 이 그래프는 두 가지 정상 상태 조직(뇌와 심장, @Nolan:2013 참조)의 내피 세포에서의 차등 발현 연구에서 GO 용어와 유의미하게 변한 유전자 사이의 대응 관계를 보여줍니다. 정규화 후 차등 발현 분석이 수행되어 유전자 리스트를 얻었습니다. 그 다음 GOplot 패키지를 사용하여 차등 발현된 유전자 세트(조정된 p-값 < 0.05)에 대한 유전자 어노테이션 농축 분석을 수행했습니다."><img src="10-chap_files/figure-html/fig-GOplotEC-1.jpeg" class="img-fluid"></a></p>
<p>그림 10.10: 이 그래프는 두 가지 정상 상태 조직(뇌와 심장, Nolan 등 (<a href="16-chap.html#ref-Nolan:2013">2013</a>) 참조)의 내피 세포에서의 차등 발현 연구에서 GO 용어와 유의미하게 변한 유전자 사이의 대응 관계를 보여줍니다. 정규화 후 차등 발현 분석이 수행되어 유전자 리스트를 얻었습니다. 그 다음 <strong><a href="https://cran.r-project.org/web/packages/GOplot/">GOplot</a></strong> 패키지를 사용하여 차등 발현된 유전자 세트(조정된 p-값 &lt; 0.05)에 대한 유전자 어노테이션 농축 분석을 수행했습니다.</p>
<p>사실, 유전자 온톨로지 그래프는 서로 다른 프로세스의 유전자들이 종종 생산적으로 상호작용하기 때문에 의미 있는 _유전자 상호작용_을 반드시 캡처하는 것은 아닙니다. 많은 양의 정보가 사용되지 않은 채로 남아 있는데, 예를 들어 모든 유의미한 유전자는 p-값의 잠재적으로 큰 변동에도 불구하고 보통 동일한 가중치가 부여됩니다.</p>
</section>
</section>
<section id="유의미한-하위-그래프-및-고득점-모듈" class="level3" data-number="12.2.3">
<h3 data-number="12.2.3" class="anchored" data-anchor-id="유의미한-하위-그래프-및-고득점-모듈"><span class="header-section-number">12.2.3</span> 10.3.3 유의미한 하위 그래프 및 고득점 모듈</h3>
<p>우리는 유전자 온톨로지 이상의 것을 마음대로 사용할 수 있습니다. 유전자 네트워크의 다양한 데이터베이스가 있으며, 그중에서 우리의 차등 발현 실험에서 얻은 p-값과 같은 유의성 점수를 투영할 <strong>알려진 골격(skeleton)</strong> 그래프를 선택할 수 있습니다. 우리는 Ideker 등 (<a href="16-chap.html#ref-Ideker:2002">2002</a>)이 처음 제안한 아이디어를 따를 것입니다. 이는 Nacu 등 (<a href="16-chap.html#ref-GXNA">2007</a>)에서 더 발전되었습니다. 많은 개선 사항이 포함된 세심한 구현체는 Bioconductor 패키지 <strong><a href="https://bioconductor.org/packages/BioNet/">BioNet</a></strong> (<a href="16-chap.html#ref-BioNet">Beisser et al.&nbsp;2010</a>)으로 제공됩니다. 이러한 방법들은 모두 점수가 매겨진 골격 네트워크에서 특히 <strong>섭동된</strong> 것으로 보이는 하위 그래프나 모듈을 검색합니다.</p>
<p>네트워크의 각 유전자 노드에는 t-통계량이나 p-값으로부터 계산된 점수가 할당됩니다. 종종 경로(pathways)는 상향 조절된 유전자와 하향 조절된 유전자를 모두 포함하는데, Ideker 등 (<a href="16-chap.html#ref-Ideker:2002">2002</a>)에서 지적했듯이, 이는 검정 통계량의 절대값을 취하거나 p-값으로부터 계산된 점수를 통합함으로써 캡처될 수 있습니다2. Beisser 등 (<a href="16-chap.html#ref-BioNet">2010</a>)은 <a href="06-chap.html">6장</a>에서 했던 것처럼 유전자의 p-값을 모델링합니다: p-값이 균등하게 분포할 섭동되지 않은 유전자와, 섭동된 유전자로부터 나온 균등하지 않게 분포된 p-값의 혼합물입니다. 우리는 Pounds와 Morris (<a href="16-chap.html#ref-Pounds2003">2003</a>)를 따라 p-값에 대해 베타 분포를 사용하여 데이터의 신호를 모델링합니다.</p>
<p>2 작은 p-값이 큰 점수를 주도록 \(-p\)와 같은 것이 필요할 것입니다.</p>
<p>노드 점수 함수가 주어지면, 그래프에서 연결된 핫스팟, 즉 높은 결합 점수를 가진 유전자들의 하위 그래프를 검색합니다.</p>
<section id="하위-그래프-검색-알고리즘-사용하기" class="level4" data-number="12.2.3.1">
<h4 data-number="12.2.3.1" class="anchored" data-anchor-id="하위-그래프-검색-알고리즘-사용하기"><span class="header-section-number">12.2.3.1</span> 하위 그래프 검색 알고리즘 사용하기</h4>
<p>일반적인 그래프의 최대 점수 하위 그래프를 찾는 것은 일반적으로 다루기 힘든(intractable) 것으로 알려져 있으므로(NP-어렵 문제라고 함), 다양한 근사 알고리즘이 제안되었습니다. Ideker 등 (<a href="16-chap.html#ref-Ideker:2002">2002</a>)은 시뮬레이티드 어닐링(simulated annealing) 사용을 제안했지만, 이는 속도가 느리고 해석하기 어려운 큰 하위 그래프를 생성하는 경향이 있습니다. Nacu 등 (<a href="16-chap.html#ref-GXNA">2007</a>)은 시드 정점에서 시작하여 그 주변을 점진적으로 확장했습니다. Beisser 등 (<a href="16-chap.html#ref-BioNet">2010</a>)은 소위 최소 신장 트리(MST)를 사용하여 검색을 시작했는데, 이 그래프는 이 장의 뒷부분에서 공부할 것입니다.</p>
</section>
</section>
<section id="bionet-구현-예시" class="level3" data-number="12.2.4">
<h3 data-number="12.2.4" class="anchored" data-anchor-id="bionet-구현-예시"><span class="header-section-number">12.2.4</span> 10.3.4 BioNet 구현 예시</h3>
<p>방법을 설명하기 위해 <strong><a href="https://bioconductor.org/packages/BioNet/">BioNet</a></strong> 패키지의 데이터를 보여줍니다.</p>
<p><code>interactome</code> 데이터는 2,034개의 서로 다른 유전자 산물과 8,399개의 상호작용으로 구성된 네트워크의 연결 성분(connected component)을 포함합니다. 이것이 우리가 작업할 골격 그래프를 구성합니다 (Beisser et al.&nbsp;(<a href="16-chap.html#ref-BioNet">2010</a>) 참조).</p>
<p><code>dataLym</code>은 3,583개 유전자에 대한 관련 p-값과 \(t\) 통계량을 포함하며, 다음과 같이 액세스하여 분석을 수행할 수 있습니다:</p>
<pre><code>library("BioNet")
library("DLBCL")
data("dataLym")
data("interactome")
interactome __


A graphNEL graph with undirected edges
Number of Nodes = 9386 
Number of Edges = 36504 


pval = dataLym$t.pval
names(pval)  =  dataLym$label
subnet = subNetwork(dataLym$label, interactome)
subnet = rmSelfLoops(subnet)
subnet __


A graphNEL graph with undirected edges
Number of Nodes = 2559 
Number of Edges = 7788 </code></pre>
<section id="베타-균등-모델-적합시키기-fit-a-beta-uniform-model" class="level4" data-number="12.2.4.1">
<h4 data-number="12.2.4.1" class="anchored" data-anchor-id="베타-균등-모델-적합시키기-fit-a-beta-uniform-model"><span class="header-section-number">12.2.4.1</span> 베타-균등 모델 적합시키기 (Fit a Beta-Uniform model)</h4>
<p>p-값은 <a href="04-chap.html">4장</a>에서 공부한 혼합 모델 유형으로 적합됩니다. 여기에는 확률 (_0)을 갖는 귀무 가설의 균등 성분과 대립 가설에 해당하는 p-값에 대한 베타 분포((a x^{a - 1})에 비례)가 포함됩니다 (<a href="16-chap.html#ref-Pounds2003">Pounds and Morris 2003</a>). [f(x|a,_0)= _0 + (1-_0) a x^{a - 1} 0 &lt;x ; ; 0&lt;a&lt;1] [fdr]을 0.001로 설정하여 모델을 실행합니다:</p>
<p>패키지는 실제로 (_0)에 다른 이름을 부여합니다: ()를 사용하고 이를 혼합 매개변수(mixing parameter)라고 부릅니다.</p>
<pre><code>fb = fitBumModel(pval, plot = FALSE)
fb __


Beta-Uniform-Mixture (BUM) model

3583 pvalues fitted

Mixture parameter (lambda): 0.482
shape parameter (a):        0.180
log-likelihood:         4471.8


scores=scoreNodes(subnet, fb, fdr = 0.001)__</code></pre>
<p><a href="10-chap_files/figure- html/fig-plotFITBum-1.png" title="그림 10.11: qqplot은 데이터에 대한 베타-균등 혼합 모델 적합의 품질을 보여줍니다. 빨간색 점은 베타 분포의 이론적 분위수를 x 좌표로, 관측된 분위수를 y 좌표로 가집니다. 파란색 선은 이 모델이 잘 들어맞음을 보여줍니다."><img src="10-chap_files/figure-html/fig-plotFITBum-1.png" class="img-fluid"></a></p>
<p>그림 10.11: qqplot은 데이터에 대한 베타-균등 혼합 모델 적합의 품질을 보여줍니다. 빨간색 점은 베타 분포의 이론적 분위수를 x 좌표로, 관측된 분위수를 y 좌표로 가집니다. 파란색 선은 이 모델이 잘 들어맞음을 보여줍니다.</p>
<p><a href="10-chap_files/figure- html/fig-histFITBum-1.png" title="그림 10.12: p-값에 대한 혼합 성분의 히스토그램입니다. 베타 분포는 빨간색, 균등 분포는 파란색으로 표시됩니다. \pi_0는 분포가 균등해야 하는 귀무 성분에 할당된 혼합 비율입니다."><img src="10-chap_files/figure-html/fig-histFITBum-1.png" class="img-fluid"></a></p>
<p>그림 10.12: p-값에 대한 혼합 성분의 히스토그램입니다. 베타 분포는 빨간색, 균등 분포는 파란색으로 표시됩니다. \(_0\)는 분포가 균등해야 하는 귀무 성분에 할당된 혼합 비율입니다.</p>
<p>그 다음 다음을 사용하여 고득점 하위 그래프에 대한 휴리스틱 검색을 실행합니다:</p>
<pre><code>hotSub  =  runFastHeinz(subnet, scores)
hotSub __


A graphNEL graph with undirected edges
Number of Nodes = 144 
Number of Edges = 221 


logFC=dataLym$diff
names(logFC)=dataLym$label __</code></pre>
<p>__</p>
<p>질문 10.7</p>
<p>다음 코드를 사용하여 그림 10.13을 만들었습니다:</p>
<pre><code>plotModule(hotSub, layout = layout.davidson.harel, scores = scores,
                  diff.expr = logFC)__</code></pre>
<p><a href="10-chap_files/figure- html/fig-plotBioNet-1.png" title="그림 10.13: ABC와 GCB B세포 림프종 사이의 차등 발현에 대해 최대로 농축된 것으로 찾아진 하위 그래프입니다. 노드는 빨간색과 초록색으로 칠해져 있습니다: 초록색은 ACB에서의 상향 조절을, 빨간색은 GBC에서의 상향 조절을 나타냅니다. 노드의 모양은 점수를 나타냅니다: 직사각형은 음수 점수를, 원은 양수 점수를 나타냅니다."><img src="10-chap_files/figure-html/fig-plotBioNet-1.png" class="img-fluid"></a></p>
<p>그림 10.13: ABC와 GCB B세포 림프종 사이의 차등 발현에 대해 최대로 농축된 것으로 찾아진 하위 그래프입니다. 노드는 빨간색과 초록색으로 칠해져 있습니다: 초록색은 ACB에서의 상향 조절을, 빨간색은 GBC에서의 상향 조절을 나타냅니다. 노드의 모양은 점수를 나타냅니다: 직사각형은 음수 점수를, 원은 양수 점수를 나타냅니다.</p>
<p><code>igraph.from.graphNEL</code> 함수를 사용하여 모듈 객체를 변환하고 섹션 10.2.2에 표시된 <strong><a href="https://cran.r-project.org/web/packages/ggraph/">ggraph</a></strong> 방법을 사용하여 플로팅하세요.</p>
</section>
</section>
</section>
<section id="계통수-phylogenetic-trees" class="level2" data-number="12.3">
<h2 data-number="12.3" class="anchored" data-anchor-id="계통수-phylogenetic-trees"><span class="header-section-number">12.3</span> 10.4 계통수 (Phylogenetic Trees)</h2>
<p><a href="imgs/SameTreePhyl.png" title="그림 10.14: 수학적 객체로서, 계층적 클러스터링 트리(sec-clustering에서 연구됨)는 계통수와 동일합니다. 이들은 팁에 레이블이 있는 뿌리가 있는 이진 트리입니다."><img src="imgs/SameTreePhyl.png" class="img-fluid"></a></p>
<p>그림 10.14: 수학적 객체로서, 계층적 클러스터링 트리(<a href="05-chap.html">5장</a>에서 연구됨)는 계통수와 동일합니다. 이들은 팁에 레이블이 있는 <strong>뿌리가 있는 이진(rooted binary)</strong> 트리입니다.</p>
<p>생물학에서 그래프의 정말 중요한 용도 중 하나는 계통수를 구축하는 것입니다. 트리는 <strong>사이클(cycles)</strong>(셀프 루프나 여러 정점을 거치는 루프를 일컫는 공식 용어)이 없는 그래프입니다. 계통수는 보통 팁에 있는 현대의3 분류군(taxa)에 해당하는 잎(leaves)에만 레이블이 있는 뿌리가 있는 이진 트리입니다. 내부 노드는 팁에 있는 <strong>현대(contemporaneous)</strong> 데이터로부터 추론되어야 하는 <strong>조상(ancestral)</strong> 서열에 해당합니다. 많은 방법들이 서로 다른 종이나 집단에서 얻은 정렬된 DNA 서열을 사용하여 트리를 추론하거나 추정합니다. 트리의 팁은 보통 <strong>OTU</strong>(Operational Taxonomic Units)라고 불립니다. 이러한 분석에서 관심 있는 통계적 <strong>매개변수(parameter)</strong>는 잎에 OTU 레이블이 있는 뿌리가 있는 이진 트리입니다 (자세한 내용은 Holmes (<a href="16-chap.html#ref-holmesima">1999</a>, <a href="16-chap.html#ref-holmes2003b">2003b</a>)를 참조하세요).</p>
<p>3 현대적이기 때문에, 트리는 종종 잎들이 모두 뿌리에서 같은 거리에 있도록 표현됩니다.</p>
<section id="hiv의-예" class="level4" data-number="12.3.0.1">
<h4 data-number="12.3.0.1" class="anchored" data-anchor-id="hiv의-예"><span class="header-section-number">12.3.0.1</span> HIV의 예</h4>
<p><a href="imgs/hivtreeplos.png" title="그림 10.15: 이 계통수는 아프리카에서의 서로 다른 HIV/SIV 균주의 역사를 설명합니다 [@Wertheim:2009], [그림 출처]."><img src="imgs/hivtreeplos.png" class="img-fluid"></a></p>
<p>그림 10.15: 이 계통수는 아프리카에서의 서로 다른 HIV/SIV 균주의 역사를 설명합니다 (<a href="16-chap.html#ref-Wertheim:2009">Wertheim and Worobey 2009</a>), [그림 출처].</p>
<p>HIV는 매우 빠르게 진화함으로써(수개월 내에 여러 돌연변이가 나타날 수 있음) 스스로를 보호하는 바이러스입니다. 따라서 그 진화는 실시간으로 추적될 수 있는 반면, 대형 유기체의 진화는 수백만 년에 걸쳐 일어났습니다. HIV 트리는 약물 내성 탐지 및 이해와 같은 의료 목적으로 구축됩니다. 이들은 개별 유전자에 대해 추정됩니다. 서로 다른 유전자는 진화 역사에서 차이를 보일 수 있으며 따라서 서로 다른 <strong>유전자 트리(gene trees)</strong>를 생성할 수 있습니다. 그림 10.15의 계통수는 바이러스가 원숭이에서 인간으로 옮겨간 시기를 보여줍니다 (<a href="16-chap.html#ref-Wertheim:2009">Wertheim and Worobey 2009</a>).</p>
</section>
<section id="계통수의-특별한-요소들" class="level4" data-number="12.3.0.2">
<h4 data-number="12.3.0.2" class="anchored" data-anchor-id="계통수의-특별한-요소들"><span class="header-section-number">12.3.0.2</span> 계통수의 특별한 요소들</h4>
<ul>
<li><p>대부분의 계통수는 뿌리가 있는 것으로 표시되며, <code>뿌리(root)</code>는 나중에 보게 되겠지만 보통 트리의 팁에 외집단(outgroup)을 포함시킴으로써 찾아집니다.</p></li>
<li><p>이 공통 조상으로부터 유래된 형질을 상동(homologous)이라고 합니다(집단 연구를 수행하는 유전학자들은 상동이라는 용어 대신 가계에 의한 동일성(identity by descent, IBD)으로 대체합니다).</p></li>
<li><p>공통 조상에 의해 정의된 트리의 자매들을 분기군(clades) 또는 단계통군(monophyletic groups)이라고 하며, 이들은 단순한 <em>유사성</em> 이상의 공통점을 가집니다.</p></li>
</ul>
</section>
<section id="진화를-위한-마르코프-모델-markovian-models-for-evolution" class="level3" data-number="12.3.1">
<h3 data-number="12.3.1" class="anchored" data-anchor-id="진화를-위한-마르코프-모델-markovian-models-for-evolution"><span class="header-section-number">12.3.1</span> 10.4.1 진화를 위한 마르코프 모델 (Markovian models for evolution)</h3>
<p>현대 데이터로부터 조상 종에서 일어난 일을 추론하기 위해, 우리는 시간이 지남에 따라 치환(substitutions)과 삭제(deletions)가 어떻게 발생하는지에 대한 가정을 세워야 합니다. 우리가 사용하는 모델은 모두 마르코프 모델이며 시간 동질적(time homogeneous)이라고 합니다. 즉, 돌연변이율이 역사 전반에 걸쳐 일정합니다.</p>
<p><a href="imgs/devil.png" title="이것을 분자 시계 가설이라고 합니다. 만약 이 가정을 하지 않는다면 비식별성(non-identifiability) 문제에 직면하게 됩니다 (즉, 관측된 데이터가 주어졌을 때 가능한 많은 돌연변이 역사들 사이의 차이를 말할 수 없습니다)."><img src="imgs/devil.png" class="img-fluid"></a></p>
<p>이것을 <strong>분자 시계(molecular clock)</strong> 가설이라고 합니다. 만약 이 가정을 하지 않는다면 비식별성(non-identifiability) 문제에 직면하게 됩니다 (즉, 관측된 데이터가 주어졌을 때 가능한 많은 돌연변이 역사들 사이의 차이를 말할 수 없습니다).</p>
<section id="연속-마르코프-체인과-생성-행렬-generator-matrix" class="level4" data-number="12.3.1.1">
<h4 data-number="12.3.1.1" class="anchored" data-anchor-id="연속-마르코프-체인과-생성-행렬-generator-matrix"><span class="header-section-number">12.3.1.1</span> 연속 마르코프 체인과 생성 행렬 (Generator matrix)</h4>
<p>우리는 그림 10.7에서 본 [A, C, G, T] 상태에 대한 마르코프 체인을 사용할 것입니다. 그러나 이제는 상태의 변화, 즉 돌연변이가 무작위 시간에 발생한다고 가정합니다. 이러한 돌연변이 사건 사이의 간격은 지수 분포를 따를 것입니다. 이러한 연속 시간 마르코프 체인은 다음과 같은 속성을 가집니다:</p>
<ul>
<li><p><strong>기억 없음(No Memory)</strong>. (P(Y(u+t)=j;|;Y(t)=i))는 (t) 이전의 시간에 의존하지 않습니다.</p></li>
<li><p><strong>시간 동질성(Time homogeneity)</strong>. 확률 (P(Y(h+t)=j,|,Y(t)=i))는 (t)에 의존하지 않고, 사건 사이의 시간인 (h)와 (i) 및 (j)에 의존합니다.</p></li>
<li><p><strong>선형성(Linearity)</strong>. 순간 전이율은 대략 선형 형태입니다.</p></li>
</ul>
<p><a href="imgs/devil.png" title="여기서 o(h)라고 쓴 오차항을 사용합니다. 이것은 리틀 o 오브 h라고 읽으며, 이 오차항이 h보다 훨씬 느리게(즉, 하위 선형으로) 커진다는 것을 의미합니다."><img src="imgs/devil.png" class="img-fluid"></a></p>
<p>여기서 (o(h))라고 쓴 오차항을 사용합니다. 이것은 리틀 (o) 오브 (h)라고 읽으며, 이 오차항이 (h)보다 훨씬 느리게(즉, 하위 선형으로) 커진다는 것을 의미합니다.</p>
<p>[ <span class="math display">\[\begin{align} P_{ij}(h)&amp;=q_{ij}h+o(h), \quad\text{for }j\neq i\\
P_{ii}(h)&amp;=1-q_i(h)+ o(h), \qquad\text{where }q_i=\sum_{j\neq i}q_{ij}.
\end{align}\]</span> ]</p>
<p>(q_{ij})는 순간 전이율(instantaneous transition rate)로 알려져 있습니다. 이러한 비율은 표 10.2와 같은 행렬을 정의합니다.</p>
<pre><code>  * **지수 분포(Exponential distribution)**. 변화 사이의 시간은 지수 분포를 따른다고 가정합니다.</code></pre>
<table class="caption-top">
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th>(Q = </th>
<th>(Q = </th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>표 10.2: 두 가지 전이율 행렬의 예입니다. 왼쪽은 Jukes-Cantor(<code>JC69</code>) 모델이고, 오른쪽은 Kimura(<code>K80</code>) 2-매개변수 모델을 보여줍니다.</p>
<p><strong>생성기(generator)</strong>라고 불리는 순간 변화 확률 행렬입니다. 가장 단순한 모델인 Jukes-Cantor 모델에서는 모든 돌연변이가 동일하게 발생할 가능성이 있습니다 (표 10.2의 왼쪽 참조). 좀 더 유연한 모델인 Kimura 모델은 표 10.2의 오른쪽에 나와 있습니다.</p>
<p>__</p>
<p>질문 10.8</p>
<p>왜 Kimura 모델이 더 유연하다고 말할까요?</p>
<p>__</p>
<p>해결책</p>
<p>__</p>
<p>Jukes-Cantor 모델은 하나의 매개변수만 가지며, 모든 전이(transitions)와 트랜스버전(transversions)이 동일하게 발생할 가능성이 있다고 가정합니다. Kimura 모델에는 전이와 트랜스버전(퓨린에서 피리미딘으로 또는 그 반대로 발생하는 돌연변이)에 대해 각각 하나씩 매개변수가 있습니다.</p>
<p><a href="imgs/devil.png" title="여기서 용어의 혼란이 있을 수 있습니다! : 이 문맥에서 전이(Transitions)는 퓨린 내(A<->G) 또는 피리미딘 내(C <-> T)의 돌연변이 변화를 의미합니다. 반면 앞서 마르코프 체인에 대해 이야기했을 때의 전이(transition) 행렬은 모든 상태 변화의 모든 확률을 포함합니다."><img src="imgs/devil.png" class="img-fluid"></a></p>
<p>가장 유연한 모델은 일반화된 시간 가역적(Generalized Time Reversible, GTR) 모델이라고 하며, 6개의 자유 매개변수를 가집니다. 우리는 알려진 트리로부터 이러한 생성 모델에 따라 시뮬레이션된 데이터의 예를 보여줄 것입니다. ### 10.4.2 Simulating data and plotting a tree</p>
<p>Suppose we already know our phylogenetic tree and want to simulate the evolution of the nucleotides down this tree. First we visualize the tree <code>tree1</code> using <code>ggtree</code>; loading the tree and the relevant packages with:</p>
<pre><code>library("phangorn")
library("ggtree")
load(file.path(DATA,"tree1.RData"))__</code></pre>
<p>__</p>
<p>Task</p>
<p>Use the <code>ggtree</code> function to plot <code>tree1</code>; make the tips of the tree green triangles, the ancestral nodes, red circles.</p>
<pre><code>ggtree(tree1, lwd = 2, color = "darkgreen", alpha = 0.8, right = TRUE) +
  geom_tiplab(size = 7, angle = 90, offset = 0.05) +
  geom_point(aes(shape = isTip, color = isTip), size = 5, alpha = 0.6)__</code></pre>
<p><a href="10-chap_files/figure- html/fig-Atree1b-1.png" title="Figure 10.16: This is the tree we use as our true parameter. We generate nucleotides one at a time from the root and `dropping’ them down the tree. With some probability proportional to the edge lengths, mutations occur down the branches."><img src="10-chap_files/figure-html/fig-Atree1b-1.png" class="img-fluid"></a></p>
<p>Figure 10.16: This is the tree we use as our <em>true</em> parameter. We generate nucleotides one at a time from the root and `dropping’ them down the tree. With some probability proportional to the edge lengths, mutations occur down the branches.</p>
<p>Now we generate some sequences from our tree. Each sequence starts with a new nucleotide letter generated randomly at the root; mutations may occur as we go down the tree. You can see in Figure 10.17 that the colors are not equally represented, because the frequency at the root was chosen to be different from the uniform, see the following code.</p>
<pre><code>seqs6 = simSeq(tree1, l = 60, type = "DNA", bf = c(1, 1, 3, 3)/8, rate = 0.1)
seqs6 __


6 sequences with 60 character and 30 different site patterns.
The states are a c g t 


mat6df = data.frame(as.character(seqs6))
p = ggtree(tree1, lwd = 1.2) + geom_tiplab(aes(x = branch), size = 5, vjust = 2)
gheatmap(p, mat6df[, 1:60], offset = 0.01, colnames = FALSE)__</code></pre>
<p><a href="10-chap_files/figure-html/fig-ggtreeAlignment-1.png &quot;Figure 10.17: The tree on the left was used to generate the sequences on the right according to a Jukes Cantor model. The nucleotide frequencies generated at the root were quite unequal, with A and C being generated more rarely. As the sequences percolate down the tree, mutations occur, they are more likely to occur on the longer branches.&quot;"><img src="10-chap_files/figure-html/fig- ggtreeAlignment-1.png" class="img-fluid"></a></p>
<p>Figure 10.17: The tree on the left was used to generate the sequences on the right according to a Jukes Cantor model. The nucleotide frequencies generated at the root were quite unequal, with <code>A</code> and <code>C</code> being generated more rarely. As the sequences percolate down the tree, mutations occur, they are more likely to occur on the longer branches.</p>
<p>__</p>
<p>Question 10.9</p>
<p>Experiment with the code above. Change the <code>bf</code> and <code>rate</code> arguments in the <code>simSeq</code> function to make mutations more likely. Do you think sequences generated with a very high mutation rate would make it easier to infer the tree that generated them?</p>
<p>__</p>
<p>Solution</p>
<p>__</p>
<p>Very high mutation rates result in mutations overwriting themselves and make inference more difficult. Of course, there is a sweet spot because some mutations have to occur in order for us to resolve the tree branches. After a certain time and a certain number of mutations it may be very difficult to see what was happening at the root. See Mossel (<a href="16-chap.html#ref- Mossel:2003">2003</a>) for details.</p>
<p>__</p>
<p>Question 10.10</p>
<p><strong>Estimation bias: distance underestimation.</strong><br>
1) If we only count the number of changes between two sequences using a simple Hamming distance, but there has been much evolutionary change between the two, why do we underestimate the distance between the sequences?<br>
2) Will be the bias be larger for smaller evolutionary distances?</p>
<p>The standard Markovian models of evolution we saw above enable us to improve these estimates.</p>
</section>
</section>
<section id="estimating-a-phylogenetic-tree" class="level3" data-number="12.3.2">
<h3 data-number="12.3.2" class="anchored" data-anchor-id="estimating-a-phylogenetic-tree"><span class="header-section-number">12.3.2</span> 10.4.3 Estimating a phylogenetic tree</h3>
<p><img src="imgs/Magnify.png" class="img-fluid"></p>
<p>“In solving a problem of this sort, the grand thing is to be able to reason backward. That is a very useful accomplishment, and a very easy one, but people do not practise it much. In the everyday affairs of life it is more useful to reason forward, and so the other comes to be neglected. There are fifty who can reason synthetically for one who can reason analytically”. <strong>Sherlock Holmes</strong></p>
<p>When the true tree-parameter is known, the above-mentioned probabilistic generative models of evolution tells us what patterns to expect in the sequences. As we have seen in earlier chapters, statistics means going back from the data to reasonable estimates of the parameters; here the tree itself and the branch lengths, even the evolutionary rates can be considered to be the parameters.</p>
<p><a href="10-chap_files/figure- html/fig-igraphsteiner-1.png" title="Figure 10.18: A Steiner tree, the inner points are represented as squares. The method for creating the shortest tree that passes through all outer 1,2,5,6 is to create two inside (“ancester”) points 3 and 4."><img src="10-chap_files/figure-html/fig-igraphsteiner-1.png" class="img-fluid"></a></p>
<p>Figure 10.18: A Steiner tree, the inner points are represented as squares. The method for creating the shortest tree that passes through all outer 1,2,5,6 is to create two inside (“ancester”) points 3 and 4.</p>
<p>There are several approaches to estimation: tree `building’ is no exception, here are the main ones:</p>
<p><strong>A nonparametric estimate: the parsimony tree</strong> Parsimony is a nonparametric method that minimizes the number of changes necessary to explain the data, it’s solution is the same as that of the Steiner tree problem (see Figure 10.18).</p>
<p><strong>A parametric estimate: the maximum likelihood tree</strong> In order to estimate the tree using a maximum likelihood or Bayesian approach one needs a model for molecular evolution that integrates mutation rates and branch edge lengths. ML estimation (e.g., <code>Phyml</code>, <code>FastML</code>, <code>RaxML</code>) use efficient optimization algorithms to maximize the likelihood of a tree under the model assumptions.</p>
<p><strong>Bayesian posterior distributions for trees</strong> Bayesian estimation, MrBayes (<a href="16-chap.html#ref-mrbayes3">Ronquist et al.&nbsp;2012</a>) or BEAST (<a href="16-chap.html#ref-beast">Bouckaert et al.&nbsp;2014</a>) both use MCMC to find posterior distributions of the phylogenies. Bayesian methods are not directly integrated into R and require the user to import the collections of trees generated by Monte Carlo methods in order to summarize them and make confidence statements see Chakerian and Holmes (<a href="16-chap.html#ref-distory-paper">2012</a>) for simple examples.</p>
<p><strong>The semi-parametric approach: distance based methods</strong> These methods, called Neighbor Joining and UPGMA, are quite similar to the hierachical clusering algorithms we already encountered in <a href="05-chap.html">Chapter 5</a>. However, the distance estimation steps uses the parametric evolutionary models of Table 10.2; the `parametric’ part of why we call the method semi-parametric.</p>
<p>The neighbor-joining algorithm itself uses Steiner points as the summary of two combined points, and proceeds iteratively as in hierarchical clustering. It can be quite fast and is often used as a good starting point for the more time-consuming methods.</p>
<p>Let’s start by estimating the tree from the data <code>seqs6</code> using the <code>nj</code> (neighbor joining) on DNA distances based on the one-parameter Jukes-Cantor model, we make Figure 10.19 using the <code>ggtree</code> function:</p>
<pre><code>tree.nj = nj(dist.ml(seqs6, "JC69"))
ggtree(tree.nj) + geom_tiplab(size = 7) __</code></pre>
<p><a href="10-chap_files/figure- html/fig-njtree1-1.png" title="Figure 10.19: Trees built with a neighbor joining algorithm are very fast to compute and are often used as initial values for more expensive estimation procedures such as the maximum likelihood or parsimony."><img src="10-chap_files/figure-html/fig-njtree1-1.png" class="img-fluid"></a></p>
<p>Figure 10.19: Trees built with a neighbor joining algorithm are very fast to compute and are often used as initial values for more expensive estimation procedures such as the maximum likelihood or parsimony.</p>
<p>__</p>
<p>Question 10.11</p>
<p>Generate the maximum likelihood scores of the tree1 given the <code>seqs6</code> data and compare them to those of the neighbor joining tree.</p>
<p>__</p>
<p>Solution</p>
<p>__</p>
<pre><code>fit = pml(tree1, seqs6, k = 4)__</code></pre>
<p>__</p>
<p>Question 10.12</p>
<p>When we have aligned amino acids from which we want to infer a tree, we use (\(20 \)) transition matrices. The methods for estimating the phylogenetic are very similar. Try this in phangorn with an HIV amino acid sequence downloaded from <a href="https://www.hiv.lanl.gov/content/sequence/NEWALIGN/align.html" class="uri">https://www.hiv.lanl.gov/content/sequence/NEWALIGN/align.html</a>.</p>
<p>The quality of the tree estimates depend on the number of sequences per taxa and the distance to the root. We can evaluate the quality of the estimates either by using parametric and nonparametric bootstraps or performing Bayesian tree estimation using MCMC. For examples of how to visualize and compare the sampling distribution of trees, see Chakerian and Holmes (<a href="16-chap.html#ref-distory-paper">2012</a>).</p>
</section>
<section id="application-to-16s-rrna-data" class="level3" data-number="12.3.3">
<h3 data-number="12.3.3" class="anchored" data-anchor-id="application-to-16s-rrna-data"><span class="header-section-number">12.3.3</span> 10.4.4 Application to 16S rRNA data</h3>
<p>In <a href="05-chap.html">Chapter 5</a> we saw how to use a probabilistic clustering method to denoise 16S rRNA sequences. We can now reload these denoised sequences and preprocess them before building their phylogeny4.</p>
<p>4 In order to keep all the information and be able to compare sequences from different experiments, we use the sequences themselves as their label(<a href="16-chap.html#ref-Callahan:2017">Callahan, McMurdie, and Holmes 2017</a>).</p>
<pre><code>library("dada2")
seqtab = readRDS(file.path(DATA,"seqtab.rds"))
seqs = getSequences(seqtab)
names(seqs) = seqs __</code></pre>
<p>One of the benefits of using well-studied marker loci such as the 16S rRNA gene is the ability to taxonomically classify the sequenced variants. <strong><a href="https://bioconductor.org/packages/dada2/">dada2</a></strong> includes a naive Bayesian classifier method for this purpose (<a href="16-chap.html#ref-wang2007naive">Wang et al. 2007</a>). This classifier compares sequence variants to training sets of classified sequences. Here we use the RDP v16 training set (<a href="16-chap.html#ref-cole2009rdp">Cole et al.&nbsp;2009</a>)5. For example, code for such a classification might look like this.</p>
<p>5 See the download link on the dada2 website: <a href="https://benjjneb.github.io/dada2/training.html" class="uri">https://benjjneb.github.io/dada2/training.html</a></p>
<pre><code>fastaRef = "../tmp/rdp_train_set_16.fa.gz"
taxtab = assignTaxonomy(seqtab, refFasta = fastaRef)__</code></pre>
<p>Since the <code>assignTaxonomy</code> function runs for a while, the above code is not live and we here load a previously computed result, a table of taxonomic information:</p>
<pre><code>taxtab = readRDS(file.path(DATA,"taxtab16.rds"))
dim(taxtab)__


[1] 268   6</code></pre>
<p>__</p>
<p>Question 10.13</p>
<p>Write one line of code using R’s pipe operator <code>|&gt;</code> that shows just the first 6 rows of the taxonomic information without the row names.</p>
<p>__</p>
<p>Solution</p>
<p>__</p>
<pre><code>head(taxtab) |&gt; `rownames&lt;-`(NULL)__


     Kingdom    Phylum          Class         Order          
[1,] "Bacteria" "Bacteroidetes" "Bacteroidia" "Bacteroidales"
[2,] "Bacteria" "Bacteroidetes" "Bacteroidia" "Bacteroidales"
[3,] "Bacteria" "Bacteroidetes" "Bacteroidia" "Bacteroidales"
[4,] "Bacteria" "Bacteroidetes" "Bacteroidia" "Bacteroidales"
[5,] "Bacteria" "Bacteroidetes" "Bacteroidia" "Bacteroidales"
[6,] "Bacteria" "Bacteroidetes" "Bacteroidia" "Bacteroidales"
     Family               Genus        
[1,] "Porphyromonadaceae" NA           
[2,] "Porphyromonadaceae" NA           
[3,] "Porphyromonadaceae" NA           
[4,] "Porphyromonadaceae" "Barnesiella"
[5,] "Bacteroidaceae"     "Bacteroides"
[6,] "Porphyromonadaceae" NA           </code></pre>
<p>__</p>
<p>Question 10.14</p>
<p>What is the difference between taxonomic and phylogenetic information?</p>
<p>Note that as the <code>seqs</code> data are randomly generated, they are “cleaner” than the real data we will have to handle.</p>
<p>In particular naturally occurring raw sequences have to be <strong>aligned</strong>. This is necessary as there are often extra nucleotides in some sequences, a consequence of what we call <em>indel</em> events6. Also mutations occur and appear as substitutions of one nucleotide by another.</p>
<p>6 A nucleotide is deleted or inserted and it is often hard to distinguish which took place.</p>
<p>Here is an example of what the first few characters of <strong>aligned</strong> sequences looks like:</p>
<pre><code>readLines(file.path(DATA,"mal2.dna.txt")) |&gt; head(12) |&gt; cat(sep="\n")__


    11   1620
Pre1        GTACTTGTTA GGCCTTATAA GAAAAAAGT- TATTAACTTA AGGAATTATA
Pme2        GTATCTGTTA AGCCTTATAA AAAGATAGT- T-TAAATTAA AGGAATTATA
Pma3        GTATTTGTTA AGCCTTATAA GAGAAAAGTA TATTAACTTA AGGA-TTATA
Pfa4        GTATTTGTTA GGCCTTATAA GAAAAAAGT- TATTAACTTA AGGAATTATA
Pbe5        GTATTTGTTA AGCCTTATAA GAAAAA--T- TTTTAATTAA AGGAATTATA
Plo6        GTATTTGTTA AGCCTTATAA GAAAAAAGT- TACTAACTAA AGGAATTATA
Pfr7        GTACTTGTTA AGCCTTATAA GAAAGAAGT- TATTAACTTA AGGAATTATA
Pkn8        GTACTTGTTA AGCCTTATAA GAAAAGAGT- TATTAACTTA AGGAATTATA
Pcy9        GTACTCGTTA AGCCTTTTAA GAAAAAAGT- TATTAACTTA AGGAATTATA
Pvi10       GTACTTGTTA AGCCTTTTAA GAAAAAAGT- TATTAACTTA AGGAATTATA
Pga11       GTATTTGTTA AGCCTTATAA GAAAAAAGT- TATTAATTTA AGGAATTATA</code></pre>
<p>We will perform this multiple-alignment on our <code>seqs</code> data using the <strong><a href="https://bioconductor.org/packages/DECIPHER/">DECIPHER</a></strong> package (<a href="16-chap.html#ref-wright2015decipher">Wright 2015</a>):</p>
<pre><code>library("DECIPHER")
alignment = AlignSeqs(DNAStringSet(seqs), anchor = NA, verbose = FALSE)__</code></pre>
<p>We use the <strong><a href="https://cran.r-project.org/web/packages/phangorn/">phangorn</a></strong> package to build the MLE tree (under the GTR model), but will use the neighbor-joining tree as our starting point.</p>
<pre><code>phangAlign = phangorn::phyDat(as(alignment, "matrix"), type = "DNA")
dm = phangorn::dist.ml(phangAlign)
treeNJ = phangorn::NJ(dm)   # Note: tip order != sequence order
fit = phangorn::pml(treeNJ, data = phangAlign)
fitGTR = update(fit, k = 4, inv = 0.2)
fitGTR = phangorn::optim.pml(fitGTR, model = "GTR", optInv = TRUE,
         optGamma = TRUE,  rearrangement = "stochastic",
         control = phangorn::pml.control(trace = 0))__</code></pre>
</section>
</section>
<section id="combining-phylogenetic-trees-into-a-data-analysis" class="level2" data-number="12.4">
<h2 data-number="12.4" class="anchored" data-anchor-id="combining-phylogenetic-trees-into-a-data-analysis"><span class="header-section-number">12.4</span> 10.5 Combining phylogenetic trees into a data analysis</h2>
<p>We now need to combine the phylogenetic tree and the denoised read abundances with the complementary information provided about the samples from which the reads were gathered. This information about the sample is often provided as a spreadhseet (or <code>.csv</code>), and sometimes called the <em>meta</em> -data7. This data combination step is facilitated by the specialized containers and accessors that <strong><a href="https://bioconductor.org/packages/phyloseq/">phyloseq</a></strong> provides.</p>
<p>7 We consider the prefix <em>meta</em> unhelpful and potentially confusing here: the data about the samples is just that: data.</p>
<p>The following set of steps contains a few data cleanup and reorganization tasks—a dull but necessary part of applied statistics—that end in the creation of the object <code>ps1</code>.</p>
<pre><code>samples = read.csv("../data/MIMARKS_Data_combined.csv", header = TRUE)
samples$SampleID = paste0(gsub("00", "", samples$host_subject_id), 
                          "D", samples$age-21) 
samples = samples[!duplicated(samples$SampleID), ] 
stopifnot(all(rownames(seqtab) %in% samples$SampleID))
rownames(samples) = samples$SampleID 
keepCols = c("collection_date", "biome", "target_gene", "target_subfragment", 
  "host_common_name", "host_subject_id", "age", "sex", "body_product", "tot_mass",
  "diet", "family_relationship", "genotype", "SampleID") 
samples = samples[rownames(seqtab), keepCols] __</code></pre>
<p>The sample-by-sequence feature table, the sample (meta)data, the sequence taxonomies, and the phylogenetic tree—are combined into a single object as follows:</p>
<pre><code>library("phyloseq")
pso = phyloseq(tax_table(taxtab), 
               sample_data(samples),
               otu_table(seqtab, taxa_are_rows = FALSE), 
               phy_tree(fitGTR$tree))__</code></pre>
<p>We have already encountered several cases of combining heterogeneous datasets into special data classes that automate the linking and keeping consistent the different parts of the dataset (e.g., in <a href="08-chap.html">Chapter 8</a>, when we studied the <code>pasilla</code> data).</p>
<p>__</p>
<p>Task</p>
<p>Look at the detailed <strong><a href="https://bioconductor.org/packages/phyloseq/">phyloseq</a></strong> <a href="https://joey711.github.io/phyloseq/tutorials-index.html">documentation here</a>. Try a few filtering operations. For instance, create a subset of the data that contains the tree, taxa abundance table, the sample and taxa information for only the samples that have more than 5000 reads.</p>
<p>This can be done in one line:</p>
<pre><code>prune_samples(rowSums(otu_table(pso)) &gt; 5000, pso)__


phyloseq-class experiment-level object
otu_table()   OTU Table:         [ 268 taxa and 10 samples ]
sample_data() Sample Data:       [ 10 samples by 14 sample variables ]
tax_table()   Taxonomy Table:    [ 268 taxa by 6 taxonomic ranks ]
phy_tree()    Phylogenetic Tree: [ 268 tips and 266 internal nodes ]</code></pre>
<p>We can also make other data transformations while maintaining the integrity of the links between all the data components.</p>
<p>__</p>
<p>Question 10.15</p>
<p>What do the following lines of code do?</p>
<pre><code>prevalence = apply(X = otu_table(pso),
                   MARGIN = ifelse(taxa_are_rows(pso), yes = 1, no = 2),
                   FUN = function(x) {sum(x &gt; 0)})
prevdf = data.frame(Prevalence = prevalence,
                    TotalAbundance = taxa_sums(pso),
                    tax_table(pso))
tab = table(prevdf$Phylum)
keepPhyla = names(tab)[tab&gt;5]
prevdf1   = subset(prevdf,   Phylum %in% keepPhyla)
ps2v      = subset_taxa(pso, Phylum %in% keepPhyla)__</code></pre>
<p>Plotting the abundances for certain bacteria can be done using barcharts. <strong><a href="https://cran.r-project.org/web/packages/ggplot2/">ggplot2</a></strong> expressions have been hardwired into suitable one-line calls in the <strong><a href="https://bioconductor.org/packages/phyloseq/">phyloseq</a></strong> package. There is also an interactive <a href="http://joey711.github.io/shiny-phyloseq/">Shiny-phyloseq</a> browser based tool (<a href="16-chap.html#ref- mcmurdie2015">McMurdie and Holmes 2015</a>). For more details, please see the online vignettes.</p>
<section id="hierarchical-multiple-testing" class="level3" data-number="12.4.1">
<h3 data-number="12.4.1" class="anchored" data-anchor-id="hierarchical-multiple-testing"><span class="header-section-number">12.4.1</span> 10.5.1 Hierarchical multiple testing</h3>
<p>Hypothesis testing can identify individual bacteria whose abundance relates to sample variables of interest. A standard approach is very similar to the approach we already visited in <a href="06-chap.html">Chapter 6</a>. Compute a test statistic for each taxa individually; then jointly adjust p-values to ensure a false discovery rate upper bound. However, this procedure does not exploit the structure among the tested hypotheses. For example, if we observe that one Ruminococcus species is strongly associated with age, but the biological reason for this sits at the genus level, then we would expect other species to have such an association as well. To integrate such information, Benjamini and Yekutieli (<a href="16-chap.html#ref-benjamini2003hierarchical">2003</a>) and Benjamini and Bogomolov (<a href="16-chap.html#ref-benjamini2014selective">2014</a>) proposed a hierarchical testing procedure, where lower level taxonomic groups are only tested if higher levels are found to be be associated. In the case where many related species have a slight signal, this pooling of information can increase power.</p>
<p>We apply this method to test the association between microbial abundance and age. We use the data object <code>ps1</code>, which is similar to <code>pso</code> from above, but has undergone some additional transformation and filtering steps. We also need to apply the normalization protocols available in the <strong><a href="https://bioconductor.org/packages/DESeq2/">DESeq2</a></strong> package, which we discussed in <a href="08-chap.html">Chapter 8</a>, following Love, Huber, and Anders (<a href="16-chap.html#ref-LoveDESeq2">2014</a>) for RNA-Seq data and McMurdie and Holmes (<a href="16-chap.html#ref-mcmurdie2014">2014</a>) for 16S rRNA generated count data.</p>
<pre><code># warning: !expr c("DESeqDataSet.se, design = design, ignoreRank.: some variables in design formula are characters, converting to factors")
library("DESeq2")
ps1 = readRDS(file.path(DATA,"ps1.rds"))
ps_dds = phyloseq_to_deseq2(ps1, design = ~ ageBin + family_relationship)
geometricmean = function(x)
   if (all(x == 0)) { 0 } else { exp(mean(log(x[x != 0]))) }
geoMeans = apply(counts(ps_dds), 1, geometricmean)
ps_dds = estimateSizeFactors(ps_dds, geoMeans = geoMeans)
ps_dds = estimateDispersions(ps_dds)
abund = getVarianceStabilizedData(ps_dds)__</code></pre>
<p>We use the <strong><a href="https://cran.r-project.org/web/packages/structSSI/">structSSI</a></strong> package to perform the hierarchical testing (<a href="16-chap.html#ref-sankaran2014structssi">Sankaran and Holmes 2014</a>). For more convenient printing, we first shorten the names of the taxa:</p>
<pre><code>rownames(abund) = substr(rownames(abund), 1, 5) |&gt; make.names(unique = TRUE)__</code></pre>
<p>The hierarchical testing procedure we are now going to do differs from standard multiple hypothesis testing in that univariate tests are done not only for every taxon, but for each higher-level taxonomic group. A helper function, <code>treePValues</code>, is available for this: it expects an edge list encoding parent-child relationships, with the first row specifying the root node.</p>
<pre><code>library("structSSI")
el = phy_tree(ps1)$edge
el0 = el
el0 = el0[rev(seq_len(nrow(el))), ]
el_names = c(rownames(abund), seq_len(phy_tree(ps1)$Nnode))
el[, 1] = el_names[el0[, 1]]
el[, 2] = el_names[el0[, 2]]
unadj_p = treePValues(el, abund, sample_data(ps1)$ageBin)__</code></pre>
<p>We can now do our FDR calculations using the hierarchical testing procedure. The test results are guaranteed to control several variants of FDR, but at different levels; we defer details to (<a href="16-chap.html#ref-benjamini2003hierarchical">Benjamini and Yekutieli 2003</a>; <a href="16-chap.html#ref-benjamini2014selective">Benjamini and Bogomolov 2014</a>; <a href="16-chap.html#ref-sankaran2014structssi">Sankaran and Holmes 2014</a>).</p>
<p>__</p>
<p>Task</p>
<p>Try the following code, including the interactive plotting command that will open a browser window:</p>
<pre><code>hfdr_res = hFDR.adjust(unadj_p, el, 0.75)
summary(hfdr_res)
#plot(hfdr_res, height = 5000) # not run: opens in a browser __</code></pre>
<p><a href="imgs/structssi-screenshot.png &quot;Figure 10.20: A screenshot of a subtree with many differentially abundant microbes, as determined by the hierarchical testing procedure. Currently the user is hovering over the node associated with microbe GCGAG.33; this causes the adjusted p-value (0.029) to appear.&quot;"><img src="imgs/structssi-screenshot.png" class="img-fluid"></a></p>
<p>Figure 10.20: A screenshot of a subtree with many differentially abundant microbes, as determined by the hierarchical testing procedure. Currently the user is hovering over the node associated with microbe GCGAG.33; this causes the adjusted p-value (0.029) to appear.</p>
<p>The plot opens in a new browser – a static screenshot of a subtree is displayed in Figure 10.20. Nodes are shaded according to p-values, from blue to orange, representing the strongest to weakest associations. Grey nodes were never tested, to focus power on more promising subtrees. Scanning the full tree; it becomes clear that the association between age group and taxonomic abundances is present in only a few isolated taxonomic groups. It is quite strong in those groups. To give context to these results, we can retrieve the taxonomic identity of the rejected hypotheses.</p>
<pre><code>library("dplyr")
options(digits = 3)
tax = tax_table(ps1)[, c("Family", "Genus")] |&gt; data.frame()
tax$seq = rownames(abund)
hfdr_res@p.vals$seq = rownames(hfdr_res@p.vals)
left_join(tax, hfdr_res@p.vals[,-3]) |&gt;
  arrange(adjp) |&gt; head(9) |&gt; dplyr::select(1,2,4,5)__


              Family       Genus hypothesisName hypothesisIndex
1 Porphyromonadaceae        &lt;NA&gt;           &lt;NA&gt;              NA
2 Porphyromonadaceae        &lt;NA&gt;           &lt;NA&gt;              NA
3 Porphyromonadaceae        &lt;NA&gt;           &lt;NA&gt;              NA
4 Porphyromonadaceae Barnesiella           &lt;NA&gt;              NA
5     Bacteroidaceae Bacteroides           &lt;NA&gt;              NA
6 Porphyromonadaceae Barnesiella           &lt;NA&gt;              NA
7      Rikenellaceae   Alistipes           &lt;NA&gt;              NA
8 Porphyromonadaceae        &lt;NA&gt;           &lt;NA&gt;              NA
9 Porphyromonadaceae        &lt;NA&gt;           &lt;NA&gt;              NA</code></pre>
<p>It seems that the most strongly associated bacteria all belong to family <em>Lachnospiraceae</em>.</p>
</section>
</section>
<section id="minimum-spanning-trees" class="level2" data-number="12.5">
<h2 data-number="12.5" class="anchored" data-anchor-id="minimum-spanning-trees"><span class="header-section-number">12.5</span> 10.6 Minimum spanning trees</h2>
<p>A very simple and useful graph is the so-called <strong>minimum spanning tree</strong> (<strong>MST</strong>). Given a set of vertices, a <strong>spanning tree</strong> is a tree that goes through all points at least once. Examples are shown in Figure 10.21. Given distances between vertices, the MST is the spanning tree with the minimum total length (see Figure 10.21).</p>
<p>Greedy algorithms work well for computing the MST and there are many implementations in R: <code>mstree</code> in <strong><a href="https://cran.r-project.org/web/packages/ade4/">ade4</a></strong> , <code>mst</code> in <strong><a href="https://cran.r-project.org/web/packages/ape/">ape</a></strong> , <code>spantree</code> in <strong><a href="https://cran.r-project.org/web/packages/vegan/">vegan</a></strong> , <code>mst</code> in <strong><a href="https://cran.r-project.org/web/packages/igraph/">igraph</a></strong>.</p>
<p><a href="10-chap_files/figure- html/fig-graphs-MST-1.png" title="Figure 10.21 (a):"><img src="10-chap_files/figure-html/fig-graphs-MST-1.png" class="img-fluid"></a></p>
<ol type="a">
<li></li>
</ol>
<p><a href="10-chap_files/figure- html/fig-graphs-MST-2.png" title="Figure 10.21 (b):"><img src="10-chap_files/figure-html/fig-graphs-MST-2.png" class="img-fluid"></a></p>
<ol start="2" type="a">
<li></li>
</ol>
<p>Figure 10.21: Two spanning trees for the same set of six vertices. The blue graph is the minimum spanning tree, if the Euclidean distances between the points in the 2D plane are used.</p>
<p>Here we are going to take the DNA sequence distances between strains of HIV from patients all over the world and construct their minimum spanning tree. The result is shown in Figure 10.22.</p>
<pre><code>load(file.path(DATA, "dist2009c.RData"))
country09 = attr(dist2009c, "Label")
mstree2009 = ape::mst(dist2009c)
gr09 = graph_from_adjacency_matrix(mstree2009, mode = "undirected")
ggraph(gr09, layout="fr") +
  geom_edge_link(color = "black",alpha=0.5) +
  geom_node_point(aes(color = vertex_attr(gr09)$name), size = 2) +
  geom_node_text(aes(label = vertex_attr(gr09)$name), color="black",size=2) +
  theme_void() +
  guides(color=guide_legend(keyheight=0.1,keywidth=0.1,
      title="Countries"))__</code></pre>
<p><a href="10-chap_files/figure- html/fig-HIVMSTi-1.png" title="Figure 10.22: The minimum spanning tree computed from DNA distances between HIV sequences from samples taken in 2009 and whose country of origin was known, data as published in the HIVdb database [@HIVdb]."><img src="10-chap_files/figure-html/fig-HIVMSTi-1.png" class="img-fluid"></a></p>
<p>Figure 10.22: The minimum spanning tree computed from DNA distances between HIV sequences from samples taken in 2009 and whose country of origin was known, data as published in the <code>HIVdb</code> database (<a href="16-chap.html#ref-HIVdb">Rhee et al. 2003</a>).</p>
<p>__</p>
<p>Question 10.16</p>
<p>Make the network plot again, but replace <code>geom_node_text</code> with labels that repel each other to minimize the overlapping node labels.</p>
<p>__</p>
<p>Solution</p>
<p>__</p>
<p>See Figure 10.23. Maybe a better, or additional approach would be to first cluster those vertices that are very close together and from the same country.</p>
<pre><code>library("ggraph")
ggraph(gr09, layout="fr") +
  geom_edge_link(color = "black",alpha=0.5) +
  geom_node_point(aes(color = vertex_attr(gr09)$name), size = 2) +
  geom_node_label(aes(label = vertex_attr(gr09)$name), color="black",size=2,repel=TRUE) +
  theme_void() +
  guides(color=guide_legend(keyheight=0.1,keywidth=0.1,
      title="Countries"))__</code></pre>
<p><a href="10-chap_files/figure-html/fig-graphs- networklabelrepel-1.png" title="Figure 10.23: Solution to Question wrn-graphs- networklabelrepel."><img src="10-chap_files/figure-html/fig-graphs- networklabelrepel-1.png" class="img-fluid"></a></p>
<p>Figure 10.23: Solution to Question 10.16.</p>
<p>It could be preferable to use a <strong>graph layout</strong> that incorporates the known geographic coordinates. Thus, we might be able to see how the virus jumped large distances across the world through traveller mobility. We introduce approximate country coordinates, which we then <strong>jitter</strong> slightly to reduce overlapping.</p>
<pre><code>library("rworldmap")
mat = match(country09, countriesLow$NAME)
coords2009 = data.frame(
  lat = countriesLow$LAT[mat],
  lon = countriesLow$LON[mat],
  country = country09)
layoutCoordinates = cbind(
  x = jitter(coords2009$lon, amount = 15),
  y = jitter(coords2009$lat, amount = 8))
labc = names(table(country09)[which(table(country09) &gt; 1)])
matc = match(labc, countriesLow$NAME)
dfc = data.frame(
  latc = countriesLow$LAT[matc],
  lonc = countriesLow$LON[matc],
  labc)
dfctrans = dfc
dfctrans[, 1] = (dfc[,1] + 31) / 93
dfctrans[, 2] = (dfc[,2] + 105) / 238
Countries = vertex_attr(gr09)$name 

ggraph(gr09, layout=layoutCoordinates) +
  geom_node_point(aes(color=Countries),size = 3, alpha=0.75) +
  geom_edge_arc(color = "black", alpha = 0.5, strength=0.15) +
  geom_label(data=dfc,aes(x=lonc,y=latc,label=labc,fill=labc),colour="white",alpha=0.8,size=3,show.legend=F) +
  theme_void()  __</code></pre>
<p><a href="10-chap_files/figure- html/fig-HIVmap-1.png" title="Figure 10.24: A minimum spanning tree between HIV cases. The geographic locations of the cases were jittered to reduce overlapping. The DNA sequence distances between the HIV strains were used as input to an undirected minimum spanning tree algorithm."><img src="10-chap_files/figure-html/fig-HIVmap-1.png" class="img-fluid"></a></p>
<p>Figure 10.24: A minimum spanning tree between HIV cases. The geographic locations of the cases were jittered to reduce overlapping. The DNA sequence distances between the HIV strains were used as input to an undirected minimum spanning tree algorithm.</p>
<p>The input to the minimum spanning tree algorithm is a distance matrix or a graph with a length edge attribute. Figure 10.24 is the minimum spanning tree between cases of HIV, for which strain information was made available through the HIVdb database@HIVdb. The DNA distances were computed using the Jukes- Cantor mutation model.</p>
<p>__</p>
<p>Question 10.17</p>
<p>The above analysis provided an <strong>undirected</strong> network of connections, in fact several implementations of the minimum spanning tree (ie for instance <code>mstree</code> in <strong><a href="https://cran.r-project.org/web/packages/ade4/">ade4</a></strong>) provide a directed path through the points, which can provide meaningful information on the (apparent) spread of disases. Make a directed network version of the above maps.</p>
<p>MST is a very useful component of a simple nonparametric test for detecting differences between factors that are mapped onto its vertices.</p>
<section id="mst-based-testing-the-friedmanrafsky-test" class="level3" data-number="12.5.1">
<h3 data-number="12.5.1" class="anchored" data-anchor-id="mst-based-testing-the-friedmanrafsky-test"><span class="header-section-number">12.5.1</span> 10.6.1 MST based testing: the Friedman–Rafsky test</h3>
<p>Graph-based two-sample tests8 were introduced by Friedman and Rafsky (<a href="16-chap.html#ref-friedman1979multivariate">Friedman and Rafsky 1979</a>) as a generalization of the Wald-Wolfowitz runs test (see Figure 10.25). Our previous examples show graph vertices associated with covariates such as country of origin. Here we test whether the covariate is significantly <strong>associated</strong> to the graph structure.</p>
<p>8 Tests that explore whether two samples are drawn from the same distribution.</p>
<p>The <strong>Friedman-Rafsky</strong> tests for two/multiple sample segregation on a minimum spanning tree. It was conceived as a generalization of the univariate Wald- Wolfowitz runs test. If we are comparing two samples, say men and women, whose coordinates represent a measurement of interest. We color the two groups blue and red as in Figure 10.25, the Wald-Wolfowitz test looks for long runs of the same color that would indicate that the two groups have different means.</p>
<p><a href="10-chap_files/figure- html/fig-WWtest-1.png" title="Figure 10.25: Seeing the number of runs in a one- dimensional, two-sample, nonparametric Wald-Wolfowitz test can indicate whether the two groups have the same distributions."><img src="10-chap_files/figure-html/fig-WWtest-1.png" class="img-fluid"></a></p>
<p>Figure 10.25: Seeing the number of runs in a one-dimensional, two-sample, nonparametric Wald-Wolfowitz test can indicate whether the two groups have the same distributions.</p>
<p>Instead of looking for consecutive values of one type (‘runs’), we count the number of connected nodes of the same type.</p>
<p>Once the minimum spanning tree has been constructed, the vertices are assigned `colors’ according to the different levels of a categorical variable. We call <strong>pure</strong> edges those whose two nodes have the same level of the factor variable. We use \(S_O\), the number of <strong>pure</strong> edges as our test statistic. To evaluate whether our observed value could have occurred by chance when the groups have the same distributions, we permute the vertix labels (colors) randomly and recount how many pure edges there are. This label swapping is repeated many times, creating our null distribution for \(S\).</p>
</section>
<section id="example-bacteria-sharing-between-mice" class="level3" data-number="12.5.2">
<h3 data-number="12.5.2" class="anchored" data-anchor-id="example-bacteria-sharing-between-mice"><span class="header-section-number">12.5.2</span> 10.6.2 Example: Bacteria sharing between mice</h3>
<p>Here we illustrate the idea on a collection of samples from mice whose stool were analyzed for their microbial content. We read in a data set with many mice and many taxa, we compute the Jaccard distance and then use the <code>mst</code> function from the <strong><a href="https://cran.r-project.org/web/packages/igraph/">igraph</a></strong> package. We annotate the graph with the relevant covariates as shown in the code below:</p>
<pre><code>ps1  = readRDS(file.path(DATA,"ps1.rds"))
sampledata = data.frame( sample_data(ps1))
d1 = as.matrix(phyloseq::distance(ps1, method="jaccard"))
gr = graph_from_adjacency_matrix(d1,  mode = "undirected", weighted = TRUE)
net = igraph::mst(gr)
V(net)$id = sampledata[names(V(net)), "host_subject_id"]
V(net)$litter = sampledata[names(V(net)), "family_relationship"]__</code></pre>
<p>We make a <code>ggraph</code> object from the resulting igraph generated minimum spanning tree and then plot it, as shown in Figure 10.26.</p>
<pre><code>ggraph(net, layout="fr")+
  geom_edge_arc(color = "darkgray") +
  geom_node_point(aes(color = id, shape = litter)) + 
  theme(legend.position="bottom")__</code></pre>
<p><a href="10-chap_files/figure- html/fig-mstplot-1.png" title="Figure 10.26: The minimum spanning tree based on Jaccard dissimilarity and annotated with the mice ID and litter factors"><img src="10-chap_files/figure-html/fig-mstplot-1.png" class="img-fluid"></a></p>
<p>Figure 10.26: The minimum spanning tree based on Jaccard dissimilarity and annotated with the mice ID and litter factors</p>
<p>Now we compute the null distribution and p-value for the test, this is implemented in the <strong>phyloseqGraphTest</strong> package:</p>
<pre><code>library("phyloseqGraphTest")
gt = graph_perm_test(ps1, "host_subject_id", distance="jaccard",
                     type="mst",  nperm=1000)
gt$pval __


[1] 0.000999</code></pre>
<p>We can take a look at the complete histogram of the null distribution generatedby permutation using:</p>
<pre><code>plot_permutations(gt)__</code></pre>
<p><a href="10-chap_files/figure- html/fig-mstJaccard-1.png" title="Figure 10.27: The permutation histogram of the number of pure edges in the network obtained from the minimal spanning tree with Jaccard similarity."><img src="10-chap_files/figure-html/fig-mstJaccard-1.png" class="img-fluid"></a></p>
<p>Figure 10.27: The permutation histogram of the number of pure edges in the network obtained from the minimal spanning tree with Jaccard similarity.</p>
<section id="different-choices-for-the-skeleton-graph" class="level4" data-number="12.5.2.1">
<h4 data-number="12.5.2.1" class="anchored" data-anchor-id="different-choices-for-the-skeleton-graph"><span class="header-section-number">12.5.2.1</span> Different choices for the skeleton graph</h4>
<p>It is not necessary to use an MST for the skeleton graph that defines the edges. Graphs made by linking nearest neighbors (<a href="16-chap.html#ref-schilling1986multivariate">Schilling 1986</a>) or distance thresholding work as well.</p>
<p>The Bioconductor package <strong><a href="https://bioconductor.org/packages/phyloseq/">phyloseq</a></strong> has functionality for creating graphs based on thresholding a distance matrix through the function <code>make_network</code>. We create a network by creating an edge between samples whose Jaccard dissimilarity is less than a threshold, which we set below via the parameter <code>max.dist</code>. We can also use the <strong><a href="https://cran.r-project.org/web/packages/ggraph/">ggraph</a></strong> package to add attributes to the vertices indicating which mouse the sample came from and which litter the mouse was in. We see that in the resulting network, shown in Figure 10.28, there is grouping of the samples by both mouse and litter.</p>
<pre><code>net = make_network(ps1, max.dist = 0.35)
sampledata = data.frame(sample_data(ps1))
V(net)$id = sampledata[names(V(net)), "host_subject_id"]
V(net)$litter = sampledata[names(V(net)), "family_relationship"]__


ggraph(net, layout="fr") +
  geom_edge_link(color = "darkgray") +
  geom_node_point(aes(color = id, shape = litter)) + 
    theme(plot.margin = unit(c(0, 5, 2, 0), "cm"))+
    theme(legend.position = c(1.4, 0.3),legend.background = element_blank(),
          legend.margin=margin(0, 3, 0, 0, "cm"))+
         guides(color=guide_legend(ncol=2))+
  theme_graph(background = "white")__</code></pre>
<p><a href="10-chap_files/figure-html/fig-ggnetworkplotJ-1.png &quot;Figure 10.28: A co-occurrence network created by using a threshold on the Jaccard dissimilarity matrix. The colors represent which mouse the sample came from; the shape represents which litter the mouse was in.&quot;"><img src="10-chap_files/figure-html/fig- ggnetworkplotJ-1.png" class="img-fluid"></a></p>
<p>Figure 10.28: A co-occurrence network created by using a threshold on the Jaccard dissimilarity matrix. The colors represent which mouse the sample came from; the shape represents which litter the mouse was in.</p>
<p>Note that no matter which graph we build between the samples, we can approximate a null distribution by permuting the labels of the nodes of the graph. However, sometimes it will preferable to adjust the permutation distribution to account for known structure between the covariates.</p>
</section>
</section>
<section id="friedmanrafsky-test-with-nested-covariates" class="level3" data-number="12.5.3">
<h3 data-number="12.5.3" class="anchored" data-anchor-id="friedmanrafsky-test-with-nested-covariates"><span class="header-section-number">12.5.3</span> 10.6.3 Friedman–Rafsky test with nested covariates</h3>
<p>In the test above, we took a rather naïve approach and showed there was a significant difference between individual mice (the <code>host_subject_id</code> variable). Here we perform a slightly different permutation test to find out if we control for the difference between mice; is there a litter (the <code>family_relationship</code> variable) effect? The setup of the test is similar, it is simply how the permutations are generated which differs. We maintain the nested structure of the two factors using the <code>grouping</code> argument. We permute the <code>family_relationship</code> labels but keep the <code>host_subject_id</code> structure intact.</p>
<pre><code>gt = graph_perm_test(ps1, "family_relationship",
        grouping = "host_subject_id",
        distance = "jaccard", type = "mst", nperm= 1000)
gt$pval __


[1] 0.002</code></pre>
<p>This test has a small p-value, and we reject the null hypothesis that the two samples come from the same distribution. From the plot of the minimum spanning tree in Figure 10.27, we see by eye that the samples group by litter more than we would expect by chance.</p>
<pre><code>plot_permutations(gt)__</code></pre>
<p><a href="10-chap_files/figure-html/fig-mstpermplotNest-1.png &quot;Figure 10.29: The permutation histogram obtained from the minimal spanning tree with Jaccard similarity.&quot;"><img src="10-chap_files/figure-html/fig- mstpermplotNest-1.png" class="img-fluid"></a></p>
<p>Figure 10.29: The permutation histogram obtained from the minimal spanning tree with Jaccard similarity.</p>
<p>__</p>
<p>Question 10.18</p>
<p>The \(k\)-nearest neighbors graph is obtained by putting an edge between two samples whenever one of them is in the set of \(k\)-nearest neighbors of the other. Redo the test, defining the graph using nearest neighbors defined with the Jaccard distance. What would you conclude?</p>
<p>__</p>
<p>Solution</p>
<p>__</p>
<pre><code>gtnn1 = graph_perm_test(ps1, "family_relationship",
                      grouping = "host_subject_id",
                      distance = "jaccard", type = "knn", knn = 1)
gtnn1$pval __


[1] 0.004</code></pre>
<p>Figure 10.30 shows that pairs of samples having edges between them in this nearest neighbor graph are much more likely to be from the same litter.</p>
<pre><code>plot_test_network(gtnn1)__</code></pre>
<p><a href="10-chap_files/figure- html/fig-knn-1-plot-1.png" title="Figure 10.30: The graph obtained from a nearest- neighbor graph with Jaccard similarity."><img src="10-chap_files/figure-html/fig-knn-1-plot-1.png" class="img-fluid"></a></p>
<p>Figure 10.30: The graph obtained from a nearest-neighbor graph with Jaccard similarity.</p>
<p><strong>Note: The dual graph</strong><br>
In the examples above we sought to show relationships between samples through their shared taxa. It can also be of interest to ask the question about taxa: do some of the taxa co-occur more often than one would expect? This approach can help study microbial `communities’ as they assemble in the microbiome. The methods we developed above all apply to this use-case, all one really does is transpose the data. It is always preferable with sparse data such as the microbiome to use Jaccard and not build correlation networks that can be appropriate in other settings.</p>
</section>
</section>
<section id="summary-of-this-chapter" class="level2" data-number="12.6">
<h2 data-number="12.6" class="anchored" data-anchor-id="summary-of-this-chapter"><span class="header-section-number">12.6</span> 10.7 Summary of this chapter</h2>
<section id="annotated-graphs" class="level4" data-number="12.6.0.1">
<h4 data-number="12.6.0.1" class="anchored" data-anchor-id="annotated-graphs"><span class="header-section-number">12.6.0.1</span> Annotated graphs</h4>
<p>In this chapter we have learnt how to store and plot data that have more structure than simple arrays: graphs have edges and nodes that can also be associated to extra annotations that can be displayed usefully.</p>
</section>
<section id="important-examples-of-graphs-and-useful-r-packages" class="level4" data-number="12.6.0.2">
<h4 data-number="12.6.0.2" class="anchored" data-anchor-id="important-examples-of-graphs-and-useful-r-packages"><span class="header-section-number">12.6.0.2</span> Important examples of graphs and useful R packages</h4>
<p>We started by specific examples such as Markov chain graphs, phylogenetic trees and minimum spanning trees. We saw how to use the <strong><a href="https://cran.r-project.org/web/packages/ggraph/">ggraph</a></strong> and <strong><a href="https://cran.r-project.org/web/packages/igraph/">igraph</a></strong> packages to visualize graphs and show as much information as possible by using specific graph layout algorithms.</p>
</section>
<section id="combining-graphs-with-statistical-data" class="level4" data-number="12.6.0.3">
<h4 data-number="12.6.0.3" class="anchored" data-anchor-id="combining-graphs-with-statistical-data"><span class="header-section-number">12.6.0.3</span> Combining graphs with statistical data</h4>
<p>We then approached the problem of incorporating a known `skeleton’ graph into differential expression analyses. This enables use to pinpoint perturbation hotspots in a network. We saw how evolutionary models defined along rooted binary trees serve as the basis for phylogenetic tree estimation and how we can incorporate these trees as supplementary information in a differential abundance analysis using the R packages <strong><a href="https://cran.r-project.org/web/packages/structSSI/">structSSI</a></strong> and <strong><a href="https://bioconductor.org/packages/phyloseq/">phyloseq</a></strong>.</p>
</section>
<section id="linking-co-occurrence-to-other-variables" class="level4" data-number="12.6.0.4">
<h4 data-number="12.6.0.4" class="anchored" data-anchor-id="linking-co-occurrence-to-other-variables"><span class="header-section-number">12.6.0.4</span> Linking co-occurrence to other variables</h4>
<p>Graph and network tools also enable the creation of networks from co- occurrence data and can be used to visualize and test the effect of factor covariates. We saw the Friedman-Rafsky test which provides an easy way of testing dependencies of a variable with the edge structure of a skeleton graph.</p>
</section>
<section id="context-and-intepretation-aids" class="level4" data-number="12.6.0.5">
<h4 data-number="12.6.0.5" class="anchored" data-anchor-id="context-and-intepretation-aids"><span class="header-section-number">12.6.0.5</span> Context and intepretation aids</h4>
<p>This chapter illustrated ways of incorporating interactions of players in a network and we saw how useful it was to combine this with statistical scores. This often provides biological insight into analyses of complex biological systems.</p>
</section>
<section id="previous-knowledge-or-outcome" class="level4" data-number="12.6.0.6">
<h4 data-number="12.6.0.6" class="anchored" data-anchor-id="previous-knowledge-or-outcome"><span class="header-section-number">12.6.0.6</span> Previous knowledge or outcome</h4>
<p>We saw that graphs can be both useful to encode our previous knowledge, metabolic network information, gene ontologies and phylogenetic trees of known bacteria are all available in standard databases. It is beneficial in a study to incorprate all known information and doing so by combining these skeleton networks with observed data enhances our understanding of experimental results in the context of what is already known.</p>
<p>On the other hand, the graph can be the outcome that we want to predict and we saw how to build graphs from data (phylogenetic trees, co-occurrence networks and minimum spanning trees).</p>
</section>
</section>
<section id="further-reading" class="level2" data-number="12.7">
<h2 data-number="12.7" class="anchored" data-anchor-id="further-reading"><span class="header-section-number">12.7</span> 10.8 Further reading</h2>
<p>For complete developments and many important consequences of the evolutionary models used in phylogenetic trees, see the books by Li (<a href="16-chap.html#ref-WHLi">1997</a>; <a href="16-chap.html#ref- LiandGraur">Li and Graur 1991</a>). The book by Felsenstein (<a href="16-chap.html#ref-fels:book">2004</a>) is the classic text on estimating phylogenetic trees.</p>
<p>The book written by the author of the <strong><a href="https://cran.r-project.org/web/packages/ape/">ape</a></strong> packages, Paradis (<a href="16-chap.html#ref-paradis:2011">2011</a>) contains many use-cases and details about manipulation of trees in R. A review of bootstrapping for phylogenetic trees can be found in Holmes (<a href="16-chap.html#ref-Holmes-2003">2003a</a>).</p>
<p>We can use a tree as well as abundances in a contingency table data through an extension of PCoA-MDS called DPCoA (Double principal coordinate analysis). For microbiome data, the phylogenetic tree provides distances between taxa; these distances serve as the basis for the first PCoA. A second PCoA enables the projection of the weighted sample points. This has proved very effective in microbial ecology applications, see Purdom (<a href="16-chap.html#ref- Purdom2010">2010</a>) or Fukuyama et al.&nbsp;(<a href="16-chap.html#ref-Fukuyama:2012">2012</a>) for details.</p>
<p>Graphs can be used to predict vertex covariates. There is a large field of applied statistics and machine learning that considers the edges in the graph as a response variable for which one can make predictions based on covariates or partial knowledge of the graph; these include <strong>ERGM</strong> ’s (Exponential Random Graph Models, Robins et al.&nbsp;(<a href="16-chap.html#ref-robins:2007">2007</a>)) and kernel methods for graphs (<a href="16-chap.html#ref- VertKernel">Schölkopf, Tsuda, and Vert 2004</a>).</p>
<p>For theoretical properties of the Friedman-Rafsky test and more examples see Bhattacharya (<a href="16-chap.html#ref-Bhattacharya:2015">2015</a>).</p>
<p>A full list packages that deal with graphs and networks is available at: <a href="http://www.bioconductor.org/packages/release/BiocViews.html#___GraphAndNetwork" class="uri">http://www.bioconductor.org/packages/release/BiocViews.html#___GraphAndNetwork</a>.</p>
</section>
<section id="exercises" class="level2" data-number="12.8">
<h2 data-number="12.8" class="anchored" data-anchor-id="exercises"><span class="header-section-number">12.8</span> 10.9 Exercises</h2>
<p>__</p>
<p>Exercise 10.1</p>
<p>Create a function that plots a graph starting from an adjacency matrix. Show how it works on an example.</p>
<p>__</p>
<p>Solution</p>
<p>__</p>
<pre><code>ggplotadjacency = function(a) {
  n = nrow(a)
  p = ncol(a)
  fromto  = reshape2::melt(a)
  stopifnot(identical(nrow(fromto), n*p))
  fromto$value = as.factor(fromto$value)
  cols = c("white", "darkblue")
  ggplot(data = fromto, aes(x = Var1, y = Var2, fill = value)) +
    geom_tile(colour = "black") +
    coord_fixed(ratio = 1, ylim = c(0.5, n + 0.5), xlim = c(0.5, p + 0.5)) +
    scale_fill_manual(values = cols) +
    scale_x_continuous(name = "" , breaks = 1:p, labels = paste(1:p)) +
    scale_y_reverse(  name = "" , breaks = n:1, labels = paste(n:1)) + 
    theme_bw() +
    theme(axis.text = element_text(size = 14),
      legend.key = element_rect(fill = "white"),
      legend.background = element_rect(fill = "white"),
      panel.border = element_blank(),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      axis.line = element_line(color = "white"),
      axis.ticks.x = element_blank(),
      axis.ticks.y = element_blank() 
    )
}__</code></pre>
<p>__</p>
<p>Exercise 10.2</p>
<p>The relationships between gene functions is organized hierarchically into a graph called the Gene Ontology (GO) graph. The biological processes are organized at finer and finer scale. Take one of the databases providing the GO information for the organisms you are interested in. Choose a gene list and build the GO graph for that list.<br>
Hint: Some examples can be found in the packages , , .</p>
<p>__</p>
<p>Exercise 10.3</p>
<p><em>Markov chain graph of transitions between states of the vaginal microbiota</em> : In DiGiulio et al.&nbsp;(<a href="16-chap.html#ref-DigiulioCallahan:2015">2015</a>) the authors use an <strong><a href="https://cran.r-project.org/web/packages/igraph/">igraph</a></strong> plot to represent the transitions rates between community state types CSTs using the <strong><a href="https://cran.r-project.org/web/packages/markovchain/">markovchain</a></strong> package. Load the data and the transition rates and state names into an object of the special class <code>markovchain</code> and tailor the layout carefully to include the percentage of preterm birth as a covariate for the vertices (make the vertex size proportional to this variable). Include the size of transitions between states as the width of the arrows.</p>
<p>__</p>
<p>Solution</p>
<p>__</p>
<p>Note: the below code is not live, a version of it used to run for the authors at one point, here it is given as a starting point for the reader to finish, it has opportunities for modernization and improvement.</p>
<p><a href="imgs/PSB_MC_s.png" title="Figure 10.31: This figure was originally created for the study done in @DigiulioCallahan:2015, where the nodes designate states of the vaginal microbiome and arrows represent transitions between states with different probabilities."><img src="imgs/PSB_MC_s.png" class="img-fluid"></a></p>
<p>Figure 10.31: This figure was originally created for the study done in DiGiulio et al.&nbsp;(<a href="16-chap.html#ref-DigiulioCallahan:2015">2015</a>), where the nodes designate states of the vaginal microbiome and arrows represent transitions between states with different probabilities.</p>
<pre><code>library("markovchain")
# Make Markov chain object
mcPreg  =  new("markovchain", states = CSTs,
              transitionMatrix = trans, name="PregCST")
mcPreg
# Set up igraph of the markov chain
netMC  =  markovchain:::.getNet(mcPreg, round = TRUE)__</code></pre>
<p>Now define a number of plotting parameters, and assign node colors based on the association of that CST and preterm outcome.</p>
<pre><code>wts  =  E(netMC)$weight/100
edgel  =  get.edgelist(netMC)
elcat  =  paste(edgel[,1], edgel[,2])
elrev  =  paste(edgel[,2], edgel[,1])
edge.curved  =  sapply(elcat, function(x) x %in% elrev)
samples_def  =  data.frame(sample_data(ps))
samples_def  =  samples_def[samples$Preterm | samples$Term,] # Only those definitely assigned, i.e. not marginal
premat  =  table(samples_def$CST, samples_def$Preterm)
rownames(premat)  =  markovchain::states(mcPreg)
colnames(premat)  =  c("Term", "Preterm")
premat
premat  =  premat/rowSums(premat)
vert.CSTclrs  =  CSTColors __


default.par  =  par(no.readonly = TRUE)
# Define color scale
# Plotting function for markov chain
plotMC  =  function(object, ...) {
    netMC  =  markovchain:::.getNet(object, round = TRUE)
    plot.igraph(x = netMC, ...)
}
# Color bar for the markov chain visualization, gradient in strength of preterm association
color.bar  =  function(lut, min, max=-min, nticks=11, ticks=seq(min, max, len=nticks), title=NULL) {
    scale = (length(lut)-1)/(max-min)
    cur.par = par(no.readonly = TRUE)
    par(mar = c(0, 4, 1, 4) + 0.1, oma = c(0, 0, 0, 0) + 0.1)
    par(ps = 10, cex = 0.8)
    par(tcl=-0.2, cex.axis=0.8, cex.lab = 0.8)
    plot(c(min,max), c(0,10), type='n', bty='n', xaxt='n', xlab=", yaxt='n', ylab=", main=title)
    axis(1, c(0, 0.5, 1))
    for (i in 1:(length(lut)-1)) {
      x = (i-1)/scale + min
      rect(x,0,x+1/scale,10, col=lut[i], border=NA)
    }
}

pal  =  colorRampPalette(c("grey50", "maroon", "magenta2"))(101)
vert.clrs  =  sapply(states(mcPreg), function(x) pal[1+round(100*premat[x,"Preterm"])])
vert.sz  =  4 + 2*sapply(states(mcPreg),
              function(x) nrow(unique(sample_data(ps)[sample_data(ps)$CST==x,"SubjectID"])))
vert.sz  =  vert.sz * 0.85
vert.font.clrs  =  c("white", "white", "white", "white", "white")

# E(netMC) to see edge list, have to define loop angles individually by the # in edge list, not vertex
edge.loop.angle = c(0, 0, 0, 0, 3.14, 3.14, 0, 0, 0, 0, 3.14, 0, 0, 0, 0, 0)-0.45
layout  =  matrix(c(0.6,0.95, 0.43,1, 0.3,0.66, 0.55,0.3, 0.75,0.65), nrow = 5, ncol = 2, byrow = TRUE)

# Color by association with preterm birth
layout(matrix(c(1,1,2,2), 2, 2, byrow = TRUE), heights=c(1,10))
color.bar(pal, min=0, max=1, nticks=6, title="Fraction preterm")
par(mar=c(0,1,1,1)+0.1)
edge.arrow.size=0.8
edge.arrow.width=1.4
edge.width = (15*wts + 0.1)*0.6
edge.labels  =  as.character(E(netMC)$weight/100)
edge.labels[edge.labels&lt;0.4]  =  NA  # labels only for self-loops
plotMC(mcPreg, edge.arrow.size=edge.arrow.size, edge.arrow.width = edge.arrow.width,
       edge.width=edge.width, edge.curved=edge.curved,
       vertex.color=vert.clrs, vertex.size=(vert.sz),
       vertex.label.font = 2, vertex.label.cex = 1,
       vertex.label.color = vert.font.clrs, vertex.frame.color = NA,
       layout=layout, edge.loop.angle = edge.loop.angle)
par(default.par)__</code></pre>
<p>__</p>
<p>Exercise 10.4</p>
<p><strong>Protein interaction networks</strong> : Read the Wikipedia article about the <a href="https://en.wikipedia.org/wiki/STRING">STRING</a> database (http://www.string- db.org).<br>
The protein Cyclin B1 is encoded by the CCNB1 gene. You can read about it on wikipedia here: <a href="https://en.wikipedia.org/wiki/Cyclin_B1" class="uri">https://en.wikipedia.org/wiki/Cyclin_B1</a>.<br>
Use STRING to generate a text file (call it <em>ccnb1datsmall.txt</em>) of edges around the CCNB1 gene. Choose nodes that are connected by evidence of co- expression with a confidence higher than 0.9. Collect no more than 50 interactions and additional nodes that are two steps away from CCNB1 in the graph.</p>
<p>__</p>
<p>Solution</p>
<p>__</p>
<ol type="1">
<li><p>Go to <a href="http://www.string-db.org" class="uri">http://www.string-db.org</a>.</p></li>
<li><p>Enter CCNB1 as the protein name and Homo sapiens as the organism. Click “Continue!”</p></li>
<li><p>Select the option with protein CCNB1 (the top one).</p></li>
<li><p>Scroll down to “info and Parameters …” 4a. For Active Prediction Methods – unselect everything except “Co-Expression” 4b. For required confidence – select “highest confidence (0.900) 4c. For interactors shown – select”no more than 50 interactors” 4d. For additional (white) nodes – select “100” (these are nodes two steps away from CCNB1) 4e. Click “Update Parameters”. You should get something that looks like the image below.</p></li>
<li><p>Click “save” under the picture (showing a diskette). This will open up a new window so you can choose which format to save the data.</p></li>
<li><p>Scroll down to the “Text Summary (TXT - simple tab delimited flatfile)” file and save that document as <em>ccnb1datsmall.txt</em>.</p></li>
</ol>
<p>__</p>
<p>Exercise 10.5</p>
<p>Read the txt file <em>ccnb1datsmall.txt</em> into R and make a plot of the graph using one of the graph visualization methods covered in this chapter.</p>
<p>__</p>
<p>Solution</p>
<p>__</p>
<p><a href="imgs/ccnb1img.png" title="Figure 10.32: This network was created with the STRING website by setting a 2 step neighborhood around the CCNB1 gene for co-expression levels \geq 0.900."><img src="imgs/ccnb1img.png" class="img-fluid"></a></p>
<p>Figure 10.32: This network was created with the STRING website by setting a 2 step neighborhood around the CCNB1 gene for co-expression levels \(\) 0.900.</p>
<pre><code>dat = read.table(file.path(DATA,"ccnb1datsmall.txt"), header = TRUE, comment.char = "", stringsAsFactors = TRUE)
v = levels(unlist(dat[,1:2]))        # vertex names
n = length(v)                        # number of vertices
e = matrix(match(as.character(unlist(dat[,1:2])), v),ncol=2) # edge list
w = dat$coexpression                 # edge weights __</code></pre>
<p>M is our co-expression network adjacency matrix. Since the STRING data only says if proteins i and j are co-expressed and doesn’t distinguish between (i,j) and (j,i) we want to make M symmetric (undirected) by considering the weight on (i,j) is the same as from (j,i). A is our co-expression graph adjacency matrix and we make \(A_{ij} = 1\) if they are coexpressed.</p>
<pre><code>M = matrix(0, n, n)
M[e] = w
M = M + t(M)
dimnames(M) = list(v, v)
A = 1*(M &gt; 0)__</code></pre>
<p>We use default plotting parameters and generate the graph using the package <strong><a href="https://cran.r-project.org/web/packages/igraph/">igraph</a></strong> starting with <code>e</code>, the vector of edges (an alternative is to use the adjacency matrix A).</p>
<p><em>Note:</em> We use a seed to make the graph always look the same. Graph layout often contains an optimization with a random component that makes the picture look different, although the graph itself is the same.</p>
<pre><code>library(igraph)
net = network(e, directed=FALSE)
par(mar=rep(0,4))
plot(net, label=v)__</code></pre>
<p>You could make a graph with <strong><a href="https://cran.r-project.org/web/packages/ggraph/">ggraph</a></strong>.</p>
<p>__</p>
<p>Exercise 10.6</p>
<p>Make a heatmap showing the adjacency matrix of the graph created in Exercise 10.5.</p>
<p>__</p>
<p>Solution</p>
<p>__</p>
<p>We use defaults in making a heatmap except for changing the colors, you can experiment and add additional parameters.</p>
<pre><code>breaks  =  c(0, seq(0.9, 1, length=11))
cols  =  grey(1-c(0,seq(0.5,1,length=10)))
ccnb1ind  =  which(v == "CCNB1")
vcols  =  rep("white",n)
vcols[ccnb1ind]  =  "blue"
vcols[which(M[,ccnb1ind]&gt;0 | M[ccnb1ind,])]  =  "red"
par(mar = rep(0, 4))
heatmap(M, symm = TRUE, ColSideColors = vcols, RowSideColors = vcols,
        col = cols, breaks = breaks,  frame = TRUE)
legend("topleft", c("Neighbors(CCNB1)", "CCNB1"),
       fill = c("red","blue"),
       bty = "n", inset = 0, xpd = TRUE,  border = FALSE)__</code></pre>
<p><a href="10-chap_files/figure- html/fig-heatmapCCNB1-1.png" title="Figure 10.33: This represents the adjacency of the CCNB1 network – 2 step neighborhood with co-expression levels \geq 0.900, generated from R (darker is closer to 1, we ignore values < 0.9)."><img src="10-chap_files/figure-html/fig-heatmapCCNB1-1.png" class="img-fluid"></a></p>
<p>Figure 10.33: This represents the adjacency of the CCNB1 network – 2 step neighborhood with co-expression levels \(\) 0.900, generated from R (darker is closer to 1, we ignore values &lt; 0.9).</p>
<p>__</p>
<p>Exercise 10.7</p>
<p>The visualization shows the strongest interactions in the two step neighborhood of CCNB1. Both the plotted graph and the heatmap image show the same data: there seems to be a cluster of proteins which are all similar to CCNB1 and there is also another cluster in the other proteins. Many of the proteins in the CCNB1 cluster are coexpressed at the same time as each other.<br>
Why might this be the case?<br>
Conversely, proteins which are coexpressed with a protein that is coexpressed with CCNB1 (two steps away) do not tend to be coexpressed with each other.<br>
Is it easier for you to see this in one of the figures (the plot or the heatmap) than the other?</p>
<p>__</p>
<p>Exercise 10.8</p>
<p>Compare the use of <strong><a href="https://cran.r-project.org/web/packages/ape/">ape</a></strong> and <strong><a href="https://cran.r-project.org/web/packages/phangorn/">phangorn</a></strong> in the analysis of HIV GAG data. Compute the Jukes Cantor distances between the sequences using both packages and compare them to the Hamming distances.</p>
<pre><code>library("ape")
library("phangorn")
GAG = read.dna(file.path(DATA, "DNA_GAG_20.txt"))__</code></pre>
<p>__</p>
<p>Exercise 10.9</p>
<p>Perform the Friedman–Rafksy type test with a “two-nearest” neighbor-graph using the Bray-Curtis dissimilarity.</p>
<p>__</p>
<p>Solution</p>
<p>__</p>
<pre><code>gt = graph_perm_test(ps1, "family_relationship", distance = "bray", 
                     grouping = "host_subject_id", type = "knn", knn = 2)
gt$pval __


[1] 0.004


plot_test_network(gt)
permdf = data.frame(perm=gt$perm)
obs = gt$observed
ymax = max(gt$perm)
ggplot(permdf, aes(x = perm)) + geom_histogram(bins = 20) +
  geom_segment(aes(x = obs, y = 0, xend = obs, yend = ymax/10), color = "red") +
  geom_point(aes(x = obs, y = ymax/10), color = "red") + xlab("Number of pure edges")__</code></pre>
<p><a href="10-chap_files/figure- html/fig-knn-2-plot-1.png" title="Figure 10.34 (a): \text{}"><img src="10-chap_files/figure-html/fig-knn-2-plot-1.png" class="img-fluid"></a></p>
<ol type="a">
<li>\(\)</li>
</ol>
<p><a href="10-chap_files/figure- html/fig-knn-2-plot-2.png" title="Figure 10.34 (b): \text{}"><img src="10-chap_files/figure-html/fig-knn-2-plot-2.png" class="img-fluid"></a></p>
<ol start="2" type="a">
<li>\(\)</li>
</ol>
<p>Figure 10.34: The graph (a) and permutation histogram (b) obtained from a two nearest-neighbor graph with Jaccard similarity.</p>
<p>Beisser, Daniela, Gunnar W Klau, Thomas Dandekar, Tobias Müller, and Marcus T Dittrich. 2010. “BioNet: An R-Package for the Functional Analysis of Biological Networks.” <em>Bioinformatics</em> 26 (8): 1129–30.</p>
<p>Benjamini, Yoav, and Marina Bogomolov. 2014. “Selective Inference on Multiple Families of Hypotheses.” <em>Journal of the Royal Statistical Society: Series B</em> 76 (1): 297–318.</p>
<p>Benjamini, Yoav, and Daniel Yekutieli. 2003. “Hierarchical FDR Testing of Trees of Hypotheses.” Technical report, Department of Statistics; Operations Research, Tel Aviv University.</p>
<p>Bhattacharya, Bhaswar B. 2015. “Power of Graph-Based Two-Sample Tests.” <em>arXiv Preprint arXiv:1508.07530</em>.</p>
<p>Bouckaert, Remco, Joseph Heled, Denise Kühnert, Tim Vaughan, Chieh-Hsi Wu, Dong Xie, Marc A Suchard, Andrew Rambaut, and Alexei J Drummond. 2014. “BEAST 2: A Software Platform for Bayesian Evolutionary Analysis.” <em>PLoS Computational Biology</em> 10 (4): e1003537.</p>
<p>Callahan, Benjamin J, Paul J McMurdie, and Susan P Holmes. 2017. “Exact Sequence Variants Should Replace Operational Taxonomic Units in Marker Gene Data Analysis.” <em>ISME Journal</em> , 1–5.</p>
<p>Chakerian, John, and Susan Holmes. 2012. “Computational Tools for Evaluating Phylogenetic and Hierarchical Clustering Trees.” <em>Journal of Computational and Graphical Statistics</em> 21 (3): 581–99.</p>
<p>Cole, J. R., Q. Wang, E. Cardenas, J. Fish, B. Chai, R. J. Farris, A. S. Kulam-Syed-Mohideen, et al.&nbsp;2009. “The Ribosomal Database Project: Improved Alignments and New Tools for rRNA Analysis.” <em>Nucleic Acids Research</em> 37 (Supplement 1): D141–45.</p>
<p>DiGiulio, Daniel B., Benjamin J. Callahan, Paul J. McMurdie, Elizabeth K. Costello, Deirdre J. Lyelle, Anna Robaczewska, Christine L. Sun, et al.&nbsp;2015. “Temporal and Spatial Variation of the Human Microbiota During Pregnancy.” <em>PNAS</em>.</p>
<p>Felsenstein, Joseph. 2004. <em>Inferring Phylogenies</em>. Boston: Sinauer.</p>
<p>Friedman, Jerome H, and Lawrence C Rafsky. 1979. “Multivariate Generalizations of the Wald-Wolfowitz and Smirnov Two-Sample Tests.” <em>The Annals of Statistics</em> , 697–717.</p>
<p>Fukuyama, Julia, Paul J McMurdie, Les Dethlefsen, David A Relman, and Susan Holmes. 2012. “Comparisons of Distance Methods for Combining Covariates and Abundances in Microbiome Studies.” In <em>Pac Symp Biocomput</em>. World Scientific.</p>
<p>Holmes, Susan. 1999. “Phylogenetic Trees: An Overview.” In <em>Statistics and Genetics</em> , 81–118. IMA 112. New York: Springer.</p>
<p>———. 2003a. “Bootstrapping Phylogenetic Trees: Theory and Methods.” <em>Statistical Science</em> 18 (2): 241–55.</p>
<p>———. 2003b. “Statistics for phylogenetic trees.” <em>Theoretical Population Biology</em> 63 (1): 17–32.</p>
<p>Ideker, Trey, Owen Ozier, Benno Schwikowski, and Andrew F Siegel. 2002. “Discovering Regulatory and Signalling Circuits in Molecular Interaction Networks.” <em>Bioinformatics</em> 18 Suppl 1 (January): S233–40. <a href="http://bioinformatics.oxfordjournals.org/cgi/reprint/18/suppl\_1/S233" class="uri">http://bioinformatics.oxfordjournals.org/cgi/reprint/18/suppl\_1/S233</a>.</p>
<p>Li, Wen-Hsiung. 1997. <em>Molecular Evolution.</em> Sinauer Associates Incorporated.</p>
<p>Li, Wen-Hsiung, and Dan Graur. 1991. <em>Fundamentals of Molecular Evolution</em>. Vol. 48. Sinauer Associates Sunderland, MA.</p>
<p>Liberzon, Arthur, Aravind Subramanian, Reid Pinchback, Helga Thorvaldsdóttir, Pablo Tamayo, and Jill P Mesirov. 2011. “Molecular Signatures Database (MSigDB) 3.0.” <em>Bioinformatics</em> 27 (12): 1739–40.</p>
<p>Love, Michael I, Wolfgang Huber, and Simon Anders. 2014. “Moderated Estimation of Fold Change and Dispersion for RNA-seq Data with DESeq2.” <em>Gnome Biology</em> 15 (12): 1–21.</p>
<p>McMurdie, Paul J, and Susan Holmes. 2014. “Waste Not, Want Not: Why Rarefying Microbiome Data Is Inadmissible.” <em>PLoS Computational Biology</em> 10 (4): e1003531.</p>
<p>———. 2015. “Shiny-Phyloseq: Web Application for Interactive Microbiome Analysis with Provenance Tracking.” <em>Bioinformatics</em> 31 (2): 282–83.</p>
<p>Mossel, Elchanan. 2003. “On the Impossibility of Reconstructing Ancestral Data and Phylogenies.” <em>Journal of Computational Biology</em> 10 (5): 669–76.</p>
<p>Nacu, Serban, Rebecca Critchley-Thorne, Peter Lee, and Susan Holmes. 2007. “Gene Expression Network Analysis and Applications to Immunology.” <em>Bioinformatics</em> 23 (7, 7): 850–58. <a href="https://doi.org/10.1093/bioinformatics/btm019" class="uri">https://doi.org/10.1093/bioinformatics/btm019</a>.</p>
<p>Nolan, Daniel J, Michael Ginsberg, Edo Israely, Brisa Palikuqi, Michael G Poulos, Daylon James, Bi-Sen Ding, et al.&nbsp;2013. “Molecular Signatures of Tissue-Specific Microvascular Endothelial Cell Heterogeneity in Organ Maintenance and Regeneration.” <em>Developmental Cell</em> 26 (2): 204–19.</p>
<p>Paradis, Emmanuel. 2011. <em>Analysis of Phylogenetics and Evolution with r</em>. Springer Science &amp; Business Media.</p>
<p>Pounds, Stan, and Stephan W Morris. 2003. “Estimating the Occurrence of False Positives and False Negatives in Microarray Studies by Approximating and Partitioning the Empirical Distribution of p-Values.” <em>Bioinformatics</em> 19 (10): 1236–42.</p>
<p>Purdom, Elizabeth. 2010. “Analysis of a Data Matrix and a Graph: Metagenomic Data and the Phylogenetic Tree.” <em>Annals of Applied Statistics</em> , July.</p>
<p>Rhee, Soo-Yon, Matthew J Gonzales, Rami Kantor, Bradley J Betts, Jaideep Ravela, and Robert W Shafer. 2003. “Human Immunodeficiency Virus Reverse Transcriptase and Protease Sequence Database.” <em>Nucleic Acids Research</em> 31 (1): 298–303.</p>
<p>Robins, Garry, Tom Snijders, Peng Wang, Mark Handcock, and Philippa Pattison. 2007. “Recent Developments in Exponential Random Graph (p*) Models for Social Networks.” <em>Social Networks</em> 29 (2): 192–215.</p>
<p>Ronquist, Fredrik, Maxim Teslenko, Paul van der Mark, Daniel L Ayres, Aaron Darling, Sebastian Höhna, Bret Larget, Liang Liu, Marc A Suchard, and John P Huelsenbeck. 2012. “MrBayes 3.2: Efficient Bayesian Phylogenetic Inference and Model Choice Across a Large Model Space.” <em>Systematic Biology</em> 61 (3): 539–42.</p>
<p>Sankaran, Kris, and Susan Holmes. 2014. “structSSI: Simultaneous and Selective Inference for Grouped or Hierarchically Structured Data.” <em>Journal of Statistical Software</em> 59 (1): 1–21.</p>
<p>Schilling, Mark F. 1986. “Multivariate Two-Sample Tests Based on Nearest Neighbors.” <em>Journal of the American Statistical Association</em> 81 (395): 799–806.</p>
<p>Schölkopf, Bernhard, Koji Tsuda, and Jean-Philippe Vert. 2004. <em>Kernel Methods in Computational Biology</em>. MIT press.</p>
<p>Wang, Q., G. M. Garrity, J. M. Tiedje, and J. R. Cole. 2007. “Naive Bayesian Classifier for Rapid Assignment of rRNA Sequences into the New Bacterial Taxonomy.” <em>Applied and Environmental Microbiology</em> 73 (16): 5261.</p>
<p>Wertheim, Joel O, and Michael Worobey. 2009. “Dating the Age of the SIV Lineages That Gave Rise to HIV-1 and HIV-2.” <em>PLoS Computational Biology</em> 5 (5): e1000377.</p>
<p>Wright, Erik S. 2015. “DECIPHER: Harnessing Local Sequence Context to Improve Protein Multiple Sequence Alignment.” <em>BMC Bioinformatics</em> 16 (1): 1.</p>
<p>Yu, Hongxiang, Diana L Simons, Ilana Segall, Valeria Carcamo-Cavazos, Erich J Schwartz, Ning Yan, Neta S Zuckerman, et al.&nbsp;2012. “PRC2/EED-EZH2 Complex Is up-Regulated in Breast Cancer Lymph Node Metastasis Compared to Primary Tumor and Correlates with Tumor Proliferation in Situ.” <em>PloS One</em> 7 (12): e51239.</p>
<p>Page built at 01:33 on 2025-09-01 using R version 4.5.1 (2025-06-13)</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./09-chap.html" class="pagination-link" aria-label="9.1 이 장의 목표">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">9.1 이 장의 목표</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./11-chap.html" class="pagination-link" aria-label="11.1 이 장의 목표">
        <span class="nav-page-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">11.1 이 장의 목표</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>