![](imgs/StatDiagram.png)

이전 장에서 생성 모델과 매개변수 값에 대한 지식은 의사 결정에 사용할 수 있는 확률(예: 실제로 에피토프를 찾았는지 여부)을 제공했습니다. 많은 실제 상황에서는 생성 모델이나 매개변수가 모두 알려져 있지 않으며 수집된 데이터를 사용하여 이를 추정해야 합니다. 통계 모델링은 데이터를 _상향으로_ 시작하여 데이터를 _아마도_ 그럴듯하게 설명하는 모델1로 작동합니다. 이러한 상향 추론 단계를 통계적 **추론**이라고 합니다. 이 장에서는 추론을 위한 구성 요소 역할을 하는 분포 및 추정 메커니즘 중 일부를 보여줍니다. 이 장의 예제는 모두 매개변수적이지만(즉, 통계 모델에는 알려지지 않은 소수의 매개변수만 있음) 우리가 논의하는 원리는 일반화됩니다.


1 현재 데이터를 모두 완벽하게 설명하는 모델을 찾았다고 해도 현실은 항상 더 복잡할 수 있습니다. 새로운 데이터 세트를 통해 다른 모델이 필요하다는 결론을 내릴 수 있으며 현재 모델을 특수 사례 또는 근사치로 포함할 수 있습니다.


[![통계 설정에서는 데이터 X로 시작하여 이를 사용하여 매개변수를 추정합니다. 이러한 추정치는 \\widehat{\\theta}에서와 같이 우리가 모자라고 부르는 그리스 문자로 표시됩니다.](imgs/devil.png)](imgs/devil.png "통계 설정에서 우리는 데이터 X로 시작하여 이를 사용하여 매개변수를 추정합니다. 이러한 추정치는 \\widehat{\\theta}에서와 같이 우리가 모자라고 부르는 그리스 문자로 표시됩니다.")


통계 설정에서는 데이터 \\(X\\)로 시작하여 이를 사용하여 매개변수를 _추정_합니다. 이러한 추정치는 \\(\widehat{\theta}\\)와 같이 우리가 모자라고 부르는 그리스 문자로 표시됩니다.


## 2.1 이 장의 목표


이 장에서는 다음을 수행합니다.


* 종종 혼동되는 두 주제인 "확률"과 "통계" 사이에 차이가 있음을 확인하십시오.

* 히스토그램 및 기타 시각화 기법을 사용하여 데이터를 확률 분포에 맞춥니다.

* 시뮬레이션 실험을 통해 **최대 우도**라는 추정 절차를 처음 접해보세요.

* 사전 정보가 있는 데이터로부터 추론을 합니다. 이를 위해 우리는 특별히 맞춤화된 속성을 가진 새로운 분포를 포함하는 베이지안 패러다임을 사용할 것입니다. 우리는 시뮬레이션을 사용하여 베이지안 추정이 최대 우도의 단순한 적용과 어떻게 다른지 살펴보겠습니다.

* 통계 모델과 추정을 사용하여 이항 및 다항 분포의 종속성을 평가합니다.

* 테이블로 정리된 역사적으로 흥미로운 일부 게놈 데이터를 분석합니다.

* **종속** 데이터에 대한 마르코프 체인 모델을 만듭니다.

* 전체 게놈의 모티프를 계산하는 몇 가지 구체적인 응용 프로그램을 수행하고 게놈 데이터 전용 특수 생체전도체 클래스를 조작합니다.

![](imgs/Parameters.png)

**매개변수의 예**: 단일 매개변수 \\(\lambda\\)는 포아송 분포를 정의합니다. 문자 \\(\mu\\)는 정규 평균의 평균으로 자주 사용됩니다. 보다 일반적으로, 우리는 확률 모델을 지정하는 데 필요한 매개변수의 일반적인 튜플을 지정하기 위해 그리스 문자 \\(\theta\\)를 사용합니다. 예를 들어, 이항 분포의 경우 \\(\theta=(n,p)\\)는 양의 정수와 0과 1 사이의 실수라는 두 숫자로 구성됩니다.


#### 매개변수가 핵심입니다.


우리는 [1장](01-chap.html)에서 에피토프 예의 모든 매개변수 값에 대한 지식을 통해 확률 모델을 사용하고 우리가 보유한 데이터를 기반으로 귀무 가설을 테스트할 수 있음을 확인했습니다. 몇 가지 실제 사례와 컴퓨터 시뮬레이션을 통해 통계 모델링에 대한 다양한 접근 방식을 살펴보겠지만, 사용 가능한 정보의 양에 따라 두 가지 상황을 구별하는 것부터 시작하겠습니다.


## 2.2 통계모델과 확률모델의 차이점


확률적 분석은 데이터의 무작위성에 대한 좋은 생성 모델을 알고 _그리고_ 해당 매개변수의 실제 값을 알 때 가능합니다.


[![](imgs/ProbaDiagram.png)](imgs/ProbaDiagram.png "그림 2.1: 초 생성에서 얻은 확률 모델. 데이터는 녹색으로 x로 표시됩니다. \\theta의 실제 값을 알면 x의 가능한 모든 인스턴스, 특히 우리가 관찰한 x에 대해 x를 관찰할 확률을 계산할 수 있습니다.")


그림 2.1: [1장](01-chap.html)에서 얻은 확률 모델. 데이터는 녹색으로 \\(x\\)로 표시됩니다. \\(\theta\\)의 실제 값을 안다면 \\(x\\)의 가능한 모든 인스턴스, 특히 우리가 관찰한 \\(x\\)에 대해 \\(x\\)를 관찰할 확률을 계산할 수 있습니다.


에피토프 예에서 위양성(false positives)이 위치당 베르누이(0.01)로 발생한다는 것을 알고, 분석된 환자 샘플의 수와 단백질의 길이는 _알 수 없는 매개변수가 없음_을 의미합니다.


그러한 경우, 우리는 수학적 **추론**을 사용하여 그림 2.1에 도식화된 사건의 확률을 계산할 수 있습니다. 에피토프 예에서는 주어진 매개변수 \\(\lambda=0.5\\)를 사용하여 포아송 확률을 **널 모델**로 사용했습니다. 우리는 수학적 추론을 통해 7 이상의 최대값을 볼 가능성이 약 \\(10^{-4}\\)이므로 실제로 관찰된 데이터가 해당 모델(또는 "귀무가설") 하에서는 거의 발생하지 않는다는 결론을 내릴 수 있었습니다.


이제 우리가 환자 수와 단백질의 길이(이것은 실험 설계에 의해 제공됨)를 알고 있지만 분포 자체와 위양성률은 알지 못한다고 가정합니다. 데이터를 관찰한 후에는 확률 모델 \\(F\\)(푸아송, 정규, 이항)과 해당 모델에 대한 누락된 매개변수를 모두 추정하기 위해 데이터에서 _위로_ 이동해야 합니다. 이것이 이번 장에서 설명할 통계적 **추론** 유형입니다.


## 2.3 통계 모델링의 간단한 예


#### 데이터부터 시작하세요


모델링 절차는 두 부분으로 구성됩니다. 먼저 데이터 생성 프로세스를 모델링하려면 합리적인 확률 _분포_가 필요합니다. [1장](01-chap.html)에서 본 것처럼 이산형 카운트 데이터는 이항, 다항 또는 포아송 분포와 같은 간단한 확률 분포로 모델링될 수 있습니다. 정규 분포 또는 종 모양의 곡선은 연속 측정에 적합한 모델인 경우가 많습니다. 배포판은 이러한 기본 배포판의 더 복잡한 혼합일 수도 있습니다(자세한 내용은 [4장](04-chap.html) 참조).


까다로운 이상치 없이 시작하여 이전 장의 에피토프 예를 다시 살펴보겠습니다.




load("../data/e100.RData") e99 = e100[-which.max(e100)]__


#### 적합도 : 육안평가


첫 번째 단계는 후보 분포에서 적합성을 찾는 것입니다. 이를 위해서는 그래픽 및 정량적 적합도 플롯에 대한 컨설팅이 필요합니다. 이산형 데이터의 경우 그림 2.2와 같이 빈도 막대 그래프를 그릴 수 있습니다(연속형 데이터의 경우 히스토그램 참조).




barplot(table(e99), space = 0.8, col = "chartreuse4")__


[![](02-chap_files/Figure-html/fig-twopoisson-1.png)](02-chap_files/Figure-html/fig-twopoisson-1.png "그림 2.2: 이상값 없이 관찰된 에피토프 데이터 분포.")


그림 2.2: 이상치가 없는 에피토프 데이터의 관찰된 분포.


그러나 비교를 사용하지 않고는 어떤 이론적 분포가 데이터에 가장 잘 맞는지 결정하기는 어렵습니다. 하나의 시각적 **적합도** 다이어그램은 **루토그램**([Cleveland 1988](16-chap.html#ref-Tukey:1988))으로 알려져 있습니다. 이론적인 빨간색 점에서 관찰된 개수로 막대를 걸어 놓습니다. 개수가 이론적 값과 정확히 일치하는 경우 상자 아래쪽이 가로 축과 정확하게 정렬됩니다.




library("vcd") gf1 = goodfit( e99, "poisson") rootogram(gf1, xlab = "", ret_gp = gpar(fill = "chartreuse4"))__


[![](02-chap_files/Figure-html/fig-stat-rooto-1.png)](02-chap_files/Figure- html/fig-stat-rooto-1.png "그림 2.3: 이론적 값의 제곱근을 빨간색 점으로 표시하고 관찰된 주파수의 제곱근을 드롭다운 직사각형으로 표시하는 루토그램. \(goodfit 함수가 어떤 \\람다를 결정하는지 아래에서 조금 살펴보겠습니다. 사용하세요.\)")


그림 2.3: 이론적 값의 제곱근을 빨간색 점으로 표시하고 관찰된 주파수의 제곱근을 드롭다운 직사각형으로 표시하는 루트그램. (`goodfit` 함수가 어떤 \\(\lambda\\)를 사용할지 결정하는 방법을 아래에서 조금 살펴보겠습니다.)


__


질문 2.1


알려진 포아송 변수를 사용하여 이러한 플롯이 어떻게 보이는지 보정하려면 \\(\lambda\\) = 0.05와 함께 `rpois`를 사용하여 100개의 포아송 분포 숫자를 생성하고 루트그램을 그립니다.


__


해결책


__




simp = rpois(100, lambda = 0.05) gf2 = goodfit(simp, "poisson") rootogram(gf2, xlab = "")__


우리는 'e99'의 루트그램이 푸아송 모델에 합리적으로 잘 맞는 것으로 보입니다. 하지만 이를 실현하기 위해 이상값을 제거했다는 점을 기억하세요. 포아송은 포아송 평균 \\(\lambda\\)이라고 불리는 하나의 매개변수에 의해 완전히 결정됩니다. 데이터가 포아송 분포를 따른다고 추측할 수 있는 대부분의 경우 데이터에서 포아송 매개변수를 추정해야 합니다.


[![모수는 이론적 분포의 평균이고 표본 평균에 의해 추정되기 때문에 포아송 평균이라고 합니다. 이러한 단어의 오버로드는 모든 사람에게 혼란을 줍니다.](imgs/devil.png)](imgs/devil.png "이 매개변수는 이론적 분포의 평균이고, 알고 보니 표본 평균에 의해 추정되기 때문에 포아송 평균이라고 합니다. 이러한 단어의 오버로드는 모든 사람에게 혼란을 줍니다.")


이 모수는 이론적 분포의 평균이고 _그리고_ 표본 평균에 의해 추정되기 때문에 포아송 평균이라고 합니다. 이러한 단어의 과부하는 모든 사람에게 혼란을 줍니다.


\\(\lambda\\)를 추정하는 가장 일반적인 방법은 관찰된 데이터를 가장 가능성 있게 만드는 값 \\(\hat{\lambda}\\)을 선택하는 것입니다. 이를 **최대 우도 추정기**([Rice 2006, chap. 8](16-chap.html#ref-Rice:2007), 섹션 5)라고 하며, 종종 **MLE**로 축약됩니다. 우리는 다음 섹션에서 다소 역설적인 이 아이디어를 설명할 것입니다.


위에서 확률 분포를 추측하기 전에 극단적인 관찰을 수행했지만 나머지 분석을 위해 이를 사용하여 데이터로 돌아갈 것입니다. 실제로 우리는 이상값이 있는지, 그리고 그것이 어떤 데이터 포인트인지 알 수 없습니다. 그것을 그대로 두면 평균의 추정치가 더 높아지는 효과가 있습니다. 결과적으로 이는 널 모델에서 7이라는 값을 관찰할 가능성이 더 높아지며 결과적으로 더 큰 p-값이 생성됩니다. 따라서 결과 p-값이 이상값을 포함하더라도 작다면 우리의 분석은 실제적인 것임을 확신할 수 있습니다. 우리는 이러한 전술을 **보수적**이라고 부릅니다. 즉, 우리는 무언가를 감지하지 못하는 주의 측면에서 실수를 저지릅니다.


#### 포아송 분포의 모수 추정


포아송 평균의 어떤 값이 데이터를 가장 가능성 있게 만드는가? 첫 번째 단계에서는 결과를 집계합니다.




테이블(e100)__



e100 0 1 2 7 58 34 7 1


그런 다음 포아송 평균에 대한 다양한 값을 시험해 보고 어떤 값이 데이터에 가장 적합한지 확인하겠습니다. 푸아송 분포의 평균 \\(\lambda\\)가 3인 경우 개수는 다음과 같습니다.




테이블(rpois(100, 3))__



0 1 2 3 4 5 6 7 4 12 23 24 14 16 4 3


데이터에서 볼 수 있는 것보다 2와 3이 더 많습니다. 따라서 개수가 잘 일치하지 않기 때문에 \\(\lambda=3\\)이 데이터를 생성했을 가능성이 낮다는 것을 알 수 있습니다.


__


질문 2.2


\\(\lambda\\)의 다른 값을 사용하여 이 시뮬레이션을 반복합니다. 시행착오를 통해 관찰된 것과 가까운 수치를 제공하는 것을 찾을 수 있습니까?


그래서 우리는 가능한 많은 값을 시험해보고 무차별 대입으로 진행할 수 있었습니다. 그러나 우리는 좀 더 우아한 작업을 수행하고 약간의 수학을 사용하여 어떤 값이 데이터 관찰 확률을 최대화하는지 확인하겠습니다. 포아송 매개변수의 값이 \\(m\\)일 때 데이터를 볼 확률을 계산해 보겠습니다. 데이터가 독립적인 추첨에서 파생된다고 가정하므로 이 확률은 단순히 개별 확률의 곱입니다.


\\[\begin{방정식*} \begin{aligned} P(58 \times 0, 34 \times 1, 7 \times 2, \text{one }7 \;|\; \text{데이터는 포아송}(m)) = P(0)^{58}\times P(1)^{34}\times P(2)^{7}\times P(7)^{1}.\end{정렬} \end{방정식*}\\]


\\(m=3\\)에 대해 우리는 이것을 계산할 수 있습니다2.


2 여기서 R의 벡터화를 어떻게 사용하는지 주목하세요. `dpois`에 대한 호출은 4개의 서로 다른 숫자에 해당하는 4개의 값을 반환합니다. 그런 다음 '^' 연산자를 사용하여 이를 각각 58, 34, 7 및 1의 거듭제곱으로 가져오면 다시 4개의 값이 생성됩니다. 마지막으로 'prod' 함수를 사용하여 이를 하나의 숫자인 product로 축소합니다.




prod(dpois(c(0, 1, 2, 7), 람다 = 3) ^ (c(58, 34, 7, 1)))__



[1] 1.392143e-110


__


질문 2.3


\\(m=0,1,2\\)에 대해 위와 같이 확률을 계산합니다. \\(m\\)은 정수여야 합니까? 예를 들어 \\(m=0.4\\)에 대한 확률을 계산해 보세요.


__


해결책


__




prod(dpois(c(0, 1, 2, 7), 람다 = 0.4) ^ (c(58, 34, 7, 1)))__



[1] 8.5483e-46


이 확률은 주어진 데이터에서 \\(\lambda\\)의 **우도 함수**이며 이를 씁니다.


여기서 \\(L\\)은 우도를 나타내고 \\(f(k)=e^{-\lambda} \,\lambda^k\,/\,k!\\)는 앞서 본 포아송 확률을 나타냅니다.


\\[ L\left(\lambda,\,x=(k_1,k_2,k_3,...)\right)=\prod_{i=1}^{100}f(k_i) \\]


100개의 작은 숫자를 곱하는 대신 로그를 취하는 것이 편리합니다. 로그는 엄격하게 증가하므로 로그가 구간 내에서 최대값에 도달하는 지점이 있으면 확률에 대한 최대값도 됩니다.


3 이는 일반적으로 연필과 종이, 그리고 컴퓨터 계산 모두에 해당됩니다.


4 여기서는 데이터 포인트에 대한 명시적인 루프 없이 계산을 작성할 수 있는 R의 벡터 구문을 다시 사용합니다. 위의 코드와 비교하면, 여기서는 고유한 값에 대해서만 'dpois'를 호출하기 전에 'table' 함수로 'data'를 표로 만드는 대신 100개의 데이터 포인트 각각에 대해 'dpois'를 호출합니다. 이는 결과가 동일하지만 코드를 읽는 것이 얼마나 쉬운지 또는 실행하는 데 걸리는 시간이 다를 수 있는 대체 솔루션에 대한 간단한 예입니다.


계산적인 일러스트레이션부터 시작해 보겠습니다. 우리는 포아송 매개변수의 다양한 값에 대한 가능성을 계산합니다. 이를 위해서는 다양한 값에 대한 데이터의 확률을 계산하는 작은 함수를 작성해야 합니다4.




loglikelihood  =  function(lambda, data = e100) { sum(log(dpois(data, lambda))) }__


이제 우리는 0.05에서 0.95까지 일련의 '람다' 값에 대한 우도를 계산할 수 있습니다(그림 2.4).




lambdas = seq(0.05, 0.95, length = 100) loglik = vapply(lambdas, loglikelihood, numeric(1)) plot(lambdas, loglik, type = "l", col = "red", ylab = "", lwd = 2, xlab = expression(lambda)) m0 = mean(e100) abline(v = m0, col = "blue", lwd = 2) abline(h = loglikelihood(m0), col = "purple", lwd = 2) m0 __



[1] 0.55


[![](02-chap_files/Figure-html/fig-poislikel-1-1.png)](02-chap_files/Figure- html/fig-poislikel-1-1.png "그림 2.4: 빨간색 곡선은 로그 우도 함수입니다. 수직선은 m \(평균\) 값을 나타내고 수평선은 m의 로그 우도를 나타냅니다. m이 로그 우도를 최대화하는 것처럼 보입니다. 가능성이 높습니다.")


그림 2.4: 빨간색 곡선은 로그 우도 함수입니다. 수직선은 'm'(평균) 값을 나타내고 수평선은 'm'의 로그 우도를 나타냅니다. 'm'이 가능성을 최대화하는 것 같습니다.


__


Question 2.4


위 코드에서 `vapply` 함수는 무엇을 합니까? 힌트: 매뉴얼 페이지를 확인하세요.


__


해결책


__


'vapply'는 첫 번째 인수인 이 경우 벡터 'lambdas'를 취하고 각 벡터 요소에 'loglikelihood' 함수(두 번째 인수)를 반복적으로 적용합니다. 결과적으로 결과의 벡터를 반환합니다. 이 함수에는 세 번째 인수인 'numeric(1)'도 필요합니다. 이 인수는 'loglikelihood'에 대한 각 개별 호출이 반환할 값 유형(단일 숫자)을 지정합니다. (일반적으로 함수가 때때로 문자열이나 두 개의 숫자와 같은 다른 것을 반환하는 경우가 발생할 수 있습니다. 이 경우 전체 결과를 일관된 벡터로 조합할 수 없으며 `vapply`가 불평합니다.)


실제로 'goodfit' 함수라는 지름길이 있습니다.




gf  =  goodfit(e100, "poisson") names(gf)__



[1] "관찰됨" "계산" "적합" "유형" "방법" "df" "par"



gf$파 __



$람다 [1] 0.55


'goodfit'의 출력은 목록이라는 복합 개체입니다. 해당 구성요소 중 하나는 'par'라고 하며 연구된 분포에 적합한 매개변수의 값을 포함합니다. 이 경우 추정치는 \\(\lambda\\)라는 하나의 숫자뿐입니다.


__


질문 2.5


`goodfit` 함수 출력의 다른 구성요소는 무엇입니까?


__


일


`m` 값을 이전에 \\(\lambda\\)에 사용한 값인 0.5와 비교합니다. 0.5 대신 `m`을 사용하여 [1장](01-chap.html)에서 수행한 모델링을 다시 실행하세요.


### 2.3.1 고전 데이터에 대한 고전 통계


다음은 표본 평균이 (로그) 가능성을 최대화한다는 계산 결과에 대한 공식적인 증거입니다.


\\[ \begin{align} \log L(\lambda, x) &= \sum_{i=1}^{100} - \lambda + k_i\log\lambda - \log(k_i!) \\\ &= -100\lambda + \log\lambda\left(\sum_{i=1}^{100}k_i\right) + \text{const.} \end{align} \태그{2.1}\\]


우리는 포괄적인 "const"를 사용합니다. \\(\lambda\\)에 의존하지 않는 용어의 경우(비록 \\(x\\), 즉 \\(k_i\\)에 의존하지만) 이를 최대화하는 \\(\lambda\\)를 찾기 위해 \\(\lambda\\)에서 도함수를 계산하고 이를 0으로 설정합니다.


\\[ \begin{align} \frac{d}{d\lambda}\log L &= -100 + \frac{1}{\lambda} \sum_{i=1}^{100}k_i \stackrel{?}{=}0 \\\ \lambda &= \frac{1}{100} \sum_{i=1}^{100}k_i = \bar{k} \end{align} \태그{2.2}\\]


방금 (데이터로부터) '처음부터' 시작하여 모델 매개변수를 추론하는 _통계적 접근_의 첫 번째 단계를 살펴보았습니다. 이는 데이터에서 매개변수를 통계적으로 _추정_하는 것입니다. 또 다른 중요한 구성 요소는 데이터를 모델링하는 데 사용할 분포군을 선택하는 것입니다. 그 부분은 _적합도_를 평가하여 수행됩니다. 우리는 나중에 이것을 만날 것입니다.


전통적인 _통계 테스트_ 프레임워크에서는 데이터에 대해 _null 모델_이라고 하는 하나의 단일 모델을 고려합니다. 널 모델은 모든 관찰이 어떤 그룹이나 치료에 관계없이 동일한 무작위 분포에서 나오는 것과 같이 "흥미롭지 않은" 기준선을 공식화합니다. 그런 다음 데이터가 해당 모델과 호환될 확률을 계산하여 더 흥미로운 일이 진행되고 있는지 테스트합니다. 종종 이것이 우리가 할 수 있는 최선의 방법입니다. 왜냐하면 우리는 "흥미로운", null이 아닌 모델 또는 대체 모델이 무엇인지 충분히 자세히 알지 못하기 때문입니다. 다른 상황에서는 나중에 살펴보겠지만 비교할 수 있는 두 가지 경쟁 모델이 있습니다.


__


질문 2.6


알려진 분포를 사용한 모델링의 가치는 무엇입니까? 예를 들어, 변수에 포아송 분포가 있다는 것을 아는 것이 왜 흥미로운가요?


__


해결책


__


모델은 데이터 생성 프로세스를 간결하지만 표현적으로 표현합니다. 예를 들어 푸아송의 경우 하나의 숫자를 알면 앞서 살펴본 것처럼 극단적이거나 희귀한 사건의 확률을 포함하여 분포에 대한 모든 것을 알 수 있습니다.


또 다른 유용한 방향은 **회귀**입니다. 우리는 카운트 기반 응답 변수(예: 시퀀싱 판독 카운트 결과)가 연속 공변량(예: 온도 또는 영양분 농도)에 어떻게 의존하는지 알고 싶을 수 있습니다. 우리 모델은 응답 변수 \\(y\\)가 방정식 \\(y = ax+b + e\\)를 통해 공변량 \\(x\\)에 의존하고 매개변수 \\(a\\) 및 \\(b\\)(추정해야 함)와 확률 모델이 정규 분포(일반적으로 분산도 추정해야 함)인 잔차 \\(e\\)를 사용하는 선형 회귀를 접했을 수 있습니다. 카운트 데이터의 경우 동일한 유형의 회귀 모델이 가능하지만 잔차의 확률 분포는 비정규적이어야 합니다. 이 경우 **일반화 선형 모델** 프레임워크를 사용합니다. [Chapter 8](08-chap.html)에서는 RNA-Seq을 연구할 때의 예시를, [Chapter 9](09-chap.html)에서는 또 다른 차세대 시퀀싱 데이터인 16S rRNA 데이터를 살펴보겠습니다.


확률 모델에 포아송, 이항, 다항 분포 또는 기타 매개변수 계열이 포함되어 있다는 사실을 알면 모델 매개변수에 대한 질문에 대한 빠른 답변을 얻고 p-값 및 신뢰 구간과 같은 수량을 계산할 수 있습니다.


## 2.4 이항분포와 최대우도


이항 분포에는 두 가지 매개변수가 있습니다. 일반적으로 알려진 시행 횟수 \\(n\\)와 시행에서 1이 나올 확률 \\(p\\)입니다. 이 확률은 종종 알려지지 않았습니다.


### 2.4.1 예


\\(n=120\\)명의 남성 샘플을 채취하여 적록색맹 여부를 테스트한다고 가정해 보겠습니다. 대상이 색맹이 아닌 경우 데이터를 0으로, 색맹인 경우 1로 코딩할 수 있습니다. 데이터를 표로 요약합니다.




테이블(CB)__



CB 0 1 110 10


__


질문 2.7


주어진 데이터에서 가장 가능성이 높은 \\(p\\) 값은 무엇입니까?


__


해결책


__


\\(\hat{p}=\frac{1}{12}\\).




평균(cb)__



[1] 0.08333333


[![그러나 주의하세요. 최대 우도 추정치는 추측하고 계산하기 어려울 뿐만 아니라 훨씬 덜 직관적이기도 합니다\(연습 imp-models-mlmax\ 참조).](imgs/devil.png)](imgs/devil.png "그러나 주의하세요: 때때로 최대 우도 추정치는 추측하고 계산하기 어려울 뿐만 아니라 훨씬 덜 직관적입니다\(연습 imp-models-mlmax\ 참조).")


그러나 조심하세요. 최대 우도 추정치는 추측하고 계산하기가 더 어려울 뿐만 아니라 훨씬 덜 직관적이기도 합니다(연습 2.2 참조).


이 특별한 경우에는 직관으로 추정값 \\(\hat{p}=\frac{1}{12}\\)을 얻을 수 있으며, 이는 최대 우도 추정값으로 판명됩니다. 우리는 이것이 (반드시) 기본 실제 값이 아니라 데이터에서 얻은 추정치임을 상기시키기 위해 편지 위에 모자를 썼습니다.


포아송의 경우 이전과 마찬가지로 가능한 많은 \\(p\\)에 대한 우도를 계산하면 이를 플롯하고 최대값이 떨어지는 위치를 확인할 수 있습니다(그림 2.5).




probs  =  seq(0, 0.3, by = 0.005) likelihood = dbinom(sum(cb), prob = probs, size = length(cb)) plot(probs, likelihood, pch = 16, xlab = "probability of success", ylab = "likelihood", cex=0.6) probs[which.max(likelihood)]__



[1] 0.085


[![](02-chap_files/Figure-html/fig-likely1-1-1.png)](02-chap_files/Figure- html/fig-likely1-1-1.png "그림 2.5: 확률의 함수로 나타낸 우도 플롯. 우도는 \[0, 1\]에 대한 함수입니다. 여기서는 \[0, 0.3\] 범위를 확대했습니다. 더 큰 p 값에 대한 가능성은 사실상 0이기 때문입니다.")


그림 2.5: 확률의 함수로 우도를 도표로 나타낸 것입니다. 가능성은 \\([0, 1]\\)의 함수입니다. 여기서는 \\([0, 0.3]\\)의 범위를 확대했습니다. \\(p\\)의 더 큰 값에 대한 가능성은 사실상 0이기 때문입니다.


참고: 0.085는 정확히 우리가 기대한 값 \\((\frac{1}{12})\\)이 아닙니다. 이는 우리가 시도한 값 집합(`probs`에서)에 \\(\frac{1}{12}\simeq 0.0833\\)의 정확한 값이 포함되지 않았기 때문에 차선책을 얻었기 때문입니다. 이를 극복하기 위해 수치 최적화 방법을 사용할 수 있습니다.


### 2.4.2 이항분포의 가능성


[![최대 우도와는 다른 기준을 제시할 수 있으며, 이는 다른 추정기로 이어집니다. 그들은 모두 모자를 가지고 다닙니다. 초-혼합에서 다른 예를 볼 수 있습니다.](imgs/devil.png)](imgs/devil.png "최대 우도와는 다른 기준을 제시할 수 있으며, 이는 다른 추정기로 이어집니다. 그들은 모두 모자를 가지고 있습니다. 우리는 초-혼합에서 다른 예를 볼 것입니다.")


최대 우도와는 다른 기준을 제시하여 다른 추정기로 이어질 수 있습니다. 그들은 모두 모자를 가지고 다닙니다. 다른 예시는 [4장](04-chap.html)에서 살펴보겠습니다.


가능성과 확률은 동일한 수학적 함수이며 다른 방식으로만 해석됩니다. 어떤 경우에는 함수가 매개변수가 주어졌을 때 데이터의 특정 값 집합을 볼 가능성이 얼마나 되는지 알려줍니다. 다른 경우에는 데이터를 주어진 것으로 간주하고 이러한 데이터를 생성했을 가능성이 있는 매개변수 값을 요청합니다. \\(n=300\\)을 가정하고 \\(y=40\\) 성공을 관찰합니다. 그런 다음 이항 분포의 경우:


\\[ f(p\,|\,n,y) = f(y\,|\,n,p)={n \y 선택} \, p^y \, (1-p)^{(n-y)}. \태그{2.3}\\]


다시 말하지만, 우도의 로그를 사용하여 작업하는 것이 더 편리합니다.


\\[ \log f(p |y) = \log {n \y 선택} + y\log(p) + (n-y)\log(1-p). \태그{2.4}\\]


다음은 이를 계산하는 데 사용할 수 있는 함수입니다5,


5 실제로는 'choose(n, y)'를 명시적으로 계산하는 것을 피하려고 합니다. 이는 컴퓨터의 부동 소수점 연산의 한계를 테스트하는 매우 큰 숫자일 수 있기 때문입니다(`n=300` 및 `y=40`의 경우 약 9.8e+49입니다). 최대화에 영향을 주지 않는 \\(p\\)와 무관한 추가 오프셋일 뿐이므로 스털링 공식을 사용하여 항을 근사화하거나 실제로 무시할 수 있습니다.




loglikelihood = function(p, n = 300, y = 40) { log(choose(n, y)) + y * log(p) + (n - y) * log(1 - p) }__


0에서 1까지의 \\(p\\) 범위를 플롯합니다(그림 2.6).




p_seq = seq(0, 1, by = 0.001) plot(p_seq, loglikelihood(p_seq), xlab = "p", ylab = "log f(p|y)", type = "l")__


[![](02-chap_files/Figure-html/fig-loglikelihood-1-1.png)](02-chap_files/Figure-html/fig-loglikelihood-1-1.png "그림 2.6: n=300 및 y=40에 대한 로그 우도 함수 플롯.")


그림 2.6: \\(n=300\\) 및 \\(y=40\\)에 대한 로그 우도 함수 플롯.


최대값은 40/300 = 0.1333... 에 있으며 직관과 일치하지만 함수가 최대값 주위에서 매우 균일하므로 \\(p\\)의 다른 값이 거의 동일할 가능성이 있음을 알 수 있습니다. 우리는 베이지안 방법을 사용하여 단일 최대값을 선택하는 대신 \\(p\\)에 대한 값 범위로 작업할 수 있는 방법을 이후 섹션에서 살펴보겠습니다.


## 2.5 추가 상자:다항 데이터


### 2.5.1 DNA 수 모델링: 염기쌍


DNA에는 네 가지 기본 분자가 있습니다: A - 아데닌, C - 시토신, G - 구아닌, T - 티민. 뉴클레오티드는 퓨린(A와 G)과 피리미딘(C와 T)의 두 그룹으로 분류됩니다. 이항식은 퓨린/피리미딘 그룹화에 대한 모델로 작동하지만 A, C, G, T를 사용하려는 경우에는 작동하지 않습니다. 이를 위해서는 [섹션 1.4](01-chap.html#sec-generative-multinomial)의 다항 모델이 필요합니다. 이러한 주파수에서 발생하는 눈에 띄는 패턴을 살펴보겠습니다.


### 2.5.2 뉴클레오티드 편향


이 섹션에서는 실제 사례에서 시뮬레이션을 통한 추정과 테스트를 결합합니다. _Staphylococcus aureus_ 박테리아 유전자에 대한 DNA 한 가닥의 데이터는 _fasta_ 파일 'staphsequence.ffn.txt'에서 확인할 수 있으며, Bioconductor 패키지 **[Biostrings](https://bioconductor.org/packages/Biostrings/)**의 기능을 사용하여 읽을 수 있습니다.




library("바이오스트링") staph = readDNAStringSet("../data/staphsequence.ffn.txt", "fasta")__


첫 번째 유전자를 살펴보겠습니다.




포도상구균[1]__



길이가 1인 DNAStringSet 개체: 너비 seq 이름 [1] 1362 ATGTCGGAAAAAGAAATTTGGGA...AAAAAGAAATAAGAAATGTATAA lcl|NC_002952.2_c...



letterFrequency(staph[[1]], 문자 = "ACGT", OR = 0)__



A C G T 522 219 229 392


__


질문 2.8


두 번째 줄에 이중 대괄호를 사용한 이유는 무엇입니까?


__


해결책


__


이중 대괄호 `[[i]]`는 단일 _DNAString_이 포함된 _DNAStringSet_를 반환하는 단일 괄호 `[i]` 쌍과 반대로 `i` 번째 유전자의 시퀀스를 _DNAString_로 추출합니다. `staph[1]`의 길이를 보면 1인데 `staph[[1]]`의 길이는 1362이다.


__


질문 2.9


[연습 1.8](01-chap.html#imp-generative-genomefrequency)과 유사한 절차에 따라 뉴클레오티드가 이 첫 번째 유전자의 4개 뉴클레오티드에 걸쳐 균등하게 분포되어 있는지 테스트합니다.


물리적 특성이 다르기 때문에 진화 선택은 뉴클레오티드 빈도에 영향을 미칠 수 있습니다. 따라서 우리는 이 데이터의 처음 10개 유전자가 동일한 다항식에서 나온 것인지 물어볼 수 있습니다. 우리는 사전 참고 자료가 없으며 처음 10개 유전자에서 뉴클레오티드가 동일한 비율로 나타나는지 여부만 결정하고 싶습니다. 그렇지 않다면, 이는 이들 10개 유전자에 대한 선택압이 다양하다는 증거를 제공할 것입니다.




letterFrq = vapply(staph, letterFrequency, FUN.VALUE = numeric(4), letters = "ACGT", OR = 0) colnames(letterFrq) = paste0("gene", seq(along = staph)) tab10 = letterFrq[, 1:10] computeProportions = function(x) { x/sum(x) } prop10 = apply(tab10, 2, computeProportions) round(prop10, digits = 2)__



유전자1 유전자2 유전자3 유전자4 유전자5 유전자6 유전자7 유전자8 유전자9 유전자10 A 0.38 0.36 0.35 0.37 0.35 0.33 0.33 0.34 0.38 0.27 C 0.16 0.16 0.13 0.15 0.15 0.15 0.16 0.16 0.14 0.16G 0.17 0.17 0.23 0.19 0.22 0.22 0.20 0.21 0.20 0.20 T 0.29 0.31 0.30 0.29 0.27 0.30 0.30 0.29 0.28 0.36



p0 = rowMeans(prop10) p0 __



A C G T 0.3470531 0.1518313 0.2011442 0.2999714


따라서 'p0'가 10개 유전자 모두에 대한 다항 확률의 벡터라고 가정하고 몬테카를로 시뮬레이션을 사용하여 이 가정 하에서 관찰된 문자 빈도와 예상 값 사이의 차이가 타당한 범위 내에 있는지 여부를 테스트해 보겠습니다.


우리는 확률 벡터 p0의 '외부' 곱과 10개 열 각각의 뉴클레오티드 개수 합계 'cs'를 취하여 예상 개수를 계산합니다.




cs = colSums(tab10) cs __



유전자1 유전자2 유전자3 유전자4 유전자5 유전자6 유전자7 유전자8 유전자9 유전자10 1362 1134 246 1113 1932 2661 831 1515 1287 696



expectedtab10 = outer(p0, cs, FUN = "*") round(expectedtab10)__



유전자1 유전자2 유전자3 유전자4 유전자5 유전자6 유전자7 유전자8 유전자9 유전자10 A 473 394 85 386 671 924 288 526 447 242 C 207 172 37 169 293 404 126 230 195 106 G 274 228 49 224 389 535 167 305 259 140 티 409 340 74 334 580 798 249 454 386 209


이제 `rmultinom` 함수를 사용하여 올바른 열 합계를 포함하는 무작위 테이블을 만들 수 있습니다. 이 테이블은 실제 비율이 'p0'에 의해 제공된다는 귀무가설에 따라 생성됩니다.




randomtab10 = sapply(cs, function(s) { rmultinom(1, s, p0) } ) all(colSums(randomtab10) == cs)__



[1] 사실


이제 이것을 B = 1000번 반복합니다. 각 테이블에 대해 [1장](01-chap.html)의 [섹션 1.4.1](01-chap.html#sec-generative-SimlatingForPower)(`stat` 함수)에서 테스트 통계를 계산하고 결과를 벡터 `simulstat`에 저장합니다. 이 값들은 'p0'가 10개 유전자 각각에 대한 다항 비율의 벡터라는 귀무 가설 하에서 생성되었으므로 함께 귀무 분포를 구성합니다.




stat = function(obsvd, exptd) { sum((obsvd - exptd)^2 / exptd) } B = 1000 simulstat = replicate(B, { randomtab10 = sapply(cs, function(s) { rmultinom(1, s, p0) }) stat(randomtab10, expectedtab10) }) S1 = stat(tab10, expectedtab10) sum(simulstat >= S1)__



[1] 0



hist(simulstat, col = "라벤더", break = seq(0, 75, length.out=50)) abline(v = S1, col = "빨간색") abline(v = Quantile(simulstat, probs = c(0.95, 0.99)), col = c("darkgreen", "blue"), lty = 2)__


[![](02-chap_files/Figure-html/fig-퀀트12-1-1.png)](02-chap_files/Figure- html/fig-Quant12-1-1.png "그림 2.7: simulstat의 히스토그램. S1의 값은 빨간색 수직 선으로 표시되고, 0.95 및 0.99 분위수 \(다음 섹션 참조\)는 점선.")


그림 2.7: `simulstat`의 히스토그램. 'S1'의 값은 빨간색 수직선으로 표시되고, 0.95 및 0.99 분위수(다음 섹션 참조)의 값은 점선으로 표시됩니다.


히스토그램은 그림 2.7에 나와 있습니다. _null 모델_에서는 `S1`=70.1만큼 큰 값을 볼 확률이 매우 작다는 것을 알 수 있습니다. 1000번의 시뮬레이션에서 'S1'만큼 큰 값이 발생한 경우는 0번 발생했습니다. 따라서 10개의 유전자는 동일한 다항 모델에서 나온 것 같지 않습니다.


## 2.6 \\(\chi^2\\) 분포


사실, 우리는 이러한 시뮬레이션을 실행하지 않고도 통계 이론을 사용하여 동일한 결론에 도달할 수 있었습니다. `simulstat` 통계의 이론적 분포는 매개변수가 30(\\(=10\times(4-1)\\))인 \\(\chi^2\\)(카이제곱) 분포6라고 합니다. 이것을 `S1` \\(=\\) 70.1만큼 큰 값을 가질 확률을 계산하는 데 사용할 수 있습니다. 위에서 본 것처럼 작은 확률은 Monte Carlo로 계산하기 어렵습니다. 계산의 세분성은 \\(1/B\\)이므로 이보다 작은 확률은 추정할 수 없으며 실제로 추정의 불확실성은 더 큽니다. 따라서 어떤 이론이라도 적용 가능하다면 그것은 유용한 경향이 있습니다. 또 다른 시각적 적합도 도구인 **분위수-분위수**(**QQ**) 플롯을 사용하여 우리 사례에서 이론과 시뮬레이션이 얼마나 잘 일치하는지 확인할 수 있습니다. 두 개의 서로 다른 표본 또는 하나의 표본 대 이론적 모델의 두 분포를 비교할 때 히스토그램만 보는 것만으로는 충분한 정보를 얻을 수 없습니다. 우리는 각 분포의 분위수를 기반으로 하는 방법을 사용합니다.


6 엄밀히 말하면 `simulstat`의 분포는 대략 \\(\chi^2\\) 분포로 설명됩니다. 테이블의 개수가 클 경우 근사치는 특히 좋습니다.


### 2.6.1 Intermezzo: 분위수 및 분위수-분위수 도표


이전 장에서는 100개의 샘플 값 \\(x_{(1)},x_{(2)},...,x_{(100)}\\)을 주문했습니다. 22번째 백분위수를 원한다고 가정해 보겠습니다. 22번째와 23번째 값 사이의 모든 값을 사용할 수 있습니다. 즉, \\(x_{(22)} \leq c_{0.22} < x_{(23)}\\)를 충족하는 모든 값은 0.22 **분위수**(\\(c_{0.22}\\))로 허용됩니다. 즉, \\(c_{0.22}\\)는 다음과 같이 정의됩니다.


\\[ \frac{\\# x_i's \leq c_{0.22}}{n} = 0.22. \\]


[섹션 3.6.7](03-chap.html#sec-graphics-ecdf)에서는 **경험적 누적 분포** 함수(**ECDF**) \\(\hat{F}\\)를 소개하고 \\(c_{0.22}\\)의 정의가 \\(\hat{F}_n(c_{0.22}) =로 작성될 수도 있음을 확인합니다. 0.22\\). 그림 2.7에는 `simulstat` 분포에 대한 히스토그램, 분위수 \\(c_{0.95}\\) 및 \\(c_{0.99}\\)도 표시되어 있습니다.


__


질문 2.10


1. `simulstat` 값과 무작위로 생성된 1000개의 \\(\chi^2_{30}\\) 난수를 각각 50개의 빈이 있는 히스토그램에 표시하여 비교합니다.

2. `simulstat` 값의 분위수를 계산하고 이를 \\(\chi_{30}^2\\) 분포의 분위수와 비교합니다. 힌트:



qs = ppoints(100) quantile(simulstat, qs) quantile(qchisq(qs, df = 30), qs)__


[![여기서 이름 충돌이 발생합니다. 통계학자들은 방금 계산한 요약 통계를 simulstat\(가중치 차이의 제곱합\), 카이제곱 또는 \\chi^2 통계라고 부릅니다. 이론적 분포 \\chi^2_\\nu는 자유도라는 매개변수 \\nu를 사용하는 그 자체의 분포입니다. 카이 제곱 또는 \\chi^2에 대해 읽을 때 어떤 의미가 적절한지 확인하기 위해 문맥에 주의를 기울여야 합니다.](imgs/devil.png)](imgs/devil.png "여기에서 이름 충돌이 발생합니다. 통계학자들은 방금 계산한 요약 통계를 simulstat \(가중치 차이의 제곱합\), 카이 제곱 또는 \\chi^2 통계라고 부릅니다. 이론적 분포 \\chi^2_\\nu 자유도라는 매개변수 \\nu를 사용하는 그 자체의 분포입니다. 카이 제곱 또는 \\chi^2에 대해 읽을 때 어떤 의미가 적절한지 확인하려면 문맥에 주의를 기울여야 합니다.")


여기서 이름 충돌이 발생합니다. 통계학자들은 방금 계산한 요약 통계를 `simulstat`(가중치 차이의 제곱합), **카이제곱** 또는 \\(\chi^2\\) _statistic_이라고 부릅니다. 이론적 _분포_ \\(\chi^2_\nu\\)는 자유도라는 매개변수 \\(\nu\\)를 사용하는 그 자체의 분포입니다. 카이제곱 또는 \\(\chi^2\\)에 대해 읽을 때 어떤 의미가 적절한지 확인하려면 문맥에 주의를 기울여야 합니다.


__


질문 2.11


0.5 분위수의 다른 이름을 알고 있나요?


__


해결책


__


중앙값.


__


질문 2.12


위의 정의에서 우리는 분위수가 일반적으로 어떻게 정의되는지에 대해 약간 모호했습니다. 즉, 0.22에 대해서만이 아닙니다. \\(1/n\\)의 배수가 아닌 숫자를 포함하여 0과 1 사이의 숫자에 대한 분위수는 어떻게 계산됩니까?


__


해결책


__


'Quantile' 함수의 매뉴얼 페이지와 'type'이라는 인수를 확인하세요.


이제 분위수가 무엇인지 알았으므로 분위수-분위수 플롯을 수행할 수 있습니다. 귀무 가설 하에서 시뮬레이션한 'simulstat' 값의 분위수를 이론적 귀무 분포 \\(\chi^2_{30}\\)에 대해 플롯합니다(그림 2.8).




qqplot(qchisq(ppoints(B), df = 30), simulstat, main = "", xlab = 표현식(chi[nu==30]^2), asp = 1, cex = 0.5, pch = 16) abline(a = 0, b = 1, col = "red")__


[![](02-chap_files/Figure-html/fig-qqplot3-1-1.png)](02-chap_files/Figure- html/fig-qqplot3-1-1.png "그림 2.8: 이론적 분위수를 보여주는 분위수-분위수 \(QQ\) 플롯을 사용하여 \\chi_{30}^2와 비교한 시뮬레이션된 통계 분포 \\chi^2_{30} 분포는 가로 축에, 샘플링된 분포는 세로 축에 표시됩니다.")


그림 2.8: QQ(분위수-분위수) 플롯을 사용하여 \\(\chi_{30}^2\\)와 비교한 시뮬레이션된 통계 분포. 이 분포는 \\(\chi^2_{30}\\) 분포에 대한 이론적 **분위수**를 가로 축에, 샘플링된 분위수를 세로 축에 표시합니다.


`simulstat`가 \\(\chi^2_{30}\\) 분포로 잘 설명되어 있다고 확신하면 이를 사용하여 p-값, 즉 귀무 가설 하에서 확률(카운트는 확률 \\(p_{\text{A}} = 0.35\\), \\(p_{\text{C}} = 0.15\\)을 갖는 다항식으로 분포됩니다.) \\(p_{\text{G}} = 0.2\\), \\(p_{\text{T}} = 0.3\\)) `S1`=70.1만큼 높은 값을 관찰합니다.




1 - pchisq(S1, df = 30)__



[1] 4.74342e-05


이렇게 작은 p-값을 사용하면 귀무가설이 불가능해 보입니다. 이 계산에는 어떻게 1000번의 시뮬레이션이 필요하지 않고 더 빠른지 확인하십시오.


## 2.7 샤가프의 법칙


뉴클레오티드 빈도에서 가장 중요한 패턴은 Chargaff에 의해 발견되었습니다([Elson and Chargaff 1952](16-chap.html#ref-Chargaff)).


![](imgs/ChargaffColdSpring_web.jpg)

분자의 무게를 사용하여 DNA 서열 분석이 가능해지기 오래 전에 그는 뉴클레오티드가 동일한 빈도로 발생하는지 여부를 물었습니다. 그는 이것을 테트라뉴클레오티드 가설이라고 불렀습니다. 우리는 이를 \\(p_{\text{A}} = p_{\text{C}} = p_{\text{G}} = p_{\text{T}}\\) 여부를 묻는 것으로 해석합니다.


불행하게도 Chargaff는 측정 자체가 아닌 각 뉴클레오티드에 대해 서로 다른 유기체에 존재하는 질량의 _백분율_만 발표했습니다.




load("../data/ChargaffTable.RData") ChargaffTable __



A T C G 인간-흉선 30.9 29.4 19.9 19.8 Mycobac.Tuber 15.1 14.6 34.9 35.4 Chicken-Eryth. 28.8 29.2 20.5 21.5 양간 29.3 29.3 20.5 20.7 성게 32.8 32.1 17.7 17.3 밀 27.3 27.1 22.7 22.8 효모 31.3 32.9 18.7 17.1 대장균 24.7 23.6 26.0 25.7


[![](02-chap_files/Figure-html/fig-ChargaffBars-1.png)](02-chap_files/Figure-html/fig-ChargaffBars-1.png "그림 2.9: ChargaffTable의 다양한 행에 대한 막대 그래프. 패턴을 찾을 수 있습니까?")


그림 2.9: 'ChargaffTable'의 다양한 행에 대한 막대 그래프. 패턴을 발견할 수 있나요?


__


질문 2.13


* 이러한 데이터는 가능성이 동일한 다항 범주에서 나온 것처럼 보입니까?

* 대체 패턴을 제안해 주실 수 있나요? 시뮬레이션에서 추정됨

* 위의 시뮬레이션에서 영감을 받아 패턴을 정량적으로 분석할 수 있습니까?

__


해결책


__


샤가프는 이 질문에 대한 답을 _보고_ 유기체 DNA의 아데닌(A) 양과 티민(T) 양의 완벽한 일치를 보장하는 _염기쌍_이라는 패턴을 가정했습니다. 마찬가지로 구아닌(G)의 양에 관계없이 시토신(C)의 양은 동일합니다. 이것이 이제 샤가프의 법칙(Chargaff's rule)이라고 불립니다. 반면에, 유기체 내 C/G의 양은 A/T의 양과 상당히 다를 수 있으며 유기체 전반에 걸쳐 뚜렷한 패턴이 없습니다. Chargaff의 규칙을 기반으로 통계를 정의할 수 있습니다.


\\[ (p_{\text{C}} - p_{\text{G}})^2 + (p_{\text{A}} - p_{\text{T}})^2, \\]


테이블의 모든 행에 대해 합산됩니다. 우리는 각 행에서 관찰된 확률이 특별한 순서가 아니어서 As와 Ts의 비율 또는 Cs와 Gs의 비율 사이에 특별한 관계가 없었다는 의미에서 뉴클레오티드가 '교환 가능'한 경우 데이터와 어떤 일이 발생하는지 비교를 살펴볼 것입니다.




statChf = function(x){ sum((x[, "C"] - x[, "G"])^2 + (x[, "A"] - x[, "T"])^2) } chfstat = statChf(ChargaffTable) permstat = replicate(100000, { permuted = t(apply(ChargaffTable, 1, sample)) colnames(permuted) = colnames(ChargaffTable) statChf(permuted) }) pChf = mean(permstat <= chfstat) pChf __



[1] 0.00014



hist(permstat, break = 100, main = "", col = "라벤더") abline(v = chfstat, lwd = 2, col = "red")__


[![](02-chap_files/Figure-html/fig-permstatChf-1-1.png)](02-chap_files/Figure- html/fig-permstatChf-1-1.png "그림 2.10: 열의 행별 순열을 사용하여 시뮬레이션에서 계산된 통계 statChf의 히스토그램. 관찰된 데이터에 대해 산출된 값은 빨간색으로 표시됩니다. 라인.")


그림 2.10: 열의 행별 순열을 사용하여 시뮬레이션을 통해 계산된 통계 'statChf'의 히스토그램. 관찰된 데이터에 대해 산출된 값은 빨간색 선으로 표시됩니다.


그림 2.10의 히스토그램은 빨간색 선이 그려진 관측된 11.1만큼 작은 값을 갖는 경우가 매우 드물다는 것을 보여줍니다. 작거나 작은 값을 관찰할 확률은 `pChf`=1.4^{-4}입니다. 따라서 데이터는 Chargaff의 통찰력을 강력하게 뒷받침합니다.


__


질문 2.14


'pChf'를 계산할 때 관찰된 값보다 작은 널 분포의 값만 살펴보았습니다. 여기서 우리는 왜 일방적인 방식으로 이 일을 했는가?


### 2.7.1 두 개의 범주형 변수


지금까지 우리는 예/아니요 이진 상자에 대한 이항 분포와 A, C, G, T와 같은 범주형 변수 또는 aa, aA, AA와 같은 다른 유전자형에 대한 다항 분포 등 다양한 상자로 분류될 수 있는 표본에서 데이터를 가져온 사례를 살펴보았습니다. 그러나 눈 색깔과 머리 색깔과 같은 일련의 대상에 대해 두 개 이상의 범주형 변수를 측정할 수도 있습니다. 그런 다음 눈과 머리 색깔의 모든 조합에 대한 개수를 교차표로 작성할 수 있습니다. **우수표**라는 개수 표를 얻습니다. 이 개념은 많은 생물학적 데이터 유형에 매우 유용합니다.




머리카락눈색상[,, "여성"]__



눈 머리 갈색 파란색 헤이즐색 녹색 검정색 36 9 5 2 갈색 66 34 29 14 빨간색 16 7 7 7 금발 4 64 5 8


__


질문 2.15


R에서 'HairEyeColor' 개체를 탐색해 보세요. 어떤 데이터 유형, 모양, 크기가 있나요?


__


해결책


__


이는 3차원의 숫자 배열입니다.




str(HairEyeColor)__



'테이블' 번호 [1:4, 1:4, 1:2] 32 53 10 3 11 50 10 30 10 25 ...

- attr(*, "dimnames")=3개 목록
..$ 헤어: chr [1:4] "검은색" "갈색" "빨간색" "금발" ..$ 눈 : chr [1:4] "갈색" "파란색" "개암색" "녹색" ..$ 성별 : chr [1:2] "남성" "여성"



## ?머리눈색상 __


#### 색맹과 섹스


녹색맹은 중간 파장에 민감한 원뿔(녹색)이 없기 때문에 발생하는 적록 색맹의 한 형태입니다. 듀테라노프는 2~3가지 색상만 구별할 수 있는 반면, 정상적인 시력을 가진 사람은 7가지 색상을 구분할 수 있습니다. 인간 대상의 이러한 유형의 색맹에 대한 조사에서는 색맹과 성별을 교차하는 양방향 표가 생성되었습니다.




load("../data/Deuteranopia.RData") 중수로맹 __



남성 여성 Deute 19 2 NonDeute 1981 1998


성별과 색맹 발생 사이에 관계가 있는지 어떻게 테스트할 수 있나요? 우리는 두 개의 독립적인 이항식(성별과 색맹에 대한 하나)을 사용하여 null 모델을 가정합니다. 이 모델에서 우리는 모든 셀의 다항 확률을 추정할 수 있으며 관찰된 개수와 예상 개수를 비교할 수 있습니다. 이는 R의 `chisq.test` 함수를 통해 수행됩니다.




chisq.test(Deuteranopia)__



Yates의 연속성 수정을 사용한 Pearson의 카이제곱 테스트


데이터: 중맹 X-제곱 = 12.255, df = 1, p-값 = 0.0004641


작은 p 값은 널 모델 하에서 매우 작은 확률로 그러한 테이블을 볼 것으로 예상해야 함을 알려줍니다. 즉, 여성과 남성의 중수소 색맹 비율이 동일한 경우입니다.


[섹션 10.3.2](10-chap.html#sec-graphs-GSEA)에서 Fisher의 정확한 테스트(초기하 테스트라고도 함)라는 이러한 유형의 데이터에 대한 또 다른 테스트를 볼 수 있습니다. 이 테스트는 유의하게 발현된 유전자 목록에서 특정 유형의 유전자가 과도하게 나타나는지 테스트하는 데 널리 사용됩니다.


### 2.7.2 특수 다항식: 하디-와인버그 평형


여기서 우리는 두 대립유전자 M과 N을 결합하여 생성된 세 가지 가능한 수준을 가진 다항식의 사용을 강조합니다. 모집단에서 대립유전자 M의 전체 빈도가 \\(p\\)이고 N의 빈도가 \\(q = 1-p\\)라고 가정합니다. Hardy-Weinberg 모델은 유전자형에서 두 대립 유전자의 빈도가 독립된 경우, 소위 **Hardy-Weinberg 평형**(HWE)인 경우 \\(p\\)와 \\(q\\) 사이의 관계를 조사합니다. 이는 성별 간에 대립 유전자가 균등하게 분포되어 있는 대규모 집단에서 무작위 교배가 있는 경우에 해당됩니다. 세 가지 유전자형의 확률은 다음과 같습니다.


\\[ p_{\text{MM}}=p^2,\quad p_{\text{NN}}=q^2,\quad p_{\text{MN}}=2pq \tag{2.5}\\]


우리는 유전자형 MM, MN, NN에 대한 빈도 \\((n_{\text{MM}},\,n_{\text{MN}},\,n_{\text{NN}})\\)와 총 수 \\(S=n_{\text{MM}}+ n_{\text{MN}}+n_{\text{NN}}\\)만을 관찰합니다. 다항식을 사용하여 가능성, 즉 범주의 확률이 방정식 2.5에 의해 주어질 때 관찰된 데이터의 확률을 쓸 수 있습니다.


\\[ P(n_{\text{MM}},\,n_{\text{MN}},\,n_{\text{NN}}\;|\;p) = {S \choose n_{\text{MM}},n_{\text{MN}},n_{\text{NN}}} (p^2)^{n_{\text{MM}}} \,\times\, (2pq)^{n_{\text{MN}}} \,\times\, (q^2)^{n_{\text{NN}}}, \\]


HWE 하의 로그 우도


\\[ L(p)=n_{\text{MM}}\log(p^2)+n_{\text{MN}} \log(2pq)+n_{\text{NN}}\log(q^2). \\]


로그 우도를 최대화하는 \\(p\\) 값은 다음과 같습니다.


\\[ p = \frac{n_{\text{MM}} + n_{\text{MN}}/2}{S}. \\]


그 증거는 ([Rice 2006, chap. 8](16-chap.html#ref-Rice:2007), 섹션 5)을 참조하세요. 주어진 데이터 \\((n_{\text{MM}},\,n_{\text{MN}},\,n_{\text{NN}})\\)에서 로그 우도 \\(L\\)은 단 하나의 매개변수 \\(p\\)의 함수입니다. 그림 2.11은 다음 코드에서 계산된 Mourant 데이터7의 216번째 행에 대한 \\(p\\)의 다양한 값에 대한 로그 우도 함수를 보여줍니다.


7 이는 R 패키지 **[HardyWeinberg](https://cran.r-project.org/web/packages/HardyWeinberg/)**를 통해 제공되는 Mourant, Kopec 및 Domaniewska-Sobczak([1976](16-chap.html#ref-Mourant1976))의 혈액형 대립유전자의 유전자형 빈도 데이터입니다.




library("HardyWeinberg") data("Mourant") Mourant[214:216,]__



인구 국가 합계 MM MN NN 214 오세아니아 미크로네시아 962 228 436 298 215 오세아니아 미크로네시아 678 36 229 413 216 오세아니아 타히티 580 188 296 96



nMM = Mourant$MM[216] nMN = Mourant$MN[216] nNN = Mourant$NN[216] loglik = function(p, q = 1 - p) { 2 * nMM * log(p) + nMN * log(2*p*q) + 2 * nNN * log(q) } xv = seq(0.01, 0.99, by = 0.01) yv = loglik(xv) plot(x = xv, y = yv, type = "l", lwd = 2, xlab = "p", ylab = "log-likelihood") imax = which.max(yv) abline(v = xv[imax], h = yv[imax], lwd = 1.5, col = "blue") abline(h = yv[imax], lwd = 1.5, col = "purple")__


[![](02-chap_files/Figure-html/fig- HardyWeinberg-1-1.png)](02-chap_files/Figure-html/fig-HardyWeinberg-1-1.png "그림 2.11: 타히티 데이터에 대한 로그 가능성 플롯.")


Figure 2.11: 타히티 데이터에 대한 로그 우도 플롯.


다항식의 확률에 대한 최대 우도 추정치는 이항의 경우와 마찬가지로 관측된 빈도를 사용하여 얻어지지만 추정치는 세 가지 확률 간의 관계를 고려해야 합니다. **[HardyWeinberg](https://cran.r-project.org/web/packages/HardyWeinberg/)** 패키지의 `af` 함수를 사용하여 \\(\hat{p}_{\text{MM}}\\), \\(\hat{p}_{\text{MN}}\\) 및 \\(\hat{p}_{\text{NN}}\\)을 계산할 수 있습니다.




phat  =  af(c(nMM, nMN, nNN)) phat __



0.5793103



pMM   =  phat^2 qhat  =  1 - phat __


Hardy-Weinberg 평형 하에서 기대되는 값은 다음과 같습니다.




pHW = c(MM = phat^2, MN = 2*phat*qhat, NN = qhat^2) sum(c(nMM, nMN, nNN)) * pHW __



MM.A MN.A NN.A 194.6483 282.7034 102.6483


이는 위에서 관찰된 값과 비교할 수 있습니다. 관측된 값과 매우 유사하다는 것을 알 수 있습니다. 시뮬레이션이나 위와 같이 \\(\chi^2\\) 테스트를 수행하여 관찰된 값이 Hardy-Weinberg 모델을 거부할 수 있는지 여부를 추가로 테스트할 수 있습니다. Hardy-Weinberg의 적합도에 대한 시각적 평가는 de Finetti([Finetti 1926](16-chap.html#ref-definetti26); [Cannings and Edwards 1968](16-chap.html#ref-Cannings1968))에 의해 설계되었습니다. 이는 각 대립유전자의 비율로 좌표가 제공되는 지점에 모든 샘플을 배치합니다.


#### Hardy-Weinberg 평형과의 시각적 비교


우리는 'HWTernaryPlot' 함수를 사용하여 데이터를 표시하고 이를 Hardy-Weinberg 평형과 그래픽으로 비교합니다.




pops = c(1, 69, 128, 148, 192) genotypeFrequencies = as.matrix(Mourant[, c("MM", "MN", "NN")]) HWTernaryPlot(genotypeFrequencies[pops, ], markerlab = Mourant$Country[pops], alpha = 0.0001, curvecols = c("red", rep("purple", 4)), mcex = 0.75, vertex.cex = 1)__


[![](02-chap_files/Figure-html/fig-HWtern-1.png)](02-chap_files/Figure- html/fig-HWtern-1.png "그림 2.12: 이 de Finetti 플롯은 주파수를 삼각형의 각 모서리에 대한 가중치로 사용하여 세 가지 유전자형의 중심점을 보여줍니다. Hardy-Weinberg 모델은 빨간색 곡선입니다. 수용 영역은 두 보라색 선 사이에 있습니다. 미국이 HW 균형 상태에서 가장 멀리 떨어져 있음을 알 수 있습니다."


그림 2.12: 이 **de Finetti 플롯**은 빈도를 삼각형의 각 모서리에 대한 가중치로 사용하여 세 가지 유전자형의 중심점을 보여줍니다. Hardy-Weinberg 모델은 빨간색 곡선이고 수용 영역은 두 개의 보라색 선 사이에 있습니다. 우리는 미국이 HW 균형 상태에서 가장 멀리 떨어져 있음을 알 수 있습니다.


__


질문 2.16


위 코드와 같이 삼원 플롯을 만든 다음 여기에 다른 데이터 포인트를 추가합니다. 무엇을 알 수 있습니까? 'HWChisq' 기능을 사용하여 토론을 백업할 수 있습니다.


__


해결책


__




HWTernaryPlot(genotypeFrequency[-pops, ], newframe = FALSE, alpha = 0.0001, cex = 0.5)__


__


질문 2.17


각 유전자형에 대해 동일한 비율을 유지하면서 모든 총 빈도를 50으로 나누고 삼원 플롯을 다시 만듭니다.


* 포인트는 어떻게 되나요?

* 신뢰 영역은 어떻게 되며 그 이유는 무엇입니까?

__


해결책


__




newgf = round(genotypeFrequencies / 50) HWTernaryPlot(newgf[pops, ], markerlab = Mourant$Country[pops], curvecols = c("red", rep("purple", 4)), alpha = 0.0001, mcex = 0.75, vertex.cex = 1)__


### 2.7.3 여러 다항식 연결: 시퀀스 모티프 및 로고


[Kozak Motif](http://www.sciencegateway.org/resources/kozak.htm)는 코딩 영역의 시작 코돈 **ATG** 근처에서 발생하는 시퀀스입니다. 시작 코돈 자체는 항상 고정된 철자를 가지고 있지만 왼쪽 5번째 위치에는 문자가 동일할 가능성이 전혀 없는 뉴클레오티드 패턴이 있습니다.


우리는 모든 포지션에서 다항 확률을 제공하는 **포지션 가중치 매트릭스**(PWM) 또는 **포지션별 점수 매트릭스**(PSSM)를 제공하여 이를 요약합니다. 이는 **시퀀스 로고**(그림 2.13)를 통해 그래픽으로 인코딩됩니다.




library("seqLogo") load("../data/kozak.RData") kozak __



[,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] A 0.33 0.25 0.4 0.15 0.20 1 0 0 0.05 C 0.12 0.25 0.1 0.40 0.40 0 0 0 0.05 G 0.33 0.25 0.4 0.20 0.25 0 0 1 0.90 T 0.22 0.25 0.1 0.25 0.15 0 1 0 0.00



pwm = makePWM(kozak) seqLogo(pwm, ic.scale = FALSE)__


[![](02-chap_files/Figure-html/fig-seqlogo-1-1.png)](02-chap_files/Figure- html/fig-seqlogo-1-1.png "그림 2.13: 다음은 Kozak 모티프를 모델링하는 데 사용되는 위치 종속 다항식에 대한 시퀀스 로고라는 다이어그램입니다. 이는 로그 스케일에서 각 위치의 변동량을 체계화합니다. 큰 문자는 어떤 뉴클레오티드가 발생하는지에 대한 불확실성이 없는 위치입니다.")


그림 2.13: 다음은 Kozak 모티프를 모델링하는 데 사용되는 위치 종속 다항식에 대한 시퀀스 로고라는 다이어그램입니다. 로그 스케일의 각 위치에서 변동량을 코드화합니다. 큰 글자는 어떤 뉴클레오티드가 발생하는지에 대한 불확실성이 없는 위치를 나타냅니다.


마지막 섹션에서 우리는 다항 분포의 다양한 "상자"가 동일한 확률을 갖는 경우가 거의 없음을 확인했습니다. 즉, 매개변수 \\(p_1, p_2, ...\\)는 모델링되는 항목에 따라 달라지는 경우가 많습니다. 빈도가 같지 않은 다항식의 예로는 20개의 서로 다른 아미노산, 혈액형 및 머리 색깔이 있습니다.


범주형 변수가 여러 개 있는 경우 독립적인 경우가 거의 없습니다(성별 및 색맹, 머리카락 및 눈 색깔 등). 나중에 [9장](09-chap.html)에서 분할표의 다변량 분해를 사용하여 이러한 종속성의 패턴을 탐색할 수 있음을 살펴보겠습니다. 여기에서는 범주형 변수 사이의 종속성의 중요한 특수 사례, 즉 범주형 변수의 시퀀스(또는 "체인")를 따라 발생하는 종속성(예: 시간이 지남에 따라 또는 생체 고분자를 따라 발생)을 살펴보겠습니다.


## 2.8 순차적 종속성 모델링: 마르코프 체인


내일의 날씨를 예측하고 싶다면 오늘의 날씨와 같을 가능성이 가장 높다는 것이 합리적으로 좋은 추측이며 다양한 종류의 가능한 변화에 대한 확률을 기술할 수도 있습니다^[동일한 추론을 반대로 적용할 수도 있습니다. 우리는 오늘로부터 어제의 날씨를 "예측"할 수 있습니다. 이 일기 예보 방법은 마르코프 가정의 한 예입니다. 내일에 대한 예측은 오늘의 상황에만 의존하지만 어제 또는 3주 전의 상태에는 의존하지 않습니다(우리가 잠재적으로 사용할 수 있는 모든 정보는 오늘 날씨에는 이미 포함되어 있습니다.) 날씨 예는 또한 그러한 가정이 반드시 정확할 필요는 없지만 충분히 좋은 가정이어야 한다는 점을 강조합니다. 이 가정을 이전 \\(k\\)일에 대한 종속성으로 확장하는 것은 매우 간단합니다. 여기서 \\(k\\)는 유한하고 너무 크지 않기를 바랍니다. 마르코프 가정의 핵심은 프로세스에 유한한 "기억"이 있으므로 예측은 유한한 시간 동안만 되돌아보면 된다는 것입니다.


시간적 순서 대신에 이를 생물학적 순서에 적용할 수도 있습니다. DNA에서 우리는 다이그램(예: [CG, CA, CC] 및 [CT])이라고 하는 뉴클레오티드 쌍이 똑같이 빈번하지 않도록 특정 패턴의 연속을 볼 수 있습니다. 예를 들어, 게놈의 일부에서는 독립 상태에서 예상되는 것보다 [CA]의 사례가 더 자주 나타납니다.


\\[ P(\mathtt{CA}) \neq P(\mathtt{C}) \, P(\mathtt{A}). \\]


우리는 이 종속성을 **Markov 체인**으로 시퀀스에서 모델링합니다.


\\[ P(\mathtt{CA}) = P(\mathtt{NCA}) = P(\mathtt{NNCA}) = P(...\mathtt{CA}) = P(\mathtt{C}) \, P(\mathtt{A|C}), \\]


여기서 N은 임의의 뉴클레오티드를 나타내고 \\(P(\mathtt{A|C})\\)는 "이전 염기가 \\(\mathtt{C}\\)인 경우 \\(\mathtt{A}\\)의 확률"을 나타냅니다. 그림 2.14는 이러한 전환을 그래프로 도식적으로 나타낸 것입니다.


[![](02-chap_files/Figure-html/fig- statsfourstateMC-1.png)](02-chap_files/Figure-html/fig-statsfourstateMC-1.png "그림 2.14: 4-상태 마르코프 체인 시각화. 가능한 각 다이그램 \(예: CA\)의 확률은 해당 노드 사이의 가장자리 가중치로 제공됩니다. 따라서 예를 들어, CA 확률은 가장자리 C$ o$ A로 제공됩니다. 이러한 유형의 네트워크 그래프를 그리기 위해 R 패키지를 사용하는 방법을 두 번째 이미지에서 살펴보겠습니다.")


그림 2.14: 4-상태 마르코프 체인의 시각화. 가능한 각 다이그램(예: CA)의 확률은 해당 노드 사이의 에지 가중치로 제공됩니다. 예를 들어 CA 확률은 가장자리 C$ o$ A로 제공됩니다. [11장](11-chap.html)에서 R 패키지를 사용하여 이러한 유형의 네트워크 그래프를 그리는 방법을 살펴보겠습니다.


## 2.9 베이지안 사고


[![](imgs/turtlesalltheway.png)](imgs/turtlesalltheway.png "그림 2.15: 아래쪽으로 내려가는 거북이. 분포 매개변수의 불확실성에 대한 베이지안 모델링은 불확실성이 무작위 변수로 모델링될 수 있는 매개변수에 따라 분포가 달라질 수 있는 무작위 변수를 사용하여 수행됩니다. 이를 계층적 모델이라고 합니다.")


그림 2.15: 아래로 내려가는 거북이. 분포 매개변수의 불확실성에 대한 베이지안 모델링은 불확실성이 무작위 변수로 모델링될 수 있는 매개변수에 따라 분포가 달라질 수 있는 무작위 변수를 사용하여 수행됩니다. 이를 계층적 모델이라고 합니다.


지금까지 우리는 모델의 매개변수와 모델이 사용하는 분포, 즉 가능한 다른 결과의 확률이 장기적인 빈도를 나타내는 고전적인 접근 방식을 따랐습니다. 매개변수는 적어도 개념적으로는 명확하고 알 수 있으며 고정되어 있습니다. 우리는 그것들을 알지 못할 수도 있으므로, 우리는 현재의 데이터로부터 그것들을 추정합니다. 그러나 이러한 접근 방식은 우리가 이미 가지고 있을 수 있는 정보를 고려하지 않으며, 이로 인해 매개변수에 대해 알려주거나 특정 매개변수 값이나 그 조합이 다른 것보다 더 가능성이 높아질 수 있습니다. 심지어 우리가 현재 데이터 세트를 보기 전이라도 말이죠. 이를 위해서는 확률 모델(예: 분포)을 사용하여 매개변수에 대한 사전 지식8을 표현하고 현재 데이터를 사용하여 그러한 지식을 _업데이트_하는(예: 분포를 이동하거나 더 좁게 만드는 등) 다른 접근 방식이 필요합니다. 이러한 접근법은 베이지안 패러다임(그림 2.15)에 의해 제공됩니다.


8 어떤 사람들은 “우리의 믿음(들)”이라고 말하기를 좋아합니다.


베이지안 패러다임은 일부 데이터를 수집하고 관찰하기 _전_ 및 _후_에 우리의 지식을 모델링하기 위해 _사전_ 및 _사후_ 분포를 사용하는 실용적인 접근 방식입니다. 무한히 반복될 수 있습니다. 한 라운드의 데이터 생성 후 사후가 다음 라운드의 사전으로 사용될 수 있습니다. 따라서 다양한 소스의 정보를 통합하거나 결합하는 데 특히 유용합니다.


동일한 아이디어가 가설 테스트에도 적용될 수 있습니다. 여기서 데이터를 사용하여 가설 \\(H\\)이라고 부를 수 있는 특정 진술이 사실인지 여부를 결정합니다. 여기서 "매개변수"는 \\(H\\)가 참일 확률이며, \\(P(H)\\)9로 쓰여진 **사전** 확률의 형태로 사전 지식을 공식화할 수 있습니다. 데이터를 확인한 후에는 **사후** 확률을 갖게 됩니다. \\(D\\)를 본 경우 \\(H\\)의 확률인 \\(P(H\,|\,D)\\)로 씁니다. 이는 데이터 \\(D\\)에 따라 \\(P(H)\\)보다 높거나 낮을 수 있습니다.


9 소위 빈도주의자에게는 그러한 가능성이 존재하지 않습니다. 그들의 관점은 비록 진실은 알려지지 않았지만 실제로 가설은 참이거나 거짓이라는 것입니다. "70% 진실"이라고 부르는 것은 의미가 없습니다.


### 2.9.1 예: 일배체형 빈도


수학적 형식을 최소한으로 유지하기 위해 Y 염색체의 결합된 서명(일배체형)을 사용하는 법의학의 예부터 시작합니다.


일배체형(haplotype)은 염색체에서 공간적으로 인접한 대립유전자(DNA 서열 변종)의 모음으로, 일반적으로 함께 유전되므로(재조합으로 인해 분리되지 않는 경향이 있음) 유전적으로 연결됩니다. 이 경우 우리는 Y 염색체의 연결된 변이를 살펴봅니다.


먼저 일배체형 빈도 분석의 동기를 살펴본 다음 가능성에 대한 아이디어를 다시 살펴보겠습니다. 그런 다음, 알려지지 않은 매개변수를 난수 자체로 생각하고 사전 분포를 사용하여 불확실성을 모델링하는 방법을 설명하겠습니다. 그런 다음 관찰된 새로운 데이터를 확률 분포에 통합하고 매개변수에 대한 사후 신뢰도를 계산하는 방법을 살펴보겠습니다.


[![](imgs/STRDefinition.png)](imgs/STRDefinition.png "그림 2.16: DNA의 짧은 직렬 반복 \(STR\)은 2개 이상의 뉴클레오티드 패턴이 반복되고 반복된 서열이 서로 직접 인접할 때 발생합니다. STR은 미세부수체라고도 합니다. 패턴의 길이는 2~13개 뉴클레오티드일 수 있으며 반복 횟수는 개인마다 매우 다양합니다. STR 번호는 유전적 서명으로 사용될 수 있습니다.")


그림 2.16: DNA의 짧은 직렬 반복(STR)은 두 개 이상의 뉴클레오티드 패턴이 반복되고 반복된 서열이 서로 직접 인접할 때 발생합니다. STR은 미세위성이라고도 알려져 있습니다. 패턴의 길이는 2~13개 뉴클레오티드이며, 반복 횟수는 개인마다 매우 다양합니다. STR 번호는 유전적 서명으로 사용될 수 있습니다.


[![](imgs/YSTRPositions.jpg)](imgs/YSTRPositions.jpg "그림 2.17: 인간 Y 염색체의 짧은 직렬 반복 \(STR\) 위치. 출처: https://strbase.nist.gov/ystrpos1.htm")


그림 2.17: 인간 Y 염색체의 짧은 직렬 반복(STR) 위치. 출처 : <https://strbase.nist.gov/ystrpos1.htm>


[![](imgs/USY-STR.png)](imgs/USY-STR.png "그림 2.18: FBI에서 사용하는 데이터베이스에서 Y STR 일배체형 조회.")


그림 2.18: FBI가 사용하는 데이터베이스에서 Y STR 일배체형 조회.


우리는 다양한 짧은 탠덤 반복(STR) 세트로 구성된 특정 Y-일배체형의 빈도에 관심이 있습니다. DNA 법의학에 사용되는 특정 위치의 STR 번호 조합은 특정 위치의 반복 횟수로 표시됩니다. 다음은 이러한 STR 일배체형 테이블의 짧은 발췌입니다.




haplo6 = read.table("../data/haplotype6.txt", header = TRUE) haplo6 __



개별 DYS19 DXYS156Y DYS389m DYS389n DYS389p 1 H1 14 12 4 12 3 2 H3 15 13 4 13 3 3 H4 15 11 5 11 3 4 H5 17 13 4 11 3 5 H7 13 12 5 12 3 6 H8 16 11 5 12 3


표에 따르면 일배체형 H1은 'DYS19' 위치에 14개의 반복이 있고 'DXYS156Y' 위치에 12개의 반복이 있습니다. \\(n=300\\)명의 남성을 일배체형으로 지정하여 관심 집단에서 특정 일배체형의 기본 비율 \\(p\\)를 찾고 싶다고 가정해 보겠습니다. 그 중 \\(y=40\\)에서 H1을 찾았다고 가정해 보겠습니다. 우리는 이를 모델링하기 위해 이항 분포 \\(B(n,p)\\)를 사용할 것이며, \\(p\\)는 알 수 없습니다.


이러한 Y-STR 프로필을 사용하여 생성된 일배체형은 동일한 가부장적 혈통의 남성 간에 공유됩니다. 따라서 두 명의 다른 남성이 동일한 프로필을 공유하는 것이 가능합니다.


### 2.9.2 이항식에 대한 베이지안 패러다임의 시뮬레이션 연구

분포


매개변수 \\(p\\)가 하나의 단일 값(예: 최대 가능성 추정치 40/300)을 갖는다고 가정하는 대신 베이지안 접근 방식을 사용하면 이를 통계 분포에서 가져온 것으로 볼 수 있습니다. 분포는 매개변수 \\(p\\)의 가능한 값에 대한 우리의 믿음을 표현합니다. 원칙적으로 \\(p\\)에 대해 가능한 값이 허용되는 분포를 사용할 수 있습니다. 여기에서는 비율이나 확률을 표현하고 0과 1 사이의 값을 갖는 매개변수를 보고 있으므로 _베타 분포_를 사용하는 것이 편리합니다. 밀도 공식은 다음과 같습니다.


\\[ f_{\alpha,\beta}(x) = \frac{x^{\alpha-1}\,(1-x)^{\beta-1}}{\text{B}(\alpha,\beta)}\quad\text{여기서}\quad \text{B}(\alpha,\beta)=\frac{\Gamma(\alpha)\Gamma(\beta)}{\Gamma(\alpha+\beta)}. \태그{2.6}\\]


그림 2.19에서 이 함수가 두 매개변수 \\(\alpha\\) 및 \\(\beta\\)에 어떻게 의존하는지 확인할 수 있습니다. 이는 매우 유연한 분포 계열을 만듭니다(다양한 상황에 "적합"할 수 있음). 그리고 그것은 훌륭한 수학적 특성을 가지고 있습니다. 베타 모양의 \\(p\\)에 대한 사전 믿음으로 시작하고 \\(n\\) 이항 시행의 데이터 세트를 관찰한 다음 믿음을 업데이트하면 \\(p\\)에 대한 사후 분포도 업데이트된 매개변수에도 불구하고 베타 분포를 갖게 됩니다. 이것은 수학적 사실입니다. 여기서는 증명하지 않겠지만 시뮬레이션을 통해 보여드리겠습니다.


[![](02-chap_files/Figure-html/fig-histobeta2-1.png)](02-chap_files/Figure- html/fig-histobeta2-1.png "그림 2.19: \\alpha=10,20,50 및 \\beta=30,60,150인 베타 분포. 이를 성공 확률에 대한 사전 확률로 사용할 수 있습니다. 이항 실험. 이 세 가지 분포는 평균 \(\\frac{\\alpha}{\\alpha +\\beta}\)은 동일하지만 평균 주위의 농도는 다릅니다.")


그림 2.19: \\(\alpha=10,20,50\\) 및 \\(\beta=30,60,150\\)을 사용한 베타 배포판. 이를 이항 실험의 성공 확률에 대한 **사전**으로 사용할 수 있습니다. 이 세 가지 분포는 동일한 평균(\\(\frac{\alpha}{\alpha +\beta}\\))을 갖지만 평균 주위의 농도는 다릅니다.


### 2.9.3 \\(Y\\)의 분포


주어진 \\(p\\) 선택에 대해 방정식 2.3을 통해 \\(Y\\)의 분포가 무엇인지 알 수 있습니다. 그러나 \\(p\\) 자체도 일부 분포에 따라 달라지면 \\(Y\\)의 분포는 무엇입니까? 우리는 이것을 \\(Y\\)의 **한계 분포**라고 부릅니다. 그것을 시뮬레이션해 봅시다. 먼저 100000 \\(p\\)의 무작위 샘플 `rp`를 생성합니다. 그런 다음 그림 2.20에 표시된 것처럼 각각에 대해 \\(Y\\)의 무작위 샘플을 생성합니다. 아래 코드에서는 데모를 위해 사전에 매개변수 50과 350을 사용합니다. 그러한 사전은 이미 매우 유익하며(“정점”), 예를 들어 이전 연구를 기반으로 한 우리의 믿음을 반영할 수 있습니다. 질문 2.20에서는 "더 부드러운"(덜 유익한) 사전을 시험해 볼 기회가 있습니다. 우리는 다시 `vapply`를 사용하여 이름이 지정되지 않은 `x` 함수를 `rp`의 모든 요소에 적용하여 결과적으로 동일한 길이의 또 다른 벡터 `y`를 얻습니다.




rp = rbeta(100000, 50, 350) y = vapply(rp, function(x) rbinom(1, prob = x, size = 300), integer(1)) hist(y, breaks = 50, col = "orange", main = "", xlab = "")__


[![](02-chap_files/Figure-html/fig- histmarginal-1-1.png)](02-chap_files/Figure-html/fig-histmarginal-1-1.png "그림 2.20: Y의 한계 분포.")


그림 2.20: \\(Y\\)의 한계 분포.


__


질문 2.18


R의 벡터화 기능을 사용하고 `rbinom(length(rp), rp, size = 300)`을 작성하여 위의 코드 청크에서와 동일한 결과를 얻을 수 있는지 확인하십시오.


__


해결책


__




set.seed(0xbebe) y1 = vapply(rp, function(x) rbinom(1, prob = x, 크기 = 300), 정수(1)) set.seed(0xbebe) y2 = rbinom(length(rp), rp, size = 300) stopifnot(identical(y1, y2))__


### 2.9.4 \\(Y=40\\)을 만족하는 모든 \\(p\\)의 히스토그램: 사후

분포


이제 \\(Y\\)가 40인 결과를 조건으로 \\(p\\)의 사후 분포를 계산해 보겠습니다. 이를 이론적인 사후 분포 'densPostTheory'와 비교합니다. 자세한 내용은 아래에서 확인하세요. 결과는 그림 2.21에 나와 있습니다.




pPostEmp = rp[ y == 40 ] hist(pPostEmp, breaks = 40, col = "chartreuse4", main = "", probability = TRUE, xlab = "posterior p")


p_seq = seq(0, 1, by = 0.001) densPostTheory = dbeta(p_seq, 50 + 40, 350 + 260) lines(p_seq, densPostTheory, type = "l", lwd = 3)__


[![](02-chap_files/Figure-html/fig-densityposterior-1-1.png)](02-chap_files/Figure-html/fig-densityposterior-1-1.png "그림 2.21: Y=40인 분포 값만 선택하면 p의 사후 분포가 제공됩니다. 히스토그램 \(녹색\)은 사후 분포에 대한 시뮬레이션된 값을 표시하며 선은 베타의 밀도입니다. 이론적 매개변수를 사용한 분포.")


그림 2.21: \\(Y=40\\)인 분포 값을 선택하면 \\(p\\)의 사후 분포가 제공됩니다. 히스토그램(녹색)은 사후 분포에 대한 시뮬레이션 값, 즉 베타 분포의 밀도와 이론적인 매개변수의 선을 보여줍니다.


또한 위에서 계산된 두 분포의 평균을 확인하여 유효 숫자 4자리에 가깝다는 것을 확인할 수 있습니다.




평균(pPostEmp)__



[1] 0.128726



dp = p_seq[2] - p_seq[1] sum(p_seq * densPostTheory * dp)__



[1] 0.1285714


이론적 밀도 'densPostTheory'의 평균을 근사화하기 위해 위에서 문자 그대로 적분을 계산했습니다.


\\[ \int_0^1 p \, f(p) \, dp \\]


수치 적분, 즉 적분에 대한 '합'을 사용합니다. 이는 항상 편리한(또는 실행 가능한) 것은 아닙니다. 특히 모델에 단일 스칼라 매개변수 \\(p\\)가 포함되지 않고 많은 매개변수가 있어 고차원 매개변수 벡터와 고차원 적분을 다루는 경우에는 더욱 그렇습니다. 적분을 분석적으로 계산할 수 없는 경우 **몬테카를로 적분**을 사용할 수 있습니다. 위 코드에서 몬테 카를로 통합의 아주 간단한 사례를 이미 보셨는데, 여기서 우리는 `pPostEmp`로 사후를 샘플링하고 R의 `mean` 함수를 호출하여 사후 평균을 계산하기 위해 통합을 수행했습니다. 이 경우 대체 몬테카를로 알고리즘은 올바른 매개변수와 함께 'rbeta' 함수를 직접 사용하여 사후 샘플을 생성하는 것입니다.




pPostMC = rbeta(n = 100000, 90, 610) mean(pPostMC)__



[1] 0.1285718


**분위수-분위수 플롯**(**QQ-plot**, 그림 2.22)을 사용하여 약간 다른 방식으로 생성된 Monte Carlo 샘플 'pPostMC'와 'pPostEmp' 간의 일치성을 확인할 수 있습니다.




qqplot(pPostMC, pPostEmp, type = "l", asp = 1) abline(a = 0, b = 1, col = "blue")__


[![](02-chap_files/Figure-html/fig-qqplotbeta-1-1.png)](02-chap_files/Figure- html/fig-qqplotbeta-1-1.png "그림 2.22: 이론적 분포와 시뮬레이션 샘플 pPostEmp에서 얻은 Monte Carlo 샘플 pPostMC의 Quantile-Quantile \(QQ\) 플롯. 다음 중 하나를 유사하게 비교할 수도 있습니다. 이 두 가지 분포는 이론적 분포 함수 pbeta\(., 90, 610\)에 적용됩니다. 곡선이 y=x 선에 있으면 꼬리 부분에 임의의 차이가 있음을 나타냅니다.


그림 2.22: 이론적 분포와 시뮬레이션 샘플 'pPostEmp'의 Monte Carlo 샘플 'pPostMC'의 QQ(Quantile-Quantile) 플롯. 또한 이 두 분포 중 하나를 이론적 분포 함수 'pbeta(., 90, 610)'와 유사하게 비교할 수도 있습니다. 곡선이 \\(y=x\\) 선에 있으면 이는 좋은 일치를 나타냅니다. 꼬리에는 약간의 무작위 차이가 있습니다.


__


질문 2.19


'pPostEmp'로 이어지는 시뮬레이션과 'pPostMC'로 이어지는 Monte Carlo 시뮬레이션의 차이점은 무엇인가요?


### 2.9.5 사후 분포도 베타 분포입니다.


이제 우리는 사후 분포도 베타임을 확인했습니다. 우리의 경우 해당 매개변수 \\(\alpha=90\\) 및 \\(\beta=610\\)은 이전 매개변수 \\(\alpha=50\\), \\(\beta=350\\)를 관찰된 성공 \\(y=40\\) 및 관찰된 실패 \\(n-y=260\\)와 합산하여 얻은 것입니다.


\\[ \text{베타}(90,\, 610)=\text{베타}(\alpha+y,\text{베타}+(n-y)). \\]


우리는 사후 분포에 의해 주어진 불확실성을 가지고 \\(p\\)에 대해 우리가 할 수 있는 최선의 추정치를 제공하기 위해 그것을 사용할 수 있습니다.


10 사후 분포를 최대화하는 값을 최선의 추정치로 취할 수 있습니다. 이를 **MAP** 추정치라고 하며, 이 경우에는 \\(\frac{\alpha-1}{\alpha+\beta-2}=\frac{89}{698}\doteq 0.1275\\)가 됩니다.


### 2.9.6 두 번째 데이터 계열이 있다고 가정합니다.


이전 데이터를 본 후 이제 새로운 이전 데이터인 \\(\text{Beta}(90, 610)\\)를 갖게 되었습니다. \\(n=150\\)개의 관찰과 \\(y=25\\)개의 성공, 즉 125개의 실패로 새로운 데이터 세트를 수집한다고 가정합니다. 이제 \\(p\\)에 대한 최선의 추측은 무엇입니까?


이전과 동일한 추론을 사용하면 새로운 사후값은 \\(\text{Beta}(90+25=115,\, 610+125=735)\\)가 됩니다. 이 분포의 평균은 \\(\frac{115}{115+735}=\frac{115}{850}\simeq 0.135\\)이므로 \\(p\\)의 한 추정치는 0.135가 됩니다. **최대 사후**(MAP) 추정치는 \\(\text{Beta}(115, 735)\\) 모드, 즉 \\(\frac{114}{848}\simeq 0.134\\)입니다. 이를 수치로 확인해 보겠습니다.




densPost2 = dbeta(p_seq, 115, 735) mcPost2   = rbeta(1e6, 115, 735) sum(p_seq * densPost2 * dp)   # mean, by numeric integration __



[1] 0.1352941



평균(mcPost2) # MC의 의미 __



[1] 0.1352655



p_seq[which.max(densPost2)] # MAP 추정 __



[1] 0.134


__


질문 2.20


원래 사전을 더 부드러운 사전(덜 정점)으로 바꾸는 모든 계산을 다시 실행합니다. 즉, 사전 정보를 덜 사용한다는 의미입니다. 예를 들어 균일 분포인 Beta(1,1)을 시도해 보세요. 이것이 최종 결과를 얼마나 변화시키나요?


일반적으로 사전 분포는 매우 정점에 있는 경우를 제외하고 사후 분포를 실질적으로 변경하는 경우가 거의 없습니다. 처음에 우리가 이미 무엇을 기대할지 확신하고 있었다면 이런 경우가 될 것입니다. 사전이 영향을 미치는 또 다른 경우는 데이터가 거의 없는 경우입니다.


가장 좋은 상황은 사전을 압도할 만큼 충분한 데이터를 확보하여 선택이 최종 결과에 큰 영향을 미치지 않도록 하는 것입니다.


### 2.9.7 비율 매개변수에 대한 신뢰 진술


이제 데이터를 바탕으로 \\(p\\) 비율이 실제로 무엇인지 결론을 내릴 차례입니다. 한 가지 요약은 신뢰 구간의 베이지안 아날로그인 사후 신뢰 구간입니다. 사후 분포의 2.5번째 및 97.5번째 백분위수를 취할 수 있습니다: \\(P(q_{2.5\%} \leq p \leq q_{97.5\%})=0.95\\).




분위수(mcPost2, c(0.025, 0.975))__



2.5% 97.5% 0.1131080 0.1590221


[![](imgs/DESeq2-Prediction-Interval.png)](imgs/DESeq2-Prediction-Interval.png "그림 2.23: @LoveDESeq2의 예는 더 높은 분산으로 인해 녹색 및 보라색 유전자와 이전 \(검은색 실선\)에 대한 우도 \(1로 적분되도록 조정된 실선) 및 사후 \(점선\)의 플롯을 보여줍니다. 보라색 유전자의 가능성은 더 넓고 피크가 적으며\(정보가 적음을 나타냄\), 사전은 녹색 유전자보다 후방에 더 많은 영향을 미칩니다. 최대 녹색 후방의 더 강한 곡률은 MAP 로그 접기 변화\(LFC\) 추정\(수평 오류 막대\)에 대해 보고된 표준 오류가 더 작은 것으로 해석됩니다.


그림 2.23: Love, Huber 및 Anders([2014](16-chap.html#ref-LoveDESeq2))의 예는 녹색 및 보라색 유전자와 사전(검은색 실선)에 대한 우도(1로 적분되도록 스케일링된 실선) 및 사후(점선)의 플롯을 보여줍니다. 보라색 유전자의 더 높은 분산으로 인해 우도는 더 넓고 정점이 덜 나타납니다(더 적은 정보를 나타냄). 사전은 녹색 유전자보다 사후에 더 많은 영향을 미칩니다. 최대 녹색 후방의 더 강한 곡률은 MAP 로그 접기 변경(LFC) 추정치(수평 오류 막대)에 대해 보고된 표준 오류가 더 작은 것으로 해석됩니다.


## 2.10 예: 게놈에서 뉴클레오티드 패턴의 발생


지금까지 우리가 본 예는 이산 개수와 범주형 데이터의 분포에 집중되어 있습니다. 준연속적인 거리 분포의 예를 살펴보겠습니다. 게놈 서열의 특정 모티프 인스턴스 간 거리 분포에 대한 이 사례 연구를 통해 Bioconductor에서 특정 게놈 서열 조작을 탐색할 수도 있습니다.


**[Biostrings](https://bioconductor.org/packages/Biostrings/)** 패키지는 서열 데이터 작업을 위한 도구를 제공합니다. 필수 데이터 구조 또는 R에서 알려진 _클래스_는 _DNAString_ 및 _DNAStringSet_입니다. 이를 통해 우리는 하나 또는 여러 개의 DNA 서열을 효율적으로 사용할 수 있습니다.


**[Biostrings](https://bioconductor.org/packages/Biostrings/)** 패키지에는 아미노산 서열과 보다 일반적인 생물학에서 영감을 받은 서열을 나타내는 추가 클래스도 포함되어 있습니다.




library("바이오스트링")__


__


질문 2.21


튜토리얼 비네팅을 탐색하여 Biostrings 패키지에서 제공되는 유용한 데이터와 기능 중 일부를 살펴보세요.


__


해결책


__


첫 번째 줄은 유전 코드 정보를 인쇄하고, 두 번째 줄은 IUPAC 뉴클레오티드 모호성 코드를 반환합니다. 세 번째 줄에는 **[Biostrings](https://bioconductor.org/packages/Biostrings/)** 패키지에서 사용할 수 있는 모든 비네팅이 나열되고, 네 번째 줄에는 특정 비네팅이 하나 표시됩니다.




GENETIC_CODE IUPAC_CODE_MAP vignette(package = "Biostrings") vignette("BiostringsQuickOverview", package = "Biostrings")__


이 마지막 명령은 브라우저 창에서 설명서에 액세스할 수 있는 목록을 엽니다11. **[BSgenome](https://bioconductor.org/packages/BSgenome/)** 패키지는 많은 게놈에 대한 접근을 제공하며, 전체 게놈 서열이 포함된 데이터 패키지의 이름에 다음을 입력하여 접근할 수 있습니다.


11 Vignettes는 예제와 사례 연구가 포함된 패키지 매뉴얼입니다.




library("BSgenome") ag = available.genomes() 길이(ag)__



[1] 113



ag[1:2]__



[1] "BSgenome.Alyrata.JGI.v1" [2] "BSgenome.Amellifera.BeeBase.assemble4"


우리는 E.coli의 게놈에서 'AGGAGGT' 모티프12의 발생을 조사할 것입니다. 우리는 특정 균주인 **Escherichia coli** str의 게놈 서열을 사용합니다. K12 substr.DH10B13, NCBI 접근번호는 NC_010473입니다.


12 이는 박테리아에서 단백질 합성을 시작하는 데 도움을 주는 [Shine-Dalgarno](https://en.wikipedia.org/wiki/Shine-Dalgarno_sequence) 모티브입니다.


13 실험실의 일꾼으로 알려져 있으며 실험에 자주 사용됩니다.




library("BSgenome.Ecoli.NCBI.20080805") Ecoli ShineDalgarno = "AGGAGGT" ecoli = Ecoli$NC_010473 __


`countPattern` 함수를 사용하여 너비가 50000인 창에서 패턴의 발생 횟수를 계산할 수 있습니다.




window = 50000 starts = seq(1, length(ecoli) - window, by = window) ends   = starts + window - 1 numMatches = vapply(seq_along(starts), function(i) { countPattern(shineDalgarno, ecoli[starts[i]:ends[i]], max.mismatch = 0) }, numeric(1)) table(numMatches)__



숫자 일치 항목 0 1 2 3 4 48 32 8 3 2


__


질문 2.22


이 표는 어떤 분포에 적합할까요?


__


해결책


__


푸아송은 이러한 데이터에 대한 정량적 및 그래픽 평가(그림 2.24 참조)가 보여주듯이 좋은 후보입니다.




library("vcd") gf = goodfit(numMatches, "poisson") summary(gf)__



포아송 분포에 대한 적합도 검정


X^2 df P(> X^2) 우도비 4.134932 3 0.2472577



distplot(numMatches, type = "poisson")__


[![](02-chap_files/Figure-html/fig-poissonness-1.png)](02-chap_files/Figure- html/fig-poissonness-1.png "그림 2.24: Ecoli$NC_010473 시퀀스에 따른 모티프 카운트에 대한 포아송 모델 평가.")


그림 2.24: 'Ecoli$NC_010473' 시퀀스에 따른 모티프 개수에 대한 포아송 모델 평가.


'matchPattern' 함수를 사용하여 일치 항목을 검사할 수 있습니다.




sdMatches = matchPattern(shineDalgarno, ecoli, max.mismatch = 0)__


R 명령줄에 'sdMatches'를 입력하면 이 개체에 대한 요약을 얻을 수 있습니다. 여기에는 원본 시퀀스에서 소위 _views_ 집합으로 표시되는 모든 65개 패턴 일치 위치가 포함되어 있습니다. 이제 그들 사이의 거리는 얼마나 됩니까?




betweenmotifs = gaps(sdMatches)__


따라서 이들은 실제로 66개의 보완적인 영역입니다. 이제 모티프 사이의 간격 크기 분포에 대한 모델을 찾아보겠습니다. 모티프가 무작위 위치에서 발생하는 경우 간격 길이는 지수 분포를 따를 것으로 예상됩니다. 아래 코드(출력은 그림 2.25에 표시됨)는 이 가정을 평가합니다. 지수 분포가 적합하다면 점은 대략 직선 위에 있어야 합니다. 지수 분포에는 하나의 매개변수인 비율이 있으며, 데이터의 추정치에 해당하는 기울기가 있는 선도 표시됩니다.


14 지수가 여기에 딱 들어맞는다고 어떻게 추측할 수 있습니까? 시퀀스를 따라 독립적인 무작위 베르누이 발생이 있을 때마다 간격 길이는 기하급수적으로 늘어납니다. 방출 사이의 대기 시간도 기하급수적으로 분포되는 방사성 붕괴에 대해 잘 알고 계실 것입니다. 이 분포에 익숙하지 않다면 [위키피디아](http://en.wikipedia.org/wiki/Exponential_distribution)에서 자세한 내용을 찾아보는 것이 좋습니다.




library("Renext") expplot(width(betweenmotifs), rate = 1/mean(width(betweenmotifs)), labels = "fit")__


[![](02-chap_files/Figure-html/fig-explotdata-1-1.png)](02-chap_files/Figure- html/fig-explotdata-1-1.png "그림 2.25: 모티프 간 간격의 지수 분포\(검은색 선\)에 대한 적합성 평가.")


그림 2.25: 모티프 간 간격의 지수 분포(검은색 선)에 대한 적합성 평가.


__


질문 2.23


그림 2.25의 적합선에서 분포의 오른쪽 꼬리, 즉 가장 큰 값에 약간의 편차가 있는 것으로 보입니다. 이유가 무엇일까요?


### 2.10.1 종속성의 경우 모델링


섹션 2.8에서 보았듯이 뉴클레오티드 서열은 종종 의존적입니다. 주어진 위치에서 특정 뉴클레오티드를 발견할 확률은 주변 서열에 의존하는 경향이 있습니다. 여기서는 **Markov 체인**을 사용하여 종속성 모델링을 실습해 보겠습니다. 우리는 인간 게놈의 8번 염색체 영역을 살펴보고 CpG15 섬이라고 불리는 영역과 나머지 영역 간의 차이점을 발견하려고 노력할 것입니다.


15 CpG는 5'-C-포스페이트-G-3'을 나타내고; 이는 C가 가닥을 따라 인산염을 통해 G에 연결되어 있음을 의미합니다(이것은 섹션 2.7의 C-G 염기쌍과 관련이 없습니다). CpG 디뉴클레오티드의 시토신은 메틸화되어 유전자 발현 수준을 변화시킬 수 있습니다. 이러한 유형의 유전자 조절은 **후생유전학**의 일부입니다. 더 많은 정보는 Wikipedia에 있습니다: [CpG 사이트](https://en.wikipedia.org/wiki/CpG_site) 및 [epigenetics](https://en.wikipedia.org/wiki/Epigenetics).


우리는 섬의 시작점과 끝점이 게놈에서 어디에 있는지 알려주고 뉴클레오티드와 다이그램 'CG', 'CT', 'CA', 'CC'의 빈도를 살펴보는 데이터(Irizarry, Wu 및 Feinberg([2009](16-chap.html#ref-Irizarry2009))가 생성한 데이터를 사용합니다. 따라서 우리는 뉴클레오티드 발생 사이에 종속성이 있는지 여부와 그렇다면 이를 모델링하는 방법을 물어볼 수 있습니다.




library("BSgenome.Hsapiens.UCSC.hg19") chr8 = Hsapiens$chr8 CpGtab = read.table("../data/model-based-cpg-islands-hg19.txt", 헤더 = TRUE) nrow(CpGtab)__



[1] 65699



헤드(CpGtab)__



문자 시작 끝 길이 CpGcount GCcontent pctGC obsExp 1 chr10 93098 93818 721 32 403 0.559 0.572 2 chr10 94002 94165 164 12 97 0.591 0.841 3 chr10 94527 95302 776 65 538 0.693 0.702 4문자10 119652 120193 542 53 369 0.681 0.866 5문자10 122133 122621 489 51 339 0.693 0.880 6 문자10 180265 180720 456 32 256 0.561 0.893



irCpG = with(dplyr::filter(CpGtab, chr == "chr8"), IRanges(start = start, end = end))__


[![저희는 :: 연산자를 사용하여 dplyr 패키지에서 필터 함수를 호출합니다. 로드되고 동일한 이름의 함수를 정의할 수 있는 다른 패키지에서는 호출하지 않습니다. 이 예방 조치는 필터 기능의 경우 특히 권장됩니다. 이 이름은 꽤 많은 다른 패키지에서 사용되기 때문입니다. 사람들의 이름을 \(주어진\) 이름으로 부르는 것과 같이 R 함수를 호출하는 일반적인 \(:\ 없이) 방법을 생각할 수 있습니다. 반면에 ::가 포함된 정규화된 버전은 누군가의 이름을 부르는 것과 같습니다. 적어도 CRAN 및 Bioconductor 저장소의 범위 내에서 이러한 정규화된 이름은 고유함을 보장합니다.](imgs/devil.png)](imgs/devil.png "우리는 :: 연산자를 사용하여 dplyr 패키지에서 필터 함수를 호출합니다. 로드되어 동일한 이름의 함수를 정의하는 다른 패키지에서는 호출하지 않습니다. 이 예방 조치는 필터 함수의 경우 특히 권장됩니다. 이 이름은 꽤 많은 다른 패키지에서 사용되기 때문입니다. R 함수를 호출하는 일반적인 \(:\) 방식은 사람의 이름을 \(주어진\) 이름으로 부르는 것과 같습니다. 반면 ::을 사용한 정규화된 버전은 적어도 CRAN 및 Bioconductor 저장소 범위 내에서 누군가를 호출하는 것에 해당합니다.")


우리는 `dplyr` 패키지에서 `filter` 함수를 호출하기 위해 `::` 연산자를 사용합니다. 로드되고 동일한 이름의 함수를 정의할 수 있는 다른 패키지에서는 호출되지 않습니다. 이 예방 조치는 `filter` 함수의 경우 특히 권장됩니다. 이 이름은 꽤 많은 다른 패키지에서 사용되기 때문입니다. 사람들을 이름으로 부르는 것과 같이 R 함수를 호출하는 일반적인(`::` 없이) 방법을 생각할 수 있습니다. 반면에 `::`가 포함된 정규화된 버전은 누군가를 이름으로 부르는 것에 해당합니다. 최소한 CRAN 및 Bioconductor 저장소의 범위 내에서 이러한 정규화된 이름은 고유함이 보장됩니다.


위 줄에서 데이터 프레임 `CpGtab`을 염색체 8로만 부분 집합(`필터`)한 다음 시작 및 끝 위치가 데이터 프레임의 동일하게 명명된 열에 의해 정의되는 _IRanges_ 개체를 만듭니다. 인수로부터 개체를 구성하는 'IRanges' 함수 호출에서 첫 번째 'start'는 함수의 인수 이름이고, 두 번째 'start'는 'filter'의 출력으로 얻은 데이터 프레임의 열을 나타냅니다. 'end'도 마찬가지입니다. _IRanges_는 수학적 간격에 대한 일반 컨테이너입니다. 우리는 다음 줄을 사용하여 생물학적 맥락을 만듭니다.


16 _IRanges_의 "I"는 "간격"을 의미합니다. _GRanges_의 "G"는 "게놈"을 의미합니다.




grCpG = GRanges(ranges = irCpG, seqnames = "chr8", strand = "+") genome(grCpG) = "hg19"__


이제 시각화해 보겠습니다. 그림 2.26의 출력을 참조하세요.




library("Gviz") ideo = IdeogramTrack(genome = "hg19", 염색체 = "chr8")plotTracks( list(GenomeAxisTrack(), AnnotationTrack(grCpG, 이름 = "CpG"), ideo), from = 2200000, to = 5800000, Shape = "box", fill = "#006400", stacking = "밀도")__


[![](02-chap_files/figure-html/fig-freqandbayes- ideo-1.png)](02-chap_files/figure-html/fig-freqandbayes-ideo-1.png "Figure 2.26: Gviz plot of CpG locations in a selected region of chromosome 8.")


그림 2.26: 염색체 8의 선택된 영역에 있는 CpG 위치의 **[Gviz](https://bioconductor.org/packages/Gviz/)** 플롯.


이제 우리는 CpG 섬 'irCpG'와 그 사이의 영역('gaps(irCpG)')에 해당하는 염색체 서열에 대한 소위 뷰를 정의합니다. 결과 개체 `CGIview` 및 `NonCGIview`에는 시퀀스 자체가 아닌 좌표만 포함되므로(이들은 큰 개체 `Hsapiens$chr8`에 유지됨) 저장 측면에서 상당히 가볍습니다.




CGIview    = Views(unmasked(Hsapiens$chr8), irCpG) NonCGIview = Views(unmasked(Hsapiens$chr8), gaps(irCpG))__


우리는 데이터를 사용하여 CpG 섬과 비섬의 전환 횟수를 계산합니다.




seqCGI      = as(CGIview, "DNAStringSet") seqNonCGI   = as(NonCGIview, "DNAStringSet") dinucCpG    = sapply(seqCGI, dinucleotideFrequency) dinucNonCpG = sapply(seqNonCGI, dinucleotideFrequency) dinucNonCpG[, 1]__



AA AC AG AT CA CC CG CT GA GC GG GT TA TC TG TT 389 351 400 436 498 560 112 603 359 336 403 336 330 527 519 485



NonICounts = rowSums(dinucNonCpG) IslCounts  = rowSums(dinucCpG)__


우리가 가지고 있는 4개 상태 마르코프 체인의 경우 전이 행렬을 행이 'from' 상태이고 열이 'to' 상태인 행렬로 정의합니다.




TI  = matrix( IslCounts, ncol = 4, byrow = TRUE) TnI = matrix(NonICounts, ncol = 4, byrow = TRUE) dimnames(TI) = dimnames(TnI) = list(c("A", "C", "G", "T"), c("A", "C", "G", "T"))__


각 유형의 전환 횟수를 사용하여 빈도를 계산하고 이를 두 개의 행렬에 넣습니다.


[![전환 확률은 확률이므로 행의 합이 1이 되어야 합니다.](imgs/devil.png)](imgs/devil.png "전환 확률은 확률이므로 행의 합이 1이 되어야 합니다.")


전환 확률은 확률이므로 행의 합이 1이 되어야 합니다.




MI = TI /rowSums(TI) MI __



A C G T A 0.20457773 0.2652333 0.3897678 0.1404212 C 0.20128250 0.3442381 0.2371595 0.2173200 G 0.18657245 0.3145299 0.3450223 0.1538754 T 0.09802105 0.3352314 0.3598984 0.2068492



MN = TnI / rowSums(TnI) MN __



A C G T A 0.3351380 0.1680007 0.23080886 0.2660524 C 0.3641054 0.2464366 0.04177094 0.3476871 G 0.2976696 0.2029017 0.24655406 0.2528746 T 0.2265813 0.1972407 0.24117528 0.3350027


__


질문 2.24


행마다 전환이 다릅니까? 이는 예를 들어 \\(P(\mathtt{A}\,|\,\mathtt{C}) \neq P(\mathtt{A}\,|\,\mathtt{T})\\)를 의미합니다.


__


해결책


__


전환이 다릅니다. 예를 들어, 아일랜드(MI) 전이 행렬에서 C에서 A로, T에서 A로의 전이는 매우 다르게 보입니다(0.201 대 0.098).


__


질문 2.25


CpG 섬에서는 다른 뉴클레오티드의 상대 빈도가 다른 곳과 다른가요?


__


해결책


__




freqIsl = alphabetFrequency(seqCGI, baseOnly = TRUE, collapse = TRUE)[1:4] freqIsl / sum(freqIsl)__



A C G T 0.1781693 0.3201109 0.3206298 0.1810901



freqNon = alphabetFrequency(seqNonCGI, baseOnly = TRUE, collapse = TRUE)[1:4] freqNon / sum(freqNon)__



A C G T 0.3008292 0.1993832 0.1993737 0.3004139


이는 반대 패턴을 보여줍니다. CpG 섬에서는 C와 G의 주파수가 약 0.32인 반면, CpG가 아닌 섬에서는 A와 T의 주파수가 약 0.30입니다.


__


질문 2.26


주어진 시퀀스가 ​​CpG 섬에서 오는지 여부를 결정하기 위해 이러한 차이점을 어떻게 사용할 수 있습니까?


__


해결책


__


\\(\chi^2\\) 통계를 사용하여 관찰된 주파수와 `freqIsl` 및 `freqNon` 주파수 사이의 주파수를 비교합니다. 더 짧은 시퀀스의 경우 이는 충분히 민감하지 않을 수 있으며 아래에 더 민감한 접근 방식이 제공됩니다.


CpG 섬에 있는지 아닌지 알 수 없는 시퀀스가 ​​주어지면 다른 곳에 비해 CpG 섬에 속할 확률이 얼마나 되는지 물어볼 수 있습니다. 우리는 승산비(odds ratio)를 기반으로 점수를 계산합니다. 예를 들어 보겠습니다. 시퀀스 \\(x\\)가 `ACGTTATACTACG`이고 그것이 CpG 섬에서 오는지 여부를 결정하고 싶다고 가정합니다.


시퀀스를 1차 마르코프 체인으로 모델링하면 시퀀스가 ​​CpG 섬에서 나온다고 가정하여 작성할 수 있습니다.


\\[ \begin{align} P_{\text{i}}(x = \mathtt{ACGTTATACTACG}) = \; &P_{\text{i}}(\mathtt{A}) \, P_{\text{i}}(\mathtt{AC})\, P_{\text{i}}(\mathtt{CG})\, P_{\text{i}}(\mathtt{GT})\, P_{\text{i}}(\mathtt{TT}) \times \\\ &P_{\text{i}}(\mathtt{TA})\, P_{\text{i}}(\mathtt{AT})\, P_{\text{i}}(\mathtt{TA})\, P_{\text{i}}(\mathtt{AC})\, P_{\text{i}}(\mathtt{CG}). \end{align} \\]


우리는 이 확률을 섬이 아닌 곳의 확률과 비교할 것입니다. 위에서 본 것처럼 이러한 확률은 상당히 다른 경향이 있습니다. 우리는 그들의 비율을 취하여 그것이 1보다 크거나 작은지 확인할 것입니다. 이러한 확률은 많은 작은 항의 곱이 될 것이며 매우 작아질 것입니다. 우리는 로그를 취함으로써 이 문제를 해결할 수 있습니다.


\\[ \begin{align} \log&\frac{P(x\,|\, \text{섬})}{P(x\,|\,\text{비섬})}=\\\ \log&\left( \frac{P_{\text{i}}(\mathtt{A})\, P_{\text{i}}(\mathtt{A}\rightarrow \mathtt{C})\, P_{\text{i}}(\mathtt{C}\rightarrow \mathtt{G})\, P_{\text{i}}(\mathtt{G}\rightarrow \mathtt{T})\, P_{\text{i}}(\mathtt{T}\rightarrow \mathtt{T})\, P_{\text{i}}(\mathtt{T}\rightarrow \mathtt{A})} {P_{\text{n}}(\mathtt{A})\, P_{\text{n}}(\mathtt{A}\rightarrow \mathtt{C})\, P_{\text{n}}(\mathtt{C}\rightarrow \mathtt{G})\, P_{\text{n}}(\mathtt{G}\rightarrow \mathtt{T})\, P_{\text{n}}( \mathtt{T}\rightarrow \mathtt{T})\, P_{\text{n}}( \mathtt{T}\rightarrow \mathtt{A})} \right.\times\\\ &\left.\mathtt{A}\rightarrow \mathtt{T})\, P_{\text{i}}(\mathtt{T}\rightarrow \mathtt{A})\, P_{\text{i}}(\mathtt{A}\rightarrow \mathtt{C})\, P_{\text{i}}(\mathtt{C}\rightarrow \mathtt{G})} {P_{\text{n}}(\mathtt{A}\rightarrow \mathtt{T})\, P_{\text{n}}(\mathtt{T}\rightarrow \mathtt{A})\, P_{\text{n}}(\mathtt{A}\rightarrow \mathtt{C})\, P_{\text{n}}(\mathtt{C}\rightarrow \mathtt{G})} \right) \end{align} \tag{2.7}\\]


이것이 **로그 우도 비율** 점수입니다. 계산 속도를 높이기 위해 로그 비율 \\(\log(P_{\text{i}}(\mathtt{A})/P_{\text{n}}(\mathtt{A})),..., \log(P_{\text{i}}(\mathtt{T}\rightarrow \mathtt{A})/P_{\text{n}}(\mathtt{T}\rightarrow \mathtt{A}))\\) 한 번에 모두 해당 내용을 합산하여 점수를 얻습니다.


[![작업된 예제와 많은 유용한 세부 정보는 Durbin et al.에서 찾을 수 있습니다. \(1998\).](imgs/book_icon.png)](imgs/book_icon.png "해결된 예제와 많은 유용한 세부정보는 @DEKM에서 찾을 수 있습니다.")


연구된 예제와 많은 유용한 세부 정보는 Durbin et al.에서 찾을 수 있습니다. ([1998](16-chap.html#ref-DEKM)).




alpha = log((freqIsl/sum(freqIsl)) / (freqNon/sum(freqNon))) beta  = log(MI / MN)__



x = "ACGTTATACTACG" scorefun = function(x) { s = unlist(strsplit(x, "")) score = alpha[s[1]] if (length(s) >= 2) for (j in 2:length(s)) score = score + beta[s[j-1], s[j]] score } scorefun(x)__



A -0.2824623


아래 코드에서는 `seqCGI` 개체의 2855개 시퀀스 중에서 `len = 100` 길이의 시퀀스를 선택한 다음 `seqNonCGI` 개체의 2854개 시퀀스 중에서 선택합니다(각각은 _DNAStringSet_입니다). `generateRandomScores` 함수의 처음 세 줄에서는 A, C, T, G 이외의 문자가 포함된 시퀀스를 삭제합니다. 와 같은 "." (정의되지 않은 뉴클레오티드에 사용되는 문자). 나머지 시퀀스 중에서 길이에서 'len'을 뺀 값에 비례하는 확률로 샘플링한 다음 길이가 'len'인 하위 시퀀스를 선택합니다. 하위 시퀀스의 시작점은 하위 시퀀스가 ​​맞아야 하는 제약 조건을 사용하여 균일하게 샘플링됩니다.




generateRandomScores = function(s, len = 100, B = 1000) { alphFreq = alphabetFrequency(s) isGoodSeq = rowSums(alphFreq[, 5:ncol(alphFreq)]) == 0 s = s[isGoodSeq] slen = sapply(s, length) prob = pmax(slen - len, 0) prob = prob / sum(prob) idx  = sample(length(s), B, replace = TRUE, prob = prob) ssmp = s[idx] start = sapply(ssmp, function(x) sample(length(x) - len, 1)) scores = sapply(seq_len(B), function(i) scorefun(as.character(ssmp[[i]][start[i]+(1:len)])) ) scores / len } scoresCGI    = generateRandomScores(seqCGI) scoresNonCGI = generateRandomScores(seqNonCGI)__



rgs = range(c(scoresCGI, scoresNonCGI)) br = seq(rgs[1], rgs[2], length.out = 50) h1 = hist(scoresCGI,    breaks = br, plot = FALSE) h2 = hist(scoresNonCGI, breaks = br, plot = FALSE) plot(h1, col = rgb(0, 0, 1, 1/4), xlim = c(-0.5, 0.5), ylim=c(0,120)) plot(h2, col = rgb(1, 0, 0, 1/4), add = TRUE)__


[![](02-chap_files/Figure-html/fig- ScoreMixture-1-1.png)](02-chap_files/Figure-html/fig-ScoreMixture-1-1.png "그림 2.27: generateRandomScores 함수에 의해 생성된 섬 및 비섬 점수. 이것은 우리가 만나는 혼합의 첫 번째 인스턴스입니다. sec-mixtures에서 다시 살펴보겠습니다.")


그림 2.27: 'generateRandomScores' 함수에 의해 생성된 섬 및 비섬 점수. 이것은 우리가 접하는 첫 번째 **혼합물** 사례입니다. 이에 대해서는 [4장](04-chap.html)에서 다시 살펴보겠습니다.


우리는 이것을 _훈련 데이터_로 간주할 수 있습니다. 유형을 알고 있는 데이터에서 점수가 식별에 유용한지 여부를 확인할 수 있습니다(그림 2.27 참조).


## 2.11 이 장의 요약


이 장에서 우리는 통계의 기본 요가, 즉 데이터에서 가능한 생성 분포로 돌아가는 방법과 이러한 분포를 정의하는 매개변수를 추정하는 방법을 경험했습니다.


**통계 모델** 범주형 결과(이항 및 다항) 실험에 대한 몇 가지 구체적인 통계 모델을 보여 주었습니다.


**적합도** 우리는 다양한 시각화를 사용하고 시뮬레이션 실험을 실행하여 데이터가 공정한 4개 상자 다항 모델에 적합할 수 있는지 테스트하는 방법을 보여주었습니다. 카이제곱 통계를 접하고 qq-plot을 사용하여 시뮬레이션과 이론을 비교하는 방법을 살펴보았습니다.


**추정** 최대 우도 및 베이지안 추정 절차에 대해 설명했습니다. 이러한 접근법은 뉴클레오티드 패턴 발견 및 일배체형 추정과 관련된 예에서 설명되었습니다.


**사전 및 사후 분포** 일배체형과 같이 이전에 연구된 유형의 데이터를 평가할 때 데이터의 사후 분포를 계산하는 것이 도움이 될 수 있습니다. 이를 통해 간단한 계산을 통해 의사결정에 불확실성을 포함할 수 있습니다. 충분한 데이터가 있는 한 사전 선택은 결과에 거의 영향을 미치지 않습니다.


**CpG 섬 및 마르코프 사슬** 우리는 DNA 서열에 따른 의존성이 마르코프 사슬 전이에 의해 어떻게 모델링될 수 있는지 살펴보았습니다. 우리는 이를 사용하여 긴 DNA 서열이 CpG 섬에서 유래했는지 여부를 확인할 수 있는 우도 비율을 기반으로 점수를 구축했습니다. 점수 히스토그램을 만들 때 그림 2.27에서 눈에 띄는 특징을 확인했습니다. 두 조각으로 구성된 것처럼 보였습니다. 이 **이중 양식**은 혼합을 처음 접한 것이며 [4장](04-chap.html)의 주제입니다.


이것은 일부 훈련 데이터에 대한 모델을 구축하는 첫 번째 사례입니다. CpG 섬에 있다는 것을 알고 있는 시퀀스는 나중에 새 데이터를 분류하는 데 사용할 수 있습니다. 우리는 [12장](12-chap.html)에서 이 작업을 수행하는 훨씬 더 완전한 방법을 개발할 것입니다.


## 2.12 추가 자료


이용 가능한 최고의 통계 입문 서적 중 하나는 Freedman, Pisani 및 Purves([1997](16-chap.html#ref-Freedman:1997))입니다. 중요한 개념을 설명하기 위해 상자 모델을 사용합니다. 통계 수업을 들어본 적이 없거나 재교육이 필요하다고 생각된다면 이 수업을 적극 권장합니다. 많은 입문 통계 수업에서는 이산형 데이터에 대한 깊이 있는 통계를 다루지 않습니다. 주제는 생물학적 응용에 필요한 중요한 부분입니다. 이러한 유형의 분석에 대한 책 한 권의 소개는 ([Agresti 2007](16-chap.html#ref-Agresti:2007))에서 찾을 수 있습니다.


여기서 우리는 간단한 구조화되지 않은 다항식의 예를 제시했습니다. 그러나 다항식의 범주(또는 상자)가 특정 구조를 갖는 경우도 있습니다. 예를 들어, 64개의 가능한 코돈은 20개의 아미노산을 코딩하고 정지 코돈(61+3)을 코딩합니다. 그래서 우리는 아미노산 자체를 자유도 20의 다항식으로 볼 수 있습니다. 각 아미노산 내에는 다양한 범주의 다항식이 있습니다(프롤린에는 'CCA, CCG, CCC, CCT', 연습 2.3 참조). 일부 다변량 방법은 서로 다른 풍부한 아미노산 내에서 코돈 사용 간의 가변성을 분해하기 위해 특별히 고안되었으며([Grantham et al. 1981](16-chap.html#ref-Grantham1981); [Perrière and Thiouluse 2002](16-chap.html#ref-Perriere2002)), 이를 통해 잠재 유전자 전달 및 번역 선택을 발견할 수 있습니다. [Chapter 9](09-chap.html)에서 범주형 데이터의 다변량 탐색을 탐구할 때 해당 논문에서 사용된 구체적인 방법을 다룰 것입니다.


불확실성을 정량화하기 위해 베이지안 패러다임을 성공적으로 사용한 사례가 많이 있습니다. 최근 몇 년 동안 마르코프 체인, 랜덤 워크 또는 해밀턴 역학을 사용하는 특수한 유형의 몬테카를로에 의해 사후 분포 계산이 혁신되었습니다. 이러한 방법은 몇 번의 반복 후에 올바른 사후 분포로 수렴되는 근사치를 제공합니다. 예와 더 많은 내용은 ([Robert and Casella 2009](16-chap.html#ref-Casella2009); [Marin and Robert 2007](16-chap.html#ref-Marin2007); [McElreath 2015](16-chap.html#ref-McElreath2015))을 참조하세요.


## 2.13 연습


__


연습 2.1


1,000개의 긴 유전자 서열을 따라 발생하는 돌연변이를 모델링하는 1,000개의 무작위 0/1 변수를 생성합니다. 이는 각각 \\(10^{-4}\\)의 비율로 독립적으로 발생합니다. 그런 다음 1,000개의 위치를 ​​합산하여 길이가 1,000인 시퀀스에서 얼마나 많은 돌연변이가 있는지 계산합니다.


적합성 테스트를 사용하여 이러한 돌연변이 합계에 대한 올바른 분포를 찾고 적합성 품질을 시각화하는 플롯을 만듭니다.


__


연습 2.2


\\(0\\)과 \\(7\\) 사이에서 \\(n\\)개의 임의의 균일수를 생성하고 최대값을 반환하는 함수를 만드세요. \\(n=25\\)에 대한 함수를 실행합니다. 이 절차를 \\(B=100\\)번 반복합니다. 이러한 최대값의 분포를 도표화합니다. 크기가 25인 표본의 최대우도 추정치는 얼마입니까(\\(\hat{\theta}\\))? 이론적 근거와 실제 최대값 \\(\theta\\)를 찾을 수 있습니까?


__


연습 2.3


유전자의 코딩 영역에 포함된 3개의 뉴클레오티드(**코돈**) 시퀀스는 20개의 가능한 아미노산 중 하나로 전사될 수 있습니다. \\(4^3=64\\)개의 가능한 코돈 서열이 있지만 아미노산은 20개뿐입니다. 우리는 **유전자 코드**가 중복된다고 말합니다. 각 아미노산을 _철자_하는 방법에는 여러 가지가 있습니다.


다중도(동일한 아미노산을 코딩하는 코돈의 수)는 2에서 6까지 다양합니다. 각 아미노산의 서로 다른 코돈 철자는 동일한 확률로 발생하지 않습니다. 표준 실험실 결핵균(H37Rv)에 대한 데이터를 살펴보겠습니다.




mtb = read.table("../data/M_tuberculosis.txt", header = TRUE) head(mtb, n = 4)__



AmAcid 코돈 번호 PerThous 1 Gly GGG 25874 19.25 2 Gly GGA 13306 9.90 3 Gly GGT 25320 18.84 4 Gly GGC 68310 50.82


아미노산 프롤린에 대한 코돈은 \\(CC*\\) 형식이며 Mycobacterium turberculosis에서 다음과 같은 빈도로 발생합니다.




pro  =  mtb[ mtb$AmAcid == "Pro", "Number"] pro/sum(pro)__



[1] 0.54302025 0.10532985 0.05859765 0.29305225


1. 'AmAcid' 및 'Codon' 변수를 표로 만들기 위해 'table'을 사용하여 데이터 'mtb'를 탐색합니다.

2. PerThous 변수는 어떻게 만들어졌나요?

3. 가장 강한 **코돈 편향**, 즉 가능한 철자 중에서 균일 분포에서 가장 강한 이탈을 보이는 아미노산을 찾기 위해 표에 적용할 수 있는 R 함수를 작성하세요.

\\(*\\)는 정규식에 대한 컴퓨터 표기법을 사용하여 4개 문자 중 하나를 나타냅니다.


__


연습 2.4


_Staphylococcus Aureus_의 순서에 따라 실행 창에 GC 콘텐츠를 표시합니다. 파일에서 _fasta_ 파일 시퀀스를 읽습니다.




staph = readDNAStringSet("../data/staphsequence.ffn.txt", "fasta")__


1. 전체 `staph` 개체를 살펴본 다음 세트의 처음 세 시퀀스를 표시합니다.

2. 너비가 100인 슬라이딩 윈도우의 시퀀스를 따라 GC 콘텐츠를 찾습니다.

3. b)의 결과를 표시합니다.

4. 시퀀스를 따라 이러한 비율의 전반적인 추세를 어떻게 시각화할 수 있습니까?

__


해결책


__


1. 데이터는 다음을 사용하여 표시됩니다.



포도상구균[1:3, ]__



길이가 3인 DNAStringSet 객체: 너비 seq 이름 [1] 1362 ATGTCGGAAAAAGAAATTTGGGA...AAAAAGAAATAAGAAATGTATAA lcl|NC_002952.2_c... [2] 1134 ATGATGGAATTCACTATTAAAAG...TTTTACCAATCAGAACTTACTAA lcl|NC_002952.2_c... [3] 246 GTGATTATTTTGGTTCAAGAAGT...TCATTCATCAAGGTGAACAATGA lcl|NC_002952.2_c...



포도상 구균 __



길이가 2650인 DNAStringSet 개체: 너비 시퀀스 이름 [1] 1362 ATGTCGGAAAAAGAAATTTGGG...AAAGAAATAAGAAATGTATAA lcl|NC_002952.2_c... [2] 1134 ATGATGGAATTCACTATTAAAA...TTACCAATCAGAACTTACTAA lcl|NC_002952.2_c... [3] 246 GTGATTATTTTGGTTCAAGAAG...ATTCATCAAGGTGAACAATGA lcl|NC_002952.2_c... [4] 1113 ATGAAGTTAAATACACTCCAAT...CAAGGTGAAATTATAAAGTAA lcl|NC_002952.2_c... [5] 1932 GTGACTGCATTGTCAGATGTAA...TATGCAAACTTAGACTTCTAA lcl|NC_002952.2_c... ... ... ... [2646] 720 ATGACTGTAGAATGGTTAGCAG...ACTCCTTTACTTGAAAAATAA lcl|NC_002952.2_c... [2647] 1878 GTGGTTCAAGAATATGATGTAA...CTCCAAAGGGTGAGTGACTAA lcl|NC_002952.2_c... [2648] 1380 ATGGATTTAGATACAATTACGA...CAATTCTGCTTAGGTAAATAG lcl|NC_002952.2_c... [2649] 348 TTGGAAAAAGCTTACCGAATTA...TTTAATAAAAAGATTAAGTAA lcl|NC_002952.2_c... [2650] 138 ATGGTAAAACGTACTTATCAAC...CGTAAAGTTTTATCTGCATAA lcl|NC_002952.2_c...


2. 'letterFrequency' 함수를 사용하여 빈도를 계산할 수 있습니다.



letterFrequency(staph[[1]], 문자 = "ACGT", OR = 0)__



A C G T 522 219 229 392



GCstaph = data.frame( ID = names(staph), GC = rowSums(alphabetFrequency(staph)[, 2:3] / width(staph)) * 100 )__


3. 플롯팅은 다음과 같이 수행될 수 있습니다. 여기서는 시퀀스 364에 대한 예시입니다(그림 2.28).



window = 100 gc = rowSums( letterFrequencyInSlidingView(staph[[364]], window, c("G","C")))/window plot(x = seq(along = gc), y = gc, type = "l")__


[![](02-chap_files/Figure-html/fig-SlidingGC-1-1.png)](02-chap_files/Figure-html/fig-SlidingGC-1-1.png "그림 2.28: 황색포도상구균 게놈의 시퀀스 364에 따른 GC 콘텐츠.")


그림 2.28: _Staphylococcus Aureus_ 게놈의 서열 364에 따른 GC 함량.


4. 창을 따라 'lowess' 함수를 사용하여 데이터를 평활화하면 전반적인 추세를 볼 수 있습니다.



줄거리(x = seq(along = gc), y = gc, 유형 = "l") 행(lowess(x = seq(along = gc), y = gc, f = 0.2), col = 2)__


[![](02-chap_files/Figure-html/fig- SmoothSlidingGC-1-1.png)](02-chap_files/Figure-html/fig- SmoothSlidingGC-1-1.png "그림 2.29: 스무딩이 포함된 그림 fig-SlidingGC-1과 유사합니다.")


그림 2.29: 그림 2.28과 유사하며 평활화가 적용되었습니다.


시퀀스를 따라 이동할 때 항상 여러 가능한 **상태** 중 하나에 있다는 아이디어를 사용하여 창에 비정상적으로 높은 GC 콘텐츠가 있는지 여부를 결정하는 적절한 방법을 나중에 살펴보겠습니다. 그러나 우리는 상태를 직접 관찰하지 않고 순서만 관찰합니다. 이러한 모델을 **숨겨진(상태) 마르코프 모델** 또는 줄여서 HMM이라고 합니다([Wikipedia](http://en.wikipedia.org/wiki/Hidden_Markov_model) 참조). 이 모델 이름의 _Markov_는 이웃 위치 간의 종속성을 모델링하는 방법에 대한 것이며, _hidden_ ​​부분은 상태가 직접 관찰되지 않음, 즉 숨겨진 것을 나타냅니다.


__


연습 2.5


그림 2.19와 유사한 그림을 다시 실행하되 두 가지 다른 분포, 즉 균일 분포(Beta(1,1))와 Beta(\\(\frac{1}{2},\frac{1}{2}\\))를 포함합니다. 무엇을 알아차렸나요?


__


해결책


__




dfbetas = data.frame( p = rep(p_seq, 5), dbeta = c(dbeta(p_seq, 0.5, 0.5), dbeta(p_seq,   1,   1), dbeta(p_seq,  10,  30), dbeta(p_seq,  20,  60), dbeta(p_seq,  50, 150)), pars = rep(c("Beta(0.5,0.5)", "U(0,1)=Beta(1,1)", "Beta(10,30)", "Beta(20,60)", "Beta(50,150)"), each = length(p_seq))) ggplot(dfbetas) + geom_line(aes(x = p, y = dbeta, colour = pars)) + theme(legend.title = element_blank()) + geom_vline(aes(xintercept = 0.25), colour = "#990000", linetype = "dashed")__


[![](02-chap_files/Figure-html/fig-histobeta4-1-1.png)](02-chap_files/Figure-html/fig-histobeta4-1-1.png "그림 2.30: 다양한 매개변수 선택에 대한 베타 밀도.")


그림 2.30: 다양한 매개변수 선택에 대한 베타 밀도.


1보다 큰 매개변수를 갖는 베타 분포는 단봉인 반면, Beta(0.5,0.5) 분포는 쌍봉이고 Beta(1,1)은 평탄하며 최빈값이 없습니다.


__


연습 2.6


베타 분포의 매개변수에 대한 사전 설정을 직접 선택하세요. 여기에서 스케치하면 됩니다.

<https://jhubiostatistics.shinyapps.io/drawyourprior>. Once you have set up a
먼저 \\(n=300\\)번의 시도 중 \\(Y = 40\\)번의 성공을 확인한 섹션 2.9.1의 데이터를 다시 분석하세요. QQ 플롯을 사용하여 해당 섹션에서 얻은 사후 분포를 비교하십시오.


아그레스티, 앨런. 2007. _범주형 데이터 분석 소개_. 존 와일리.


캐닝스, 크리스, 앤서니 WF 에드워즈. 1968. “자연 선택과 드 피네티 다이어그램.” _인간 유전학 연대기_ 31 (4): 421–28.


클리블랜드, 윌리엄 S. 1988. _John w.의 수집 작품. 터키: 그래픽 1965-1985_. Vol. 5. CRC를 누릅니다.


더빈, 리차드, 션 에디, 앤더스 크로그, 그레이엄 미치슨. 1998. _생물학적 서열 분석_. 케임브리지 대학 출판부.


엘슨, D, E 샤가프. 1952. "성게 배우자의 Desoxyribonucleic Acid 함량." _경험_ 8(4): 143–45.


피네티, 브루노 데. 1926. "Considerazioni Matematiche Sull'ereditarieta Mendeliana." _메트론_ ​​6:3–41.


프리드먼, 데이비드, 로버트 피사니, 로저 퍼브스. 1997. _통계_. 뉴욕, 뉴욕: WW 노턴.


Grantham, Richard, Christian Gautier, Manolo Gouy, M Jacobzone 및 R Mercier.

1981. “코돈 카탈로그 사용은 유전자에 맞게 조정된 게놈 전략입니다
표현력.” _핵산연구_ 9(1): 213–13.


Irizarry, 라파엘 A, 하오 우, 앤드류 P 페인버그. 2009. “CpG 섬의 종-일반화 확률 모델 기반 정의.” _포유류 게놈_ 20 (9-10): 674–80.


사랑, 미카엘 1세, 볼프강 후버, 사이먼 앤더스. 2014. "DESeq2를 사용한 RNA-seq 데이터의 접힘 변화 및 분산에 대한 적절한 추정." _그놈 생물학_ 15 (12): 1–21.


마린, 장 미셸, 크리스티앙 로버트. 2007. _베이지안 핵심: 전산 베이지안 통계에 대한 실용적인 접근 방식_. Springer 과학 및 비즈니스 미디어.


맥엘리스, 리처드. 2015. _통계적 재검토: R 및 Stan의 예를 사용한 베이지안 코스_. 행상인; 홀/CRC.


Mourant, AE, Ada Kopec 및 K Domaniewska-Sobczak. 1976. "인간 혈액형의 분포 2판." 옥스포드 대학 출판부 런던.


페리에르(Perrière), 기(Guy), 장 티울루즈(Jean Thiouluse). 2002. "코돈 사용 연구에서 대응 분석의 사용 및 오용." _핵산연구_ 30(20): 4548–55.


라이스, 존. 2006. _수학적 통계 및 데이터 분석_. 센게이지 학습.


로버트, 크리스찬, 조지 카셀라. 2009. _R을 이용한 몬테카를로 방법 소개_. Springer 과학 및 비즈니스 미디어.


R 버전 4.5.1(2025-06-13)을 사용하여 2025-09-01 01:33에 작성된 페이지


