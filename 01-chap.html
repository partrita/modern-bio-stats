<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>3&nbsp; 1.2 실제 예제 – Modern Statistics for Modern Biology</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./02-chap.html" rel="next">
<link href="./00-chap.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-ed96de9b727972fe78a7b5d16c58bf87.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-e1e3f43fb246ec3c8b6ce777d50d2ce9.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="msmb.css">
</head>

<body class="nav-sidebar docked quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./01-chap.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">1.2 실제 예제</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Modern Statistics for Modern Biology</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">홈</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./00-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">이 책에는 무엇이 들어있나요?</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01-chap.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">1.2 실제 예제</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">매개변수가 핵심입니다.</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">3.2 기본 R 플로팅</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">4.2 유한 혼합물</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">5.2 데이터란 무엇이며 왜 군집화하는가?</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">6.1.1 쏟아지는 데이터 속에서 정보 찾기</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">7.2 데이터란 무엇인가? 행렬과 그 동기</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./08-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">8.2 몇 가지 핵심 개념</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./09-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">9.2 다차원 척도법과 서열화 (Ordination)</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./10-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">10.2 그래프(Graphs)</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./11-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">11.1 이 장의 목표</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./12-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">지도 학습 (Supervised Learning)</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./13-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">13.1 이 장의 목표</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./14-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">14-chap.html</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./15-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">15-chap.html</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./16-chap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">16-chap.html</span></span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#이산-확률-모델-사용하기" id="toc-이산-확률-모델-사용하기" class="nav-link active" data-scroll-target="#이산-확률-모델-사용하기"><span class="header-section-number">3.1</span> 1.3 이산 확률 모델 사용하기</a>
  <ul class="collapse">
  <li><a href="#베르누이-시행" id="toc-베르누이-시행" class="nav-link" data-scroll-target="#베르누이-시행"><span class="header-section-number">3.1.1</span> 1.3.1 베르누이 시행</a></li>
  <li><a href="#이항-성공-횟수" id="toc-이항-성공-횟수" class="nav-link" data-scroll-target="#이항-성공-횟수"><span class="header-section-number">3.1.2</span> 1.3.2 이항 성공 횟수</a></li>
  <li><a href="#푸아송-분포" id="toc-푸아송-분포" class="nav-link" data-scroll-target="#푸아송-분포"><span class="header-section-number">3.1.3</span> 1.3.3 푸아송 분포</a></li>
  <li><a href="#에피토프-검출을-위한-생성-모델" id="toc-에피토프-검출을-위한-생성-모델" class="nav-link" data-scroll-target="#에피토프-검출을-위한-생성-모델"><span class="header-section-number">3.1.4</span> 1.3.4 에피토프 검출을 위한 생성 모델</a></li>
  </ul></li>
  <li><a href="#다항-분포-dna의-사례" id="toc-다항-분포-dna의-사례" class="nav-link" data-scroll-target="#다항-분포-dna의-사례"><span class="header-section-number">3.2</span> 1.4 다항 분포: DNA의 사례</a>
  <ul class="collapse">
  <li><a href="#검정력-시뮬레이션-simulating-for-power" id="toc-검정력-시뮬레이션-simulating-for-power" class="nav-link" data-scroll-target="#검정력-시뮬레이션-simulating-for-power"><span class="header-section-number">3.2.1</span> 1.4.1 검정력 시뮬레이션 (Simulating for power)</a></li>
  </ul></li>
  <li><a href="#이-장의-요약" id="toc-이-장의-요약" class="nav-link" data-scroll-target="#이-장의-요약"><span class="header-section-number">3.3</span> 1.5 이 장의 요약</a></li>
  <li><a href="#더-읽을거리" id="toc-더-읽을거리" class="nav-link" data-scroll-target="#더-읽을거리"><span class="header-section-number">3.4</span> 1.6 더 읽을거리</a></li>
  <li><a href="#연습-문제" id="toc-연습-문제" class="nav-link" data-scroll-target="#연습-문제"><span class="header-section-number">3.5</span> 1.7 연습 문제</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">1.2 실제 예제</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p><img src="imgs/Pile_ou_face.png" class="img-fluid"></p>
<p>분자 생물학에서 많은 상황은 사건의 수를 세는 것과 관련이 있습니다: 얼마나 많은 코돈이 특정 철자를 사용하는지, 얼마나 많은 DNA 리드가 참조 유전체와 일치하는지, DNA 서열에서 얼마나 많은 CG 다이그램(digrams)이 관찰되는지 등입니다. 이러한 카운트는 질량이나 강도와 같이 <em>연속적인</em> 척도로 측정되는 양과 대조적으로 우리에게 <strong>이산(discrete)</strong> 변수를 제공합니다.</p>
<p>연구 중인 메커니즘이 따르는 규칙을 알고 있다면, 비록 그 결과가 무작위일지라도 계산과 표준 확률 법칙을 통해 우리가 관심 있는 모든 사건의 확률을 생성할 수 있습니다. 이는 연역과 확률 조작 방법에 대한 우리의 지식에 기반한 <strong>하향식(top-down)</strong> 접근 방식입니다. <a href="02-chap.html">2장</a>에서는 이를 데이터 기반(<strong>상향식</strong>, bottom-up) 통계 모델링과 결합하는 방법을 살펴볼 것입니다.</p>
<p>이 장에서 우리는 다음을 수행할 것입니다:</p>
<ul>
<li><p>주어진 모델로부터 가능한 모든 결과의 확률을 얻는 방법을 배우고, 실제 데이터에서 관찰된 빈도와 이론적 빈도를 어떻게 비교할 수 있는지 확인합니다.</p></li>
<li><p>에피토프(epitope) 검출 데이터를 분석하기 위해 푸아송(Poisson) 분포를 사용하는 전체 예제를 탐구합니다.</p></li>
<li><p>이산형 데이터에 가장 유용한 생성 모델인 푸아송, 이항(binomial), 다항(multinomial) 분포를 실험하는 방법을 살펴봅니다.</p></li>
<li><p>확률을 계산하고 희귀 사건을 세기 위해 R 함수를 사용합니다.</p></li>
<li><p>지정된 분포로부터 난수를 생성합니다.</p></li>
</ul>
<p>데이터 생성 과정에 대한 확률 모델이 있는 예제로 뛰어들어 봅시다. 우리 모델은 HIV(인간 면역결핍 바이러스)의 게놈을 따른 돌연변이가 복제 주기당 뉴클레오타이드당 \(5 ^{-4}\)의 비율로 발생한다고 말합니다. 돌연변이율은 각 뉴클레오타이드 위치에서 동일하며, 한 위치에서의 돌연변이는 다른 위치에서 일어나는 일과 독립적으로 발생합니다1. HIV의 게놈 크기는 약 \(10^4=10,000\) 뉴클레오타이드이므로, 한 주기 후에 총 돌연변이 수는 비율이 \(5 ^{-4} ^4 = 5\)인 <strong>푸아송(Poisson)</strong> 분포2를 따를 것입니다. 이것이 우리에게 무엇을 말해줄까요?</p>
<p>1 실제로는, 그리고 엄밀히 말하자면, 충분히 자세히 살펴보면 완전하고 절대적인 독립성이 현실에서 유지되는 경우는 드뭅니다. 따라서 모델러들이 그러한 주장을 할 때 대개 의미하는 바는, 발생 가능한 상관관계나 의존성이 너무 약하고 드물어서 이를 무시하는 것이 충분히 좋은 근사치라는 것입니다.</p>
<p>2 이러한 유형의 확률 분포에 대해서는 나중에 더 자세히 다룰 것입니다.</p>
<p>이 확률 모델은 한 번의 복제 주기 동안의 돌연변이 수가 5에 가까울 것이며, 이 추정치의 가변성(표준 오차)은 \(\)가 될 것이라고 예측합니다. 이제 우리는 전형적인 HIV 균주에서 볼 것으로 예상되는 돌연변이 수와 그 가변성 모두에 대한 기준 참조 값을 갖게 되었습니다.</p>
<p>사실 우리는 훨씬 더 자세한 정보를 이끌어낼 수 있습니다. 만약 우리가 푸아송(5) 모델하에서 3번의 돌연변이가 얼마나 자주 발생할 수 있는지 알고 싶다면, 람다(\(\))라고 불리는 푸아송 분포의 <strong>율 매개변수(rate parameter)</strong> 값을 5로 설정하고 R 함수를 사용하여 \(x=3\)인 사건을 볼 확률을 생성할 수 있습니다.</p>
<p>\(\)나 \(\)와 같은 그리스 문자는 종종 우리가 사용하는 확률 분포를 특징짓는 중요한 매개변수를 나타냅니다.</p>
<pre><code>dpois(x = 3, lambda = 5)__


[1] 0.1403739</code></pre>
<p>이는 정확히 세 번의 사건을 볼 확률이 약 0.14, 즉 7번 중 1번 꼴임을 말해줍니다.</p>
<p>0부터 12까지 모든 값의 확률을 생성하고 싶다면 루프(loop)를 작성할 필요가 없습니다. R의 시퀀스 연산자인 콜론(“<code>:</code>”)을 사용하여 첫 번째 인수를 이 13개 값의 <strong>벡터(vector)</strong>로 간단히 설정할 수 있습니다. 확률들을 플로팅하여 확인할 수 있습니다(그림 1.1). 이 그림과 마찬가지로, 이 책의 여백에 있는 대부분의 그림은 본문에 표시된 코드에 의해 생성됩니다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="imgs/devil.png" title="R의 출력 형식이 어떻게 지정되는지 주목하세요: 첫 번째 줄은 벡터의 첫 번째 항목으로 시작하므로 [1]이고, 두 번째 줄은 9번째 항목으로 시작하므로 [9]입니다. 이는 긴 벡터에서 요소들의 위치를 파악하는 데 도움이 됩니다. 벡터(vector)라는 용어는 동일한 유형(이 경우 숫자)의 순서가 지정된 요소 리스트를 일컫는 R 용어입니다."><img src="imgs/devil.png" class="img-fluid figure-img"></a></p>
<figcaption>R의 출력 형식이 어떻게 지정되는지 주목하세요: 첫 번째 줄은 벡터의 첫 번째 항목으로 시작하므로 [1]이고, 두 번째 줄은 9번째 항목으로 시작하므로 [9]입니다. 이는 긴 벡터에서 요소들의 위치를 파악하는 데 도움이 됩니다. 벡터(vector)라는 용어는 동일한 유형(이 경우 숫자)의 순서가 지정된 요소 리스트를 일컫는 R 용어입니다.</figcaption>
</figure>
</div>
<p>R의 출력 형식이 어떻게 지정되는지 주목하세요: 첫 번째 줄은 벡터의 첫 번째 항목으로 시작하므로 [1]이고, 두 번째 줄은 9번째 항목으로 시작하므로 [9]입니다. 이는 긴 벡터에서 요소들의 위치를 파악하는 데 도움이 됩니다. _벡터(vector)_라는 용어는 동일한 유형(이 경우 숫자)의 순서가 지정된 요소 리스트를 일컫는 R 용어입니다.</p>
<pre><code>0:12 __


 [1]  0  1  2  3  4  5  6  7  8  9 10 11 12


dpois(x = 0:12, lambda = 5)__


 [1] 0.0067 0.0337 0.0842 0.1404 0.1755 0.1755 0.1462 0.1044 0.0653 0.0363
[11] 0.0181 0.0082 0.0034


barplot(dpois(0:12, 5), names.arg = 0:12, col = "red")__</code></pre>
<p><a href="01-chap_files/figure- html/fig-Poisson5-1.png" title="그림 1.1: 푸아송(5) 분포에 의해 모델링된 0, 1, 2, …, 12개의 돌연변이가 나타날 확률. 플롯은 4개나 5개의 돌연변이를 자주 보게 되겠지만 12개만큼 많이 보는 경우는 드물 것임을 보여줍니다. 분포는 더 큰 숫자(13, ...)로 계속 이어지지만 확률은 점차 작아질 것이며, 여기서는 시각화하지 않았습니다."><img src="01-chap_files/figure-html/fig-Poisson5-1.png" class="img-fluid"></a></p>
<p>그림 1.1: 푸아송(5) 분포에 의해 모델링된 0, 1, 2, …, 12개의 돌연변이가 나타날 확률. 플롯은 4개나 5개의 돌연변이를 자주 보게 되겠지만 12개만큼 많이 보는 경우는 드물 것임을 보여줍니다. 분포는 더 큰 숫자(\(13, …\))로 계속 이어지지만 확률은 점차 작아질 것이며, 여기서는 시각화하지 않았습니다.</p>
<p>수학 이론은 \(x\)라는 값을 볼 푸아송 확률이 \(e^{-} ^x / x!\) 공식에 의해 주어짐을 알려줍니다. 이 책에서 우리는 때때로 이론을 논의하겠지만, 그림 1.1과 같은 구체적인 수치 예제와 시각화를 보여주는 것을 선호할 것입니다.</p>
<p>푸아송 분포는 돌연변이와 같은 희귀 사건에 대한 좋은 모델입니다. <strong>이산 사건(discrete events)</strong>에 대한 다른 유용한 확률 모델로는 베르누이(Bernoulli), 이항(binomial), 다항(multinomial) 분포가 있습니다. 이 장에서 이러한 모델들을 탐구할 것입니다.</p>
<section id="이산-확률-모델-사용하기" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="이산-확률-모델-사용하기"><span class="header-section-number">3.1</span> 1.3 이산 확률 모델 사용하기</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="imgs/devil.png" title="범주형 변수가 서로 다른 대안적인 값들을 갖는 것으로 생각하세요. 이들은 유전자 좌위에서의 서로 다른 대안인 대립유전자(alleles)와 유사한 수준(levels)들입니다."><img src="imgs/devil.png" class="img-fluid figure-img"></a></p>
<figcaption>범주형 변수가 서로 다른 대안적인 값들을 갖는 것으로 생각하세요. 이들은 유전자 좌위에서의 서로 다른 대안인 대립유전자(alleles)와 유사한 수준(levels)들입니다.</figcaption>
</figure>
</div>
<p>범주형 변수가 서로 다른 대안적인 값들을 갖는 것으로 생각하세요. 이들은 유전자 좌위에서의 서로 다른 대안인 _대립유전자(alleles)_와 유사한 <strong>수준(levels)</strong>들입니다.</p>
<p>점 돌연변이는 발생하거나 발생하지 않을 수 있습니다; 이는 이진(binary) 사건입니다. 두 가지 가능한 결과(예, 아니오)를 범주형 변수의 <strong>수준(levels)</strong>이라고 부릅니다.</p>
<p>모든 사건이 이진인 것은 아닙니다. 예를 들어, 이배체 유기체의 유전자형은 세 가지 수준(AA, Aa, aa)을 가질 수 있습니다.</p>
<p>때때로 범주형 변수의 수준 수가 매우 많을 수 있습니다; 생물학적 샘플에 있는 서로 다른 박테리아 유형의 수(수백 또는 수천 개)나 3개의 뉴클레오타이드로 형성된 코돈의 수(64개 수준)가 그 예입니다.</p>
<p>샘플에서 범주형 변수를 측정할 때, 우리는 종종 카운트 벡터에서 서로 다른 수준의 빈도를 집계하고 싶어 합니다. R은 범주형 변수를 위한 특수한 인코딩을 가지고 있으며 이를 <strong>요인(factors)</strong> 3이라고 부릅니다. 여기서는 19명의 피험자에 대한 서로 다른 혈액 유전자형을 벡터에 담아 표로 만듭니다.</p>
<p>3 R은 요인 변수가 다른 “허용되지 않은” 값들을 받아들이지 않도록 보장하며, 이는 계산을 안전하게 유지하는 데 유용합니다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="imgs/devil.png" title="c()는 가장 기본적인 함수 중 하나입니다. 동일한 유형의 요소들을 하나의 벡터로 결합합니다. 여기에 표시된 코드에서 genotype의 요소들은 문자열입니다."><img src="imgs/devil.png" class="img-fluid figure-img"></a></p>
<figcaption>c()는 가장 기본적인 함수 중 하나입니다. 동일한 유형의 요소들을 하나의 벡터로 결합합니다. 여기에 표시된 코드에서 genotype의 요소들은 문자열입니다.</figcaption>
</figure>
</div>
<p><code>c()</code>는 가장 기본적인 함수 중 하나입니다. 동일한 유형의 요소들을 하나의 벡터로 결합합니다. 여기에 표시된 코드에서 <code>genotype</code>의 요소들은 문자열입니다.</p>
<pre><code>genotype = c("AA","AO","BB","AO","OO","AO","AA","BO","BO",
             "AO","BB","AO","BO","AB","OO","AB","BB","AO","AO")
table(genotype)__


genotype
AA AB AO BB BO OO 
 2  2  7  3  3  2 </code></pre>
<p>_요인(factor)_을 생성할 때, R은 자동으로 수준을 감지합니다. <code>levels</code> 함수를 사용하여 수준에 접근할 수 있습니다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="imgs/devil.png" title="table 함수의 출력에서 입력이 요인이었다는 사실이 명확히 드러나지는 않습니다. 하지만 만약 데이터에 나타나지 않은 다른 수준이 있었다면, 테이블은 해당 수준에 대해 0의 카운트를 포함했을 것입니다."><img src="imgs/devil.png" class="img-fluid figure-img"></a></p>
<figcaption>table 함수의 출력에서 입력이 요인이었다는 사실이 명확히 드러나지는 않습니다. 하지만 만약 데이터에 나타나지 않은 다른 수준이 있었다면, 테이블은 해당 수준에 대해 0의 카운트를 포함했을 것입니다.</figcaption>
</figure>
</div>
<p><code>table</code> 함수의 출력에서 입력이 요인이었다는 사실이 명확히 드러나지는 않습니다. 하지만 만약 데이터에 나타나지 않은 다른 수준이 있었다면, 테이블은 해당 수준에 대해 0의 카운트를 포함했을 것입니다.</p>
<pre><code>genotypeF = factor(genotype)
levels(genotypeF)__


[1] "AA" "AB" "AO" "BB" "BO" "OO"


table(genotypeF)__


genotypeF
AA AB AO BB BO OO 
 2  2  7  3  3  2 </code></pre>
<p>__</p>
<p>질문 1.1</p>
<p>데이터에 아직 존재하지 않는 일부 수준을 가진 _요인_을 만들고 싶다면 어떻게 해야 할까요?</p>
<p>__</p>
<p>해결책</p>
<p>__</p>
<p><code>factor</code> 함수의 매뉴얼 페이지를 참조하세요.</p>
<p>데이터가 관찰되는 순서가 중요하지 않다면, 그 확률 변수를 <strong>교환 가능(exchangeable)</strong>하다고 부릅니다. 이 경우 요인에서 가용한 모든 정보는 요인 수준의 카운트로 요약됩니다. 그러면 빈도 벡터가 데이터의 모든 관련 정보를 캡처하는 데 <strong>충분(sufficient)</strong>하다고 말하며, 이는 데이터를 압축하는 효과적인 방법을 제공합니다.</p>
<section id="베르누이-시행" class="level3" data-number="3.1.1">
<h3 data-number="3.1.1" class="anchored" data-anchor-id="베르누이-시행"><span class="header-section-number">3.1.1</span> 1.3.1 베르누이 시행</h3>
<p><a href="imgs/BallsinBoxes2.png" title="그림 1.2: 확률이 서로 다른 두 가지 가능한 사건. 우리는 이를 확률 매개변수 p=2/3인 베르누이 분포로 모델링합니다."><img src="imgs/BallsinBoxes2.png" class="img-fluid"></a></p>
<p>그림 1.2: 확률이 서로 다른 두 가지 가능한 사건. 우리는 이를 확률 매개변수 \(p=2/3\)인 베르누이 분포로 모델링합니다.</p>
<p>동전을 던지는 것에는 두 가지 가능한 결과가 있습니다. 베르누이 시행(Bernoulli trial)이라 불리는 이 간단한 실험은 이른바 베르누이 확률 변수를 사용하여 모델링됩니다. 이 구성 요소를 이해하면 놀라울 정도로 멀리 갈 수 있습니다. 이를 사용하여 더 복잡한 모델들을 구축할 수 있습니다.</p>
<p>이러한 확률 변수들 중 일부가 어떻게 생겼는지 보기 위해 몇 가지 실험을 시도해 봅시다. 우리는 각 분포 유형에 대해 결과를 생성하도록 맞춰진 특수한 R 함수들을 사용합니다. 이들은 모두 문자 <code>r</code>로 시작하며 그 뒤에 모델 사양이 옵니다. 여기서는 이항(binomial)의 약어인 <code>binom</code>을 사용한 <code>rbinom</code>입니다.</p>
<p>15번의 공정한 동전 던지기 시퀀스를 시뮬레이션하고 싶다고 가정해 봅시다. 성공 확률이 0.5(공정한 동전)인 15번의 베르누이 시행 결과를 얻으려면 다음과 같이 씁니다.</p>
<pre><code>rbinom(15, prob = 0.5, size = 1)__


 [1] 0 0 1 1 0 0 1 1 1 1 1 0 1 0 0</code></pre>
<p>우리는 특정 <strong>매개변수(parameters)</strong> 4 세트와 함께 <code>rbinom</code> 함수를 사용합니다: 첫 번째 매개변수는 우리가 관찰하고 싶은 시행 횟수이며, 여기서는 15를 선택했습니다. <code>prob</code>로 성공 확률을 지정합니다. <code>size=1</code>을 통해 각 개별 시행이 단 한 번의 동전 던지기로만 구성됨을 선언합니다.</p>
<p>4 R 함수의 경우, 매개변수는 <strong>인수(argument)</strong>라고도 불립니다.</p>
<p>__</p>
<p>질문 1.2</p>
<p>이 함수 호출을 여러 번 반복해 보세요. 왜 답이 매번 똑같지 않을까요?</p>
<p>성공과 실패의 확률이 합해서 1이 되는 한, 베르누이 시행에서 두 확률이 서로 다를 수 있습니다5. 그림 1.2에 표시된 것처럼 오른쪽 상자에 떨어질 확률이 \(\)이고 왼쪽 상자에 떨어질 확률이 \(\)인 조건에서 공을 던지는 12번의 시행을 시뮬레이션하려면 다음과 같이 씁니다.</p>
<p>5 우리는 이러한 사건들을 <strong>여사건(complementary)</strong>이라고 부릅니다.</p>
<pre><code>rbinom(12, prob = 2/3, size = 1)__


 [1] 1 1 1 0 0 0 1 0 1 0 1 0</code></pre>
<p>1은 성공을 나타내며 공이 오른쪽 상자에 떨어졌음을 의미하고, 0은 공이 왼쪽 상자에 떨어졌음을 의미합니다.</p>
</section>
<section id="이항-성공-횟수" class="level3" data-number="3.1.2">
<h3 data-number="3.1.2" class="anchored" data-anchor-id="이항-성공-횟수"><span class="header-section-number">3.1.2</span> 1.3.2 이항 성공 횟수</h3>
<p>만약 우리가 오직 몇 개의 공이 오른쪽 상자에 들어갔는지만 관심이 있다면, 던지는 순서는 중요하지 않으며6 출력 벡터의 셀들을 합산함으로써 이 숫자를 얻을 수 있습니다. 따라서 위에서 본 이진 벡터 대신 단일 숫자만을 보고하면 됩니다. R에서는 <code>size</code> 매개변수를 12로 설정하고 <code>rbinom</code> 함수를 한 번 호출함으로써 이를 수행할 수 있습니다.</p>
<p>두 가지 결과가 있고 크기가 1 이상이면 이항 시행(binomial trial)이 됩니다. 만약 크기가 1이라면, 이는 베르누이 시행의 특수한 사례입니다.</p>
<p>6 교환성(exchangeability) 속성.</p>
<pre><code>rbinom(1, prob = 2/3, size = 12)__


[1] 9</code></pre>
<p>이 출력은 12개의 공 중에서 몇 개가 오른쪽 상자(확률 2/3인 결과)에 떨어졌는지 알려줍니다. 앞면 또는 뒷면, 성공 또는 실패, CpG 또는 non-CpG, M 또는 F, Y = 피리미딘 또는 R = 퓨린, 질병 또는 건강, 참 또는 거짓과 같이 두 가지 가능한 결과만 있는 경우 무작위 2-박스 모델을 사용합니다. “성공” 확률 \(p\)만 알면 되는데, “실패”(<em>여사건</em>)는 \(1-p\)의 확률로 발생하기 때문입니다. 그러한 여러 번의 시행 결과를 볼 때, 만약 그것들이 교환 가능하다면7 성공 횟수만을 기록합니다. 따라서 SSSSSFSSSSFFFSF는 (성공 횟수=10, 실패 횟수=5), 즉 \(x=10, n=15\)로 요약됩니다.</p>
<p>7 시행들이 서로 <strong>독립적</strong>이라면 교환 가능한 상황 중 하나입니다.</p>
<p>성공 확률이 0.3인 15번의 베르누이 시행에서의 성공 횟수를 <strong>이항(binomial)</strong> 확률 변수, 또는 \(B(15, 0.3)\) 분포를 따르는 확률 변수라고 부릅니다. 샘플을 생성하기 위해 시행 횟수를 15로 설정한 <code>rbinom</code> 함수 호출을 사용합니다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="imgs/devil.png" title="set.seed는 여기서 무엇을 하나요?"><img src="imgs/devil.png" class="img-fluid figure-img"></a></p>
<figcaption>set.seed는 여기서 무엇을 하나요?</figcaption>
</figure>
</div>
<p>여기서 <code>set.seed</code>는 무엇을 하나요?</p>
<pre><code>set.seed(235569515)
rbinom(1, prob = 0.3, size = 15)__


[1] 5</code></pre>
<p>__</p>
<p>질문 1.3</p>
<p>이 함수 호출을 10번 반복해 보세요. 가장 흔하게 나타나는 결과는 무엇인 것 같나요?</p>
<p>__</p>
<p>해결책</p>
<p>__</p>
<p>가장 빈번한 값은 4입니다. 사실, \(X\)가 \(B(15, 0.3)\)을 따를 때 4가 나타날 것으로 기대되는 이론적 비율은 \(X=4\)일 확률값입니다.</p>
<p>전체 <strong>확률 질량 분포(probability mass distribution)</strong>는 다음을 입력하여 확인할 수 있습니다.</p>
<p>출력되는 소수점 자릿수를 2자리로 유지하기 위해 <code>round</code> 함수를 사용합니다.</p>
<pre><code>probabilities = dbinom(0:15, prob = 0.3, size = 15)
round(probabilities, 2)__


 [1] 0.00 0.03 0.09 0.17 0.22 0.21 0.15 0.08 0.03 0.01 0.00 0.00 0.00 0.00 0.00
[16] 0.00</code></pre>
<p>그림 1.3에 표시된 이 분포의 막대 그래프를 생성할 수 있습니다.</p>
<pre><code>barplot(probabilities, names.arg = 0:15, col = "red")__</code></pre>
<p><a href="01-chap_files/figure- html/fig-binombarplot-1.png" title="그림 1.3: B(15, 0.3)의 이론적 분포. 가장 높은 막대는 x=4에 있습니다. 우리는 이론적 값을 전체적으로 빨간색으로 표현하기로 선택했습니다."><img src="01-chap_files/figure-html/fig-binombarplot-1.png" class="img-fluid"></a></p>
<p>그림 1.3: \(B(15, 0.3)\)의 이론적 분포. 가장 높은 막대는 \(x=4\)에 있습니다. 우리는 이론적 값을 전체적으로 빨간색으로 표현하기로 선택했습니다.</p>
<p>시행 횟수는 R에서 <code>size</code> 매개변수로 입력한 숫자이며 종종 \(n\)으로 쓰이고, 성공 확률은 \(p\)입니다. 수학 이론은 매개변수가 \((n, p)\)인 이항 분포로 분포된 \(X\)(\(X B(n, p)\)로 씀)에 대해, \(X=k\)번의 성공을 볼 확률은 다음과 같음을 알려줍니다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="imgs/devil.png" title="n! / (n-k)!k! 대신 특수 표기법 (n k)를 단축키로 사용할 수 있습니다."><img src="imgs/devil.png" class="img-fluid figure-img"></a></p>
<figcaption>n! / (n-k)!k! 대신 특수 표기법 (n k)를 단축키로 사용할 수 있습니다.</figcaption>
</figure>
</div>
<p>\(\) 대신 특수 표기법 \({n k}\)를 단축키로 사용할 수 있습니다.</p>
[
<span class="math display">\[\begin{aligned} P(X=k) &amp;=\frac{n\times (n-1)... (n-k+1)}{k\times(k-1)... 1}\; p^k\, (1-p)^{n-k}\\ &amp;=\frac{n!}{(n-k)!k!}\;p^k\, (1-p)^{n-k}\\ &amp;={ n \choose k}\; p^k\, (1-p)^{n-k}. \end{aligned}\]</span>
<p>]</p>
<p>__</p>
<p>질문 1.4</p>
<p>\(k=3, p=2/3, n=4\)일 때 위 공식의 결과값은 얼마인가요?</p>
</section>
<section id="푸아송-분포" class="level3" data-number="3.1.3">
<h3 data-number="3.1.3" class="anchored" data-anchor-id="푸아송-분포"><span class="header-section-number">3.1.3</span> 1.3.3 푸아송 분포</h3>
<p><a href="imgs/Simeon_Poisson.jpg" title="그림 1.4: 푸아송 분포의 이름을 따온 시메옹 푸아송(Simeon Poisson). 이것이 R 코드를 제외하고는 항상 대문자로 시작하는 이유입니다."><img src="imgs/Simeon_Poisson.jpg" class="img-fluid"></a></p>
<p>그림 1.4: 푸아송 분포의 이름을 따온 시메옹 푸아송(이것이 R 코드를 제외하고는 항상 대문자로 시작하는 이유입니다).</p>
<p>성공 확률 \(p\)가 작고 시행 횟수 \(n\)이 클 때, 이항 분포 \(B(n, p)\)는 더 단순한 분포인 율 매개변수 \(=np\)를 가진 <strong>푸아송(Poisson) 분포</strong>에 의해 충실하게 근사될 수 있습니다. 우리는 이미 HIV 예제(그림 1.1)에서 이 사실과 분포를 사용했습니다.</p>
<p>__</p>
<p>질문 1.5</p>
<p>뉴클레오타이드당 확률이 \(p = 5 ^{-4}\)일 때, \(n = 10^4\) 뉴클레오타이드 게놈에서 <code>0:12</code>개의 돌연변이를 관찰할 확률 질량 분포는 무엇인가요? 이항 분포 \(B(n, p)\)로 모델링할 때와 푸아송 분포 \(Poisson(=np)\)로 모델링할 때 결과가 유사한가요?</p>
<p>__</p>
<p>해결책</p>
<p>__</p>
<p>이항 분포와 달리 푸아송 분포는 더 이상 두 개의 개별 매개변수 \(n\)과 \(p\)에 의존하지 않고, 오직 그들의 곱인 \(np\)에만 의존한다는 점에 유의하세요. 이항 분포의 경우와 마찬가지로, 푸아송 확률을 계산하기 위한 수학 공식도 존재합니다.</p>
<p>[ P(X=k)= . ]</p>
<p>예를 들어, \(\)로 두고 \(P(X=3)\)을 계산해 봅시다.</p>
<pre><code>5^3 * exp(-5) / factorial(3)__


[1] 0.1403739</code></pre>
<p>이는 위에서 <code>dpois</code>를 사용하여 계산한 것과 비교할 수 있습니다.</p>
<p>__</p>
<p>태스크</p>
<p>돌연변이율이 \(5^{-4}\)인 10,000개 위치에서의 돌연변이 과정을 시뮬레이션하고 돌연변이 수를 셉니다. 이를 여러 번 반복하고 <code>barplot</code> 함수를 사용하여 분포를 플롯하세요 (그림 1.5 참조).</p>
<pre><code>rbinom(1, prob = 5e-4, size = 10000)__


[1] 6


simulations = rbinom(n = 300000, prob = 5e-4, size = 10000)
barplot(table(simulations), col = "lavender")__</code></pre>
<p><a href="01-chap_files/figure-html/fig-gen-simpoisson-1.png &quot;그림 1.5: 300,000번의 시뮬레이션에 대한 B(10000, 10^{-4})의 시뮬레이션된 분포.&quot;"><img src="01-chap_files/figure-html/fig-gen- simpoisson-1.png" class="img-fluid"></a></p>
<p>그림 1.5: 300,000번의 시뮬레이션에 대한 B(10000, \(10^{-4}\))의 시뮬레이션된 분포.</p>
<p>이제 사례 연구에서 확률 계산을 사용할 준비가 되었습니다.</p>
</section>
<section id="에피토프-검출을-위한-생성-모델" class="level3" data-number="3.1.4">
<h3 data-number="3.1.4" class="anchored" data-anchor-id="에피토프-검출을-위한-생성-모델"><span class="header-section-number">3.1.4</span> 1.3.4 에피토프 검출을 위한 생성 모델</h3>
<p>특정 의약 화합물을 테스트할 때, 알레르기 반응을 유도하는 단백질을 찾아내는 것이 중요합니다. 그러한 반응을 일으키는 분자 부위를 <strong>에피토프(epitopes)</strong>라고 부릅니다. 에피토프의 기술적 정의는 다음과 같습니다.</p>
<blockquote class="blockquote">
<p>항체가 결합하는 거대 분자 항원의 특정 부분. T 세포에 의해 인식되는 단백질 항원의 경우, 에피토프 또는 결정기(determinant)는 T 세포 수용체(TCR)에 의한 인식을 위해 주조직 적합성 복합체(MHC) 분자에 결합하는 펩타이드 부분 또는 부위이다.</p>
</blockquote>
<p>면역학이 생소하신 분들을 위해 설명하자면: <strong>항체(antibody)</strong>(그림 1.6에 도식화됨)는 체내의 이물질인 <strong>항원(antigen)</strong>에 대응하여 특정 백혈구에서 만들어지는 단백질의 일종입니다.</p>
<p><a href="imgs/Antibody_IgG2.png" title="그림 1.6: 여러 면역글로불린 도메인을 색상으로 보여주는 항체 다이어그램."><img src="imgs/Antibody_IgG2.png" class="img-fluid"></a></p>
<p>그림 1.6: 여러 면역글로불린 도메인을 색상으로 보여주는 항체 다이어그램.</p>
<p>항체는 항원에 (어느 정도의 특이성을 가지고) 결합합니다. 결합의 목적은 항원을 파괴하는 것을 돕는 것입니다. 항체는 항원의 성격에 따라 여러 방식으로 작동할 수 있습니다. 일부 항체는 항원을 직접 파괴합니다. 다른 것들은 항원을 파괴하기 위해 백혈구를 모집하는 것을 돕습니다. 항원 결정기라고도 알려진 에피토프는 면역계, 특히 항체, B 세포 또는 T 세포에 의해 인식되는 항원의 일부입니다.</p>
<section id="알려진-매개변수를-가진-elisa-오차-모델" class="level4" data-number="3.1.4.1">
<h4 data-number="3.1.4.1" class="anchored" data-anchor-id="알려진-매개변수를-가진-elisa-오차-모델"><span class="header-section-number">3.1.4.1</span> 알려진 매개변수를 가진 ELISA 오차 모델</h4>
<p>ELISA8 어세이는 단백질을 따른 서로 다른 위치에서 특정 에피토프를 검출하는 데 사용됩니다. 우리가 사용하는 ELISA 어레이에 대해 다음 사실들이 성립한다고 가정해 봅시다.</p>
<p>8 <strong>E</strong>nzyme-<strong>L</strong>inked <strong>I</strong>mmuno<strong>S</strong>orbent <strong>A</strong>ssay (<a href="http://en.wikipedia.org/wiki/ELISA">Wikipedia ELISA 링크</a>).</p>
<ul>
<li><p>위치당 기본 노이즈 수준, 즉 위양성률(false positive rate)은 1%입니다. 이는 에피토프가 없는데도 히트(hit)라고 선언할 –즉, 에피토프가 있다고 생각할– 확률입니다. 우리는 이를 \(P(|)\)9으로 씁니다.</p></li>
<li><p>단백질은 서로 독립적이라고 가정되는 100개의 서로 다른 위치에서 테스트됩니다.</p></li>
<li><p>우리는 50명의 환자 샘플 컬렉션을 조사할 것입니다.</p></li>
</ul>
<p>9 \(X|Y\)와 같은 표현식에서 수직 막대는 “\(Y\)인 <strong>조건하에</strong> \(X\)가 발생함”을 의미합니다.</p>
</section>
<section id="한-환자의-데이터" class="level4" data-number="3.1.4.2">
<h4 data-number="3.1.4.2" class="anchored" data-anchor-id="한-환자의-데이터"><span class="header-section-number">3.1.4.2</span> 한 환자의 데이터</h4>
<p>한 환자의 어세이 데이터는 다음과 같습니다.</p>
<pre><code>  [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 [38] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 [75] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</code></pre>
<p>여기서 1은 히트(따라서 알레르기 반응의 가능성)를 나타내고, 0은 해당 위치에서 반응이 없음을 나타냅니다.</p>
<p>__</p>
<p>태스크</p>
<p>50개의 독립적인 베르누이 변수(\(p=0.01\))의 합이 –충분히 좋은 근사치로– 푸아송(0.5) 확률 변수와 같음을 시뮬레이션을 통해 확인하세요.</p>
</section>
<section id="번의-어세이-결과" class="level4" data-number="3.1.4.3">
<h4 data-number="3.1.4.3" class="anchored" data-anchor-id="번의-어세이-결과"><span class="header-section-number">3.1.4.3</span> 50번의 어세이 결과</h4>
<p>우리는 100개 위치 각각에서 집계된 50명 환자 모두의 데이터를 연구할 것입니다. 만약 알레르기 반응이 없다면, 위양성률은 한 환자에 대해 각 개별 위치가 1/100의 확률로 1이 됨을 의미합니다. 따라서 50명의 환자를 집계한 후, 임의의 주어진 위치에서의 50개 관측된 \((0, 1)\) 변수의 합은 매개변수가 0.5인 푸아송 분포를 가질 것으로 기대합니다. 전형적인 결과는 그림 1.7과 같을 것입니다. 이제 그림 1.8에 표시된 것과 같은 실제 데이터가 데이터 파일 <code>e100.RData</code>로부터 R 객체 <code>e100</code>으로 로드되었다고 가정해 봅시다.</p>
<p><a href="01-chap_files/figure- html/fig-typicalP-1.png" title="그림 1.7: 배경(즉, 위양성 히트)에 대한 우리 생성 모델로부터 얻은 전형적인 데이터 플롯: 단백질을 따른 100개 위치에서, 각 위치의 카운트는 푸아송(0.5) 확률 변수로부터 추출되었습니다."><img src="01-chap_files/figure-html/fig-typicalP-1.png" class="img-fluid"></a></p>
<p>그림 1.7: 배경(즉, 위양성 히트)에 대한 우리 생성 모델로부터 얻은 전형적인 데이터 플롯: 단백질을 따른 100개 위치에서, 각 위치의 카운트는 푸아송(0.5) 확률 변수로부터 추출되었습니다.</p>
<pre><code>load("../data/e100.RData")
barplot(e100, ylim = c(0, 7), width = 0.7, xlim = c(-0.5, 100.5),
  names.arg = seq(along = e100), col = "darkolivegreen")__</code></pre>
<p><a href="01-chap_files/figure- html/fig-epitopedata-1.png" title="그림 1.8: 100개 위치에서의 50명 환자에 대한 ELISA 어레이 결과 출력."><img src="01-chap_files/figure-html/fig-epitopedata-1.png" class="img-fluid"></a></p>
<p>그림 1.8: 100개 위치에서의 50명 환자에 대한 ELISA 어레이 결과 출력.</p>
<p>그림 1.8의 스파이크(spike)가 인상적입니다. <em>에피토프가 존재하지 않는다면, 7만큼 큰 값이 나타날 확률은 얼마일까요?</em><br>
하나의 푸아송(0.5) 확률 변수를 고려할 때 7만큼 큰 숫자(또는 그 이상)를 볼 확률을 찾는다면, 그 답은 다음과 같이 닫힌 형태(closed form)로 계산될 수 있습니다.</p>
<p>[ P(X)= _{k=7}^P(X=k). ]</p>
<p>이는 물론 \(1-P(X)\)과 같습니다. 확률 \(P(X)\)은 6에서의 이른바 <strong>누적 분포(cumulative distribution)</strong> 함수이며, R에는 이를 계산하기 위한 <code>ppois</code> 함수가 있는데, 다음 두 가지 방법 중 하나로 사용할 수 있습니다:10</p>
<p>10 1에서 뺄 필요가 없다는 편리함 외에도, 이 계산들 중 두 번째 방식은 확률이 작을 때 더 정확한 경향이 있습니다. 이는 부동 소수점 연산의 한계와 관련이 있습니다.</p>
<pre><code>1 - ppois(6, 0.5)__


[1] 1.00238e-06


ppois(6, 0.5, lower.tail = FALSE)__


[1] 1.00238e-06</code></pre>
<p>__</p>
<p>태스크</p>
<p><code>ppois</code>의 매뉴얼 페이지에서 <code>lower.tail</code> 인수의 의미를 확인하세요.</p>
<p>우리는 이 숫자를 그리스 문자 엡실론(\(\)11)으로 표시합니다. 우리는 에피토프 반응이 없다고 가정할 때 7만큼 큰 카운트를 볼 확률이 다음과 같음을 보였습니다.</p>
<p>11 수학자들은 종종 작은 숫자(및 어린이들)를 \(\)이라고 부릅니다.</p>
<p>[ =P(X)=1-P(X)^{-6}. ]</p>
</section>
<section id="푸아송-분포에-대한-극단값-분석" class="level4" data-number="3.1.4.4">
<h4 data-number="3.1.4.4" class="anchored" data-anchor-id="푸아송-분포에-대한-극단값-분석"><span class="header-section-number">3.1.4.4</span> 푸아송 분포에 대한 극단값 분석</h4>
<p>잠깐만요! 위의 계산은 이 경우에 대한 <em>올바른</em> 계산이 아닙니다.</p>
<p>__</p>
<p>질문 1.6</p>
<p>에피토프가 없을 때 이 데이터를 관찰할 확률을 계산하고 싶다면, 우리의 추론에서 어떤 결함을 찾을 수 있나요?</p>
<p>__</p>
<p>해결책</p>
<p>__</p>
<p>우리는 100개 위치 모두를 살펴보고 가장 큰 값을 찾아 7임을 확인했습니다. 이러한 선택 때문에, 7만큼 큰 값이 나타날 확률은 단 하나의 위치만을 보았을 때보다 더 높습니다.</p>
<p>따라서 푸아송(0.5)이 7만큼 클 확률이 얼마인지 묻는 대신, 우리는 100번의 푸아송(0.5) 시행의 최댓값이 7만큼 클 확률은 얼마인지 자문해야 합니다. 여기서 우리는 <strong>극단값(extreme value)</strong> 분석을 사용합니다12. 우리는 데이터 값 \(x_1, x_2, …, x_{100}\)을 정렬하고 이름을 \(x_{(1)}, x_{(2)}, x_{(3)}, …, x_{(100)}\)으로 변경하여, \(x_{(1)}\)이 100개 위치 중에서 가장 작은 카운트를 나타내고 \(x_{(100)}\)이 가장 큰 카운트를 나타내도록 합니다. \(x_{(1)}, …, x_{(100)}\)을 통칭하여 이 100개 값 표본의 <strong>순위 통계량(rank statistic)</strong>이라고 부릅니다.</p>
<p>12 무작위 분포의 매우 크거나 작은 값(예: 최댓값 또는 최솟값)의 거동에 관심이 있다는 뜻입니다.</p>
<p>13 \(\)를 사용한 표기법은 합계를 위한 \(\)과 유사하게 일련의 항들의 곱을 쓰는 간결한 방법일 뿐입니다.</p>
<p>최댓값이 7만큼 큰 사건은 100개의 카운트가 모두 6보다 작거나 같은 사건의 <strong>여사건</strong>입니다. 두 여사건의 확률 합은 1입니다. 위치들이 독립적이라고 가정하므로, 이제 계산을 수행할 수 있습니다13.</p>
[
<span class="math display">\[\begin{aligned} P(x_{(100)}\geq7) &amp;=1-P(x_{(100)}\leq6)\\ &amp;=1-P(x_{(1)}\leq6)\times P(x_{(2)}\leq6)\times \cdots \times P(x_{(100)}\leq6)\\ &amp;=1-P(x_1\leq6)\times P(x_2\leq6)\times \cdots \times P(x_{100}\leq6)\\ &amp;=1-\prod_{i=1}^{100} P(x_i\leq6). \end{aligned}\]</span>
<p>]</p>
<p>이 100개의 사건 각각이 독립적이라고 가정하므로, 위에서의 결과를 사용할 수 있습니다.</p>
<p>[ _{i=1}^{100} P(x_i )= (P(x_i ))^{100}= (1-)^{100}. ]</p>
</section>
<section id="실제로-수치-계산하기" class="level4" data-number="3.1.4.5">
<h4 data-number="3.1.4.5" class="anchored" data-anchor-id="실제로-수치-계산하기"><span class="header-section-number">3.1.4.5</span> 실제로 수치 계산하기</h4>
<p>우리는 단지 R이 이 수치의 값인 \((1-)^{100}\)을 계산하게 할 수도 있습니다. 그러한 계산이 근사를 통해 어떻게 단축될 수 있는지 관심 있는 분들을 위해 몇 가지 세부 사항을 제공합니다. 처음 읽으실 때는 건너뛰셔도 됩니다.</p>
<p>우리는 위에서 \(^{-6}\)이 1보다 훨씬 작다는 것을 기억합니다. \((1-)^{100}\)의 값을 대략적으로 계산하기 위해, 우리는 이항 정리를 사용하고 \(\)의 “고차” 항들을 모두 버릴 수 있습니다. 즉, \(^2, ^3, …\) 항들은 나머지(“주요”) 항에 비해 무시할 수 있을 정도로 작기 때문입니다.</p>
<p>[ (1-)^n = _{k=0}^n {nk} , 1^{n-k} , (-)^k = 1-n+{n} ^2 - {n} ^3 + … -n - 10^{-4} ]</p>
<p>또 다른 동등한 경로는 \(e^{-} -\) 근사를 사용하는 것인데, 이는 \((1-)-\)과 같습니다. 따라서</p>
<p>[ (1-)^{100} = e<sup>{((1-)</sup>{100})} = e^{ 100 (1-)} e^{-100 } e<sup>{-10</sup>{-4}} - 10^{-4}. ]</p>
<p>따라서 에피토프가 존재하지 않을 때 100개 위치에서 히트 수가 7개 이상일 정확한 확률은 이전에 잘못 계산했던 확률의 약 100배입니다.</p>
<p>계산된 두 확률 \(10^{-6}\)과 \(10^{-4}\) 모두 표준 유의성 임계값(예: 0.05, 0.01 또는 0.001)보다 작습니다. 에피토프가 없다는 귀무 가설을 기각하는 결정은 동일했을 것입니다. 하지만 일부 법의학 법정 사례에서처럼 p-값을 유효 숫자 8자리까지 방어해야 한다면14 그것은 다른 문제입니다. 검정의 다중성을 고려한 수정된 p-값이 보고되어야 하는 값이며, 이 중요한 문제로 <a href="06-chap.html">6장</a>에서 다시 돌아올 것입니다.</p>
<p>14 이는 O.J. 심슨 사건의 법의학적 증거 조사에서 발생했습니다.</p>
</section>
<section id="시뮬레이션을-통한-확률-계산" class="level4" data-number="3.1.4.6">
<h4 data-number="3.1.4.6" class="anchored" data-anchor-id="시뮬레이션을-통한-확률-계산"><span class="header-section-number">3.1.4.6</span> 시뮬레이션을 통한 확률 계산</h4>
<p>방금 살펴본 사례에서는 이론적 확률 계산이 매우 간단했고 명시적인 계산을 통해 결과를 알아낼 수 있었습니다. 실제로는 상황이 더 복잡해지는 경향이 있으므로, 우리가 관심 있는 사건의 확률을 찾아주는 생성 모델 기반의 컴퓨터 시뮬레이션인 <strong>몬테카를로(Monte Carlo)</strong> 방법을 사용하여 확률을 계산하는 것이 더 낫습니다. 아래에서는 100개의 푸아송 분포 수에서 최댓값을 뽑는 과정을 100,000번 반복하여 생성합니다.</p>
<pre><code>maxes = replicate(100000, {
  max(rpois(100, 0.5))
})
table(maxes)__


maxes
    1     2     3     4     5     6     7     9 
    7 23028 60840 14364  1604   141    15     1 </code></pre>
<p>100,000번의 시행 중 16번에서 최댓값이 7 이상이었습니다. 이는 \(P(X_{})\)15에 대해 다음과 같은 근사치를 제공합니다.</p>
<p>15 R에서 <code>maxes &gt;= 7</code> 표현식은 <code>maxes</code>와 길이는 같지만 <code>TRUE</code>와 <code>FALSE</code> 값을 가진 논리 벡터로 평가됩니다. 여기에 <code>mean</code> 함수를 적용하면 해당 벡터는 0과 1로 변환되며, 계산 결과는 1의 비율, 즉 <code>TRUE</code>의 비율과 같아집니다.</p>
<pre><code>mean( maxes &gt;= 7 )__


[1] 0.00016</code></pre>
<p>이는 우리의 이론적 계산과 어느 정도 일치합니다. 우리는 이미 몬테카를로 시뮬레이션의 잠재적인 한계 중 하나를 보았습니다: 시뮬레이션 결과의 “해상도(granularity)”는 시뮬레이션 횟수(100,000)의 역수에 의해 결정되므로 약 10^{-5} 수준이 됩니다. 추정된 확률은 이 해상도보다 더 정밀할 수 없으며, 실제로 우리 추정치의 정밀도는 그 수 배 수준일 것입니다. 지금까지 우리가 수행한 모든 작업은 위치당 위양성률을 알고, 분석된 환자 수와 단백질 길이를 알며, 모델로부터 동일하게 분포된 독립적인 추출을 한다고 가정하고 알 수 없는 매개변수가 없기 때문에 가능했습니다. 이것은 <strong>확률 모델링</strong> 또는 <strong>생성 모델링(generative modeling)</strong>의 예시입니다: 모든 매개변수가 알려져 있고 수학적 이론을 통해 <strong>하향식</strong> 방식으로 <strong>연역(deduction)</strong>을 수행할 수 있습니다.</p>
<p>우리는 노이즈에 대해 푸아송 분포를 가정하고, 모든 매개변수를 알고 있는 척하며 수학적 연역을 통해 결론을 내릴 수 있었습니다.</p>
<p>대신에 환자 수와 단백질 길이는 알고 있지만 데이터의 분포를 모르는 좀 더 현실적인 상황에 있다면, 우리는 <strong>통계 모델링(statistical modeling)</strong>을 사용해야 합니다. 이 접근 방식은 <a href="02-chap.html">2장</a>에서 전개될 것입니다. 시작할 데이터만 있는 경우, 우리는 먼저 이를 설명하기 위해 적절한 분포를 <strong>적합(fit)</strong>시켜야 함을 보게 될 것입니다. 하지만 이 더 어려운 문제로 넘어가기 전에, 이산 분포에 대한 지식을 이분법적인 성공-또는-실패 결과 이상으로 확장해 봅시다.</p>
</section>
</section>
</section>
<section id="다항-분포-dna의-사례" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="다항-분포-dna의-사례"><span class="header-section-number">3.2</span> 1.4 다항 분포: DNA의 사례</h2>
<section id="결과가-두-가지보다-많은-경우." class="level4" data-number="3.2.0.1">
<h4 data-number="3.2.0.1" class="anchored" data-anchor-id="결과가-두-가지보다-많은-경우."><span class="header-section-number">3.2.0.1</span> 결과가 두 가지보다 많은 경우.</h4>
<p>그림 1.9의 상자들과 같이 네 가지 가능한 결과를 모델링하거나, 네 가지 뉴클레오타이드 [A, C, G] 및 [T]의 카운트를 연구할 때, 우리는 이항 모델을 확장해야 합니다.</p>
<p><a href="imgs/BallsinBoxes4.png" title="그림 1.9: 상자들은 이산 범주형 변수의 네 가지 결과 또는 수준을 나타냅니다. 오른쪽의 상자는 더 발생 가능성이 높은 결과를 나타냅니다."><img src="imgs/BallsinBoxes4.png" class="img-fluid"></a></p>
<p>그림 1.9: 상자들은 이산 <strong>범주형(categorical)</strong> 변수의 네 가지 결과 또는 수준을 나타냅니다. 오른쪽의 상자는 더 발생 가능성이 높은 결과를 나타냅니다.</p>
<p>이항 분포를 사용할 때, 결과 1에 확률 \(p=P(1)=p_1\)을 할당하고 결과 0에 확률 \(1-p=p(0)=p_0\)을 할당함으로써 두 결과에 대해 균등하지 않은 확률을 고려할 수 있었음을 상기하세요. [A, C, G] 및 [T]와 같이 두 가지보다 많은 가능한 결과가 있을 때, 우리는 서로 다른 확률에 해당하는 서로 다른 크기의 상자들에 공을 던지는 것을 생각할 수 있으며, 이 확률들을 \(p_A, p_C, p_G, p_T\)로 레이블링할 수 있습니다. 이항 분포의 경우와 마찬가지로 가능한 모든 결과의 확률 합은 1입니다: \(p_A+p_C+p_G+p_T=1\).</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="imgs/devil.png" title="여러분은 여기서 은연중에 연속 분포인 균등 분포(uniform distribution)인 runif를 만나고 있습니다."><img src="imgs/devil.png" class="img-fluid figure-img"></a></p>
<figcaption>여러분은 여기서 은연중에 연속 분포인 균등 분포(uniform distribution)인 runif를 만나고 있습니다.</figcaption>
</figure>
</div>
<p>여러분은 여기서 은연중에 연속 분포인 균등 분포, <code>runif</code>를 만나고 있습니다.</p>
<p>__</p>
<p>태스크</p>
<p><code>runif</code>라는 함수를 통해 \(0\)과 \(1\) 사이의 모든 가능한 숫자를 생성하는 난수 생성기를 실험해 보세요. 이를 사용하여 \(p_{}=, p_{}=, p_{}=, p_{}=\)인 4가지 수준(A, C, G, T)을 가진 확률 변수를 생성하세요.</p>
<p><strong>수학적 공식화.</strong> 다항 분포(Multinomial distributions)는 카운트를 집계하기 위한 가장 중요한 모델이며, R은 확률이 \(p_1, …, p_m\)인 \(m\)개의 상자로부터 \(n\)번 추출한 결과에 대한 카운트의 <strong>다항</strong> 벡터 \((x_1, …, x_m)\)의 확률을 계산하기 위해 일반 공식을 사용합니다.</p>
<p>첫 번째 항은 다음과 같이 읽습니다: 상자 1이 확률 \(p_1\)을 갖고, 상자 2가 확률 \(p_2\), …, 상자 \(m\)이 확률 \(p_m\)을 가질 때, 상자 1에서 카운트 \(x_1\), 상자 2에서 \(x_2\), …, 상자 \(m\)에서 \(x_m\)을 관찰할 결합 확률.</p>
<p>[<span class="math display">\[\begin{align} P(x_1,x_2,...,x_m) &amp;=\frac{n!}{\prod_{i=1}^m x_i!} \prod_{i=1}^m p_i^{x_i}\\ &amp;={{n}\choose{x_1,x_2,...,x_m}} \; p_1^{x_1}\,p_2^{x_2}\cdots p_m^{x_m}. \end{align}\]</span>]</p>
<p>대괄호 안의 항은 다항 계수(multinomial coefficient)라고 불리며 다음의 약어입니다: [{nx_1,x_2,…,x_m}=.] 따라서 이는 이항 계수의 일반화입니다 – \(m=2\)인 경우 이항 계수와 동일합니다.</p>
<p>__</p>
<p>질문 1.7</p>
<p>동일한 확률을 가진 네 개의 상자가 있다고 가정해 봅시다. 공식을 사용하여, 첫 번째 상자에서 4, 두 번째 상자에서 2, 그리고 나머지 두 상자에서는 아무것도 관찰되지 않을 확률은 얼마인가요?</p>
<p>__</p>
<p>해결책</p>
<p>__</p>
<p>[ P(4,2,0,0)= =. ]</p>
<pre><code>dmultinom(c(4, 2, 0, 0), prob = rep(1/4, 4))__


[1] 0.003662109</code></pre>
<p>우리는 우리가 보는 데이터가 각 상자가 동일한 확률 1/4을 갖는 가장 단순한 가능한 4-박스 모델과 일치하는지 확인하기 위해 시뮬레이션 실험을 자주 실행합니다. 어떤 의미에서 그것은 허수아비(strawman)입니다 (흥미로운 일이 일어나지 않는다는 가설). <a href="02-chap.html">2장</a>에서 이에 대한 더 많은 예시를 볼 것입니다. 여기서는 이러한 카운트 벡터를 생성하기 위해 몇 가지 R 명령어를 사용합니다. 먼저 네 가지 종류의 동일한 확률을 가진 8개의 문자가 있다고 가정해 봅시다.</p>
<pre><code>pvec = rep(1/4, 4)
t(rmultinom(1, prob = pvec, size = 8))__


     [,1] [,2] [,3] [,4]
[1,]    1    3    1    3</code></pre>
<p>__</p>
<p>질문 1.8</p>
<p><code>t()</code> 함수를 사용하지 않고 코드를 시도해 보세요; <code>t</code>는 무엇의 약자인가요?</p>
<p>__</p>
<p>질문 1.9</p>
<p><code>rmultinom(n = 8, prob = pvec, size = 1)</code>과 <code>rmultinom(n = 1, prob = pvec, size = 8)</code>의 차이를 어떻게 해석하시겠습니까? 힌트: 1.3.1절과 1.3.2절에서 우리가 한 일을 떠올려 보세요.</p>
</section>
<section id="검정력-시뮬레이션-simulating-for-power" class="level3" data-number="3.2.1">
<h3 data-number="3.2.1" class="anchored" data-anchor-id="검정력-시뮬레이션-simulating-for-power"><span class="header-section-number">3.2.1</span> 1.4.1 검정력 시뮬레이션 (Simulating for power)</h3>
<p>과학자들이 실험을 계획할 때 종종 해결해야 하는 문제인 “표본 크기가 얼마나 커야 하는가?”와 관련된 방식으로 <strong>다항 분포</strong>에 몬테카를로를 사용하는 예시를 살펴봅시다.</p>
<p><img src="imgs/SampleSize.png" class="img-fluid"></p>
<p>통계학자에게 표본 크기에 대해 물어보면, 그들은 항상 더 많은 데이터가 필요하다고 말할 것입니다. 표본 크기가 클수록 결과는 더 민감해집니다. 하지만 실험실 작업은 비용이 많이 들기 때문에, 고려해야 할 까다로운 비용-편익 상충 관계가 있습니다. 이것은 매우 중요한 문제이므로 책의 마지막 부분(<a href="13-chap.html">13장</a>)에서 한 장 전체를 할애했습니다.</p>
<p><strong>검정력(power)</strong>이라는 용어는 통계학에서 특별한 의미를 가집니다. 이는 무언가가 거기에 <em>존재할 때</em> 이를 감지할 확률로, <strong>진양성률(true positive rate)</strong>이라고도 불립니다.</p>
<p>관례적으로 실험자들은 실험을 계획할 때 80% (또는 그 이상)의 검정력을 목표로 합니다. 이는 동일한 실험을 여러 번 실행할 때, 의미 있는 결과를 내야 함에도 불구하고 약 20%의 확률로 실패할 것임을 의미합니다.</p>
<p>우리가 수집한 DNA 데이터가 4개의 뉴클레오타이드 각각이 동일하게 발생할 가능성이 있는 \((p_A, p_C, p_G, p_T)=(0.25, 0.25, 0.25, 0.25)\)인 <strong>공정한(fair)</strong> 과정으로부터 온다는 귀무 가설을 \(H_0\)라고 부릅시다. 여기서 귀무(Null)는 단지 기준선, 즉 흥미로운 일이 전혀 일어나지 않는 상태를 의미합니다. 그것은 우리가 반증(또는 통계학자들의 용어로 “기각”)하려고 시도하는 허수아비이므로, 귀무 가설은 그로부터의 이탈이 흥미로울 수 있는 것이어야 합니다16.</p>
<p>16 생물학을 조금이라도 안다면, 살아있는 유기체의 DNA가 그 귀무 가설을 따르는 경우가 거의 없음을 알 것입니다 – 따라서 이를 반증하는 것이 그리 흥미롭지 않을 수도 있습니다. 여기서는 계산을 설명하기 위해 이 귀무 가설을 사용하지만, 좋은 귀무 가설(그 기각이 흥미로운 것)을 선택하는 데는 과학적인 입력이 필요하다는 점을 상기시켜 주는 역할도 합니다.</p>
<p>동일한 크기의 상자로 표현된 8개의 문자와 4개의 동일한 확률의 결과에 대한 R 명령어를 실행하여 보았듯이, 우리는 항상 각 상자에서 2개를 얻지는 않습니다. 단지 8개의 문자만 보고 뉴클레오타이드가 공정한 과정에서 왔는지 아닌지 말하는 것은 불가능합니다.</p>
<p>길이가 \(n=20\)인 시퀀스를 살펴봄으로써, 뉴클레오타이드의 원래 분포가 공정한지 아니면 어떤 다른(“대립”) 과정으로부터 온 것인지 감지할 수 있는지 결정해 봅시다.</p>
<p><code>rmultinom</code> 함수를 사용하여 귀무 가설로부터 1000번의 시뮬레이션을 생성합니다. 공간을 절약하기 위해 처음 11개 열만 표시합니다.</p>
<pre><code>obsunder0 = rmultinom(1000, prob = pvec, size = 20)
dim(obsunder0)__


[1]    4 1000


obsunder0[, 1:11]__


     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11]
[1,]    6    5    6    8    4    6    2    7    5     4     4
[2,]    6    6    3    7    3    3    8    4    3     3     5
[3,]    3    3    6    2    8    3    5    7    4     7     6
[4,]    5    6    5    3    5    8    5    2    8     6     5</code></pre>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="imgs/devil.png" title="모든 열의 상단에 [,1][,2]... 형식의 인덱스가 있음에 주목하세요. 이들은 열 인덱스입니다. 행은 [1,][2,]...로 라벨링되어 있습니다. obsunder0 객체는 이전에 보았던 단순한 벡터가 아니라 행렬 형태의 숫자 배열입니다."><img src="imgs/devil.png" class="img-fluid figure-img"></a></p>
<figcaption>모든 열의 상단에 [,1][,2]… 형식의 인덱스가 있음에 주목하세요. 이들은 열 인덱스입니다. 행은 [1,][2,]…로 라벨링되어 있습니다. obsunder0 객체는 이전에 보았던 단순한 벡터가 아니라 행렬 형태의 숫자 배열입니다.</figcaption>
</figure>
</div>
<p>모든 열의 상단에 <code>[,1][,2]...</code> 형식의 인덱스가 있음에 주목하세요. 이들은 열 인덱스입니다. 행은 <code>[1,][2,]...</code>로 라벨링되어 있습니다. <code>obsunder0</code> 객체는 이전에 보았던 단순한 벡터가 아니라 행렬 형태의 숫자 배열입니다.</p>
<p>행렬 <code>obsunder0</code>의 각 열은 하나의 시뮬레이션된 인스턴스입니다. 상자 안의 숫자들이 많이 변하는 것을 볼 수 있습니다: 기대값은 5=20/4이지만 일부는 8만큼 큽니다.</p>
<section id="검정-만들기" class="level4" data-number="3.2.1.1">
<h4 data-number="3.2.1.1" class="anchored" data-anchor-id="검정-만들기"><span class="header-section-number">3.2.1.1</span> 검정 만들기</h4>
<p>기억하세요: 우리는 이 값들이 공정한 과정에서 온 것임을 알고 있습니다. 분명히 프로세스의 기대값을 아는 것만으로는 충분하지 않습니다. 우리는 또한 얼마나 많은 가변성이 예상되는지, 그리고 어느 정도가 너무 큰지를 설명할 수 있는 가변성 척도가 필요합니다. 우리는 다음 통계량을 우리의 척도로 사용합니다. 이는 관측값과 기대값 사이의 차이의 제곱을 기대값으로 나눈 값들의 합으로 계산됩니다. 따라서 각 인스턴스에 대해,</p>
<p>이 척도는 각 제곱 잔차(residuals)에 기대값에 상대적인 가중치를 부여합니다.</p>
<p>[ {}=+ + + =_i ]</p>
<p>처음 세 열의 생성된 데이터는 우리가 기대하는 것과 얼마나 다를까요? 다음과 같이 얻습니다:</p>
<pre><code>expected0 = pvec * 20
sum((obsunder0[, 1] - expected0)^2 / expected0)__


[1] 1.2


sum((obsunder0[, 2] - expected0)^2 / expected0)__


[1] 1.2


sum((obsunder0[, 3] - expected0)^2 / expected0)__


[1] 1.2</code></pre>
<p>척도값은 다를 수 있습니다 – 3개 이상의 열을 살펴볼 수 있으며, 1,000개 열 전체를 연구하는 방법을 알아볼 것입니다. 반복적인 입력을 피하기 위해, <code>stat</code> 공식(식 1.1)을 함수로 캡슐화합니다:</p>
<pre><code>stat = function(obsvd, exptd = 20 * pvec) {
  sum((obsvd - exptd)^2 / exptd)
}
stat(obsunder0[, 1])__


[1] 1.2</code></pre>
<p>이 변동에 대한 더 완전한 그림을 얻기 위해, 우리는 1000개 인스턴스 모두에 대해 척도값을 계산하고 이 값들을 <code>S0</code>라고 부르는 벡터에 저장합니다: 여기에는 \(H_0\)하에서 생성된 값들이 포함됩니다. 우리는 그림 1.10에 표시된 <code>S0</code> 값들의 히스토그램을 우리 <strong>귀무 분포(null distribution)</strong>의 추정치로 간주할 수 있습니다.</p>
<pre><code>S0 = apply(obsunder0, 2, stat)
summary(S0)__


   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  0.000   1.200   2.800   3.126   4.400  17.600 


hist(S0, breaks = 25, col = "lavender", main = "")__</code></pre>
<p><a href="01-chap_files/figure- html/fig-histS0-1.png" title="그림 1.10: 귀무(공정한) 분포하에서의 통계량 stat의 시뮬레이션된 값 S0의 히스토그램은 통계량 stat의 표집 분포에 대한 근사치를 제공합니다."><img src="01-chap_files/figure-html/fig-histS0-1.png" class="img-fluid"></a></p>
<p>그림 1.10: 귀무(공정한) 분포하에서의 통계량 <code>stat</code>의 시뮬레이션된 값 <code>S0</code>의 히스토그램은 통계량 <code>stat</code>의 <strong>표집 분포(sampling distribution)</strong>에 대한 근사치를 제공합니다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="imgs/devil.png" title="apply 함수는 배열의 행이나 열에 대한 루프의 축약형입니다. 여기서 두 번째 인수 2는 열에 대해 루프를 돌 것을 나타냅니다."><img src="imgs/devil.png" class="img-fluid figure-img"></a></p>
<figcaption>apply 함수는 배열의 행이나 열에 대한 루프의 축약형입니다. 여기서 두 번째 인수 2는 열에 대해 루프를 돌 것을 나타냅니다.</figcaption>
</figure>
</div>
<p><code>apply</code> 함수는 배열의 행이나 열에 대한 루프의 축약형입니다. 여기서 두 번째 인수 2는 열에 대해 루프를 돌 것을 나타냅니다.</p>
<p>요약 함수는 <code>S0</code>가 다양한 값의 범위를 가진다는 것을 보여줍니다. 시뮬레이션된 데이터로부터 우리는 예를 들어 95% 분위수(가장 큰 5%의 값과 작은 95%의 값을 구분하는 값)를 근사할 수 있습니다.</p>
<pre><code>q95 = quantile(S0, probs = 0.95)
q95 __


95% 
7.6 </code></pre>
<p>따라서 우리는 <code>S0</code> 값의 5%가 7.6보다 크다는 것을 알 수 있습니다. 우리는 이를 데이터 검정을 위한 임계값으로 제안할 것이며, 만약 가중 제곱합 <code>stat</code>이 7.6보다 크다면 뉴클레오타이드가 동일한 확률로 발생하는 공정한 과정에서 데이터가 왔다는 가설을 기각할 것입니다.</p>
</section>
<section id="검정력-결정하기" class="level4" data-number="3.2.1.2">
<h4 data-number="3.2.1.2" class="anchored" data-anchor-id="검정력-결정하기"><span class="header-section-number">3.2.1.2</span> 검정력 결정하기</h4>
<p>우리는 가중 제곱합 차이에 기반한 우리 검정이, 데이터가 실제로 귀무 가설로부터 오지 않았을 때 이를 감지해낼 확률을 계산해야 합니다. 우리는 시뮬레이션을 통해 기각 확률을 계산합니다. <code>pvecA</code>로 매개변수화된 대립 과정(alternative process)으로부터 1000번의 시뮬레이션 인스턴스를 생성합니다.</p>
<p><img src="imgs/roulette.png" class="img-fluid"></p>
<pre><code>pvecA = c(3/8, 1/4, 1/4, 1/8)
observed = rmultinom(1000, prob = pvecA, size = 20)
dim(observed)__


[1]    4 1000


observed[, 1:7]__


     [,1] [,2] [,3] [,4] [,5] [,6] [,7]
[1,]   10    4    8    8    4    7    7
[2,]    3   10    5    6    6    7    2
[3,]    5    3    5    6    4    2    6
[4,]    2    3    2    0    6    4    5


apply(observed, 1, mean)__


[1] 7.469 4.974 5.085 2.472


expectedA = pvecA * 20
expectedA __


[1] 7.5 5.0 5.0 2.5</code></pre>
<p>귀무 가설로부터의 시뮬레이션과 마찬가지로, 관측값들은 상당히 다양합니다. 질문은: 우리 검정이 (1000번의 인스턴스 중) 얼마나 자주 데이터가 귀무 가설로부터 벗어났음을 감지해낼 것인가 하는 것입니다.</p>
<p>통계량 값이 95번째 백분위수 내에 있기 때문에 검정은 첫 번째 관측치 (10, 3, 5, 2)를 기각하지 않습니다.</p>
<pre><code>stat(observed[, 1])__


[1] 7.6


S1 = apply(observed, 2, stat)
q95 __


95% 
7.6 


sum(S1 &gt; q95)__


[1] 199


power = mean(S1 &gt; q95)
power __


[1] 0.199</code></pre>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="imgs/devil.png" title="우리는 수직 막대를 ~이 주어졌을 때 또는 ~에 대한 조건부로 읽습니다."><img src="imgs/devil.png" class="img-fluid figure-img"></a></p>
<figcaption>우리는 수직 막대를 ~이 주어졌을 때 또는 ~에 대한 조건부로 읽습니다.</figcaption>
</figure>
</div>
<p>우리는 수직 막대를 <strong>~이 주어졌을 때</strong> 또는 <strong>조건부</strong>로 읽습니다.</p>
<p>1000번의 시뮬레이션에 걸쳐 실행했을 때, 검정은 199개를 대립 분포로부터 온 것으로 식별했습니다. 따라서 우리는 확률 \(P(H_0 ;|; H_A)\)가 0.199임을 계산했습니다.</p>
<p>시퀀스 길이 \(n = 20\)을 사용하면 공정한 생성 과정과 우리 <strong>대립 가설</strong> 사이의 차이를 감지할 수 있는 약 20%의 _검정력_을 가집니다.</p>
<p>__</p>
<p>태스크</p>
<p>실제로 앞서 언급했듯이, 수용 가능한 검정력 값은 0.8 이상입니다. 시뮬레이션 실험을 반복하고 검정력이 수용 가능한 수준이 되도록 보장하는 새로운 시퀀스 길이 \(n\)을 제안하세요.</p>
</section>
<section id="고전적-데이터에-대한-고전적-통계" class="level4" data-number="3.2.1.3">
<h4 data-number="3.2.1.3" class="anchored" data-anchor-id="고전적-데이터에-대한-고전적-통계"><span class="header-section-number">3.2.1.3</span> 고전적 데이터에 대한 고전적 통계</h4>
<p>95번째 백분위수를 계산하기 위해 몬테카를로를 사용하여 데이터를 시뮬레이션할 필요는 없었습니다; 계산을 돕는 적절한 이론이 존재합니다.</p>
<p>우리의 통계량 <code>stat</code>은 사실 (자유도가 3인) <strong>카이제곱(chi-square)</strong> 분포라 불리는 잘 알려진 분포를 따르며 \({}^2_3\)로 쓰여집니다.</p>
<p><a href="imgs/ProbaDiagram.png" title="그림 11.11: 우리는 확률 모델이 F라고 부르는 분포를 어떻게 갖는지 공부했습니다. F는 관례적으로 \theta와 같은 그리스 문자로 표시되는 매개변수들에 의존하는 경우가 많습니다. 관측된 데이터는 갈색 화살표를 통해 생성되며 x와 같은 라틴 문자로 표시됩니다. 확률 계산에서 수직 막대는 ~라고 가정할 때 또는 조건부를 나타냅니다."><img src="imgs/ProbaDiagram.png" class="img-fluid"></a></p>
<p>그림 1.11: 우리는 확률 모델이 \(F\)라고 부르는 분포를 어떻게 갖는지 공부했습니다. \(F\)는 관례적으로 \(\)와 같은 그리스 문자로 표시되는 매개변수들에 의존하는 경우가 많습니다. 관측된 데이터는 갈색 화살표를 통해 생성되며 \(x\)와 같은 라틴 문자로 표시됩니다. 확률 계산에서 수직 막대는 <strong>~라고 가정할 때</strong> 또는 <strong>조건부</strong>를 나타냅니다.</p>
<p>우리는 <a href="02-chap.html">2장</a>에서 Q-Q 플롯을 사용하여 분포를 비교하는 방법을 살펴볼 것입니다 (<a href="02-chap.html#fig-qqplot3-1">그림 2.8</a> 참조). 직접 만든 시뮬레이션을 실행하는 대신 더 표준적인 검정을 사용할 수도 있었습니다. 하지만 우리가 배운 절차는 카이제곱 분포가 적용되지 않는 많은 상황으로 확장됩니다. 예를 들어, 일부 상자가 매우 낮은 확률을 가지고 카운트가 대부분 0인 경우입니다.</p>
</section>
</section>
</section>
<section id="이-장의-요약" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="이-장의-요약"><span class="header-section-number">3.3</span> 1.5 이 장의 요약</h2>
<p>우리는 몇 가지 기본 분포를 사용하여 다양한 이산 <strong>사건(events)</strong>의 확률을 계산하기 위해 수학 공식과 R을 사용했습니다:</p>
<p><strong>베르누이(Bernoulli) 분포</strong>는 우리의 가장 기본적인 구성 요소였습니다 – 이는 동전 던지기와 같은 단일 이진 시행을 나타내는 데 사용됩니다. 우리는 결과를 0과 1로 코딩할 수 있습니다. 우리는 \(p\)를 성공 확률(결과 1)이라고 부릅니다.</p>
<p><strong>이항(binomial) 분포</strong>는 \(n\)번의 이진 시행에서의 1의 개수에 사용되며, R 함수 <code>dbinom</code>을 사용하여 \(k\)번 성공할 확률을 계산할 수 있습니다. 또한 <code>rbinom</code> 함수를 사용하여 \(n\)번 시행하는 이항 실험을 시뮬레이션하는 방법도 보았습니다.</p>
<p><strong>푸아송(Poisson) 분포</strong>는 \(p\)가 작은 경우(1이 드물게 나타나는 경우)에 가장 적합합니다. 여기에는 오직 하나의 매개변수 \(\)만이 있으며, \(=np\)인 푸아송 분포는 \(p\)가 작을 때 \((n, p)\)에 대한 이항 분포와 거의 동일합니다. 우리는 시퀀스를 따라 에피토프를 테스트하는 어세이에서 무작위로 발생하는 위양성(false positives)의 수를 모델링하기 위해 푸아송 분포를 사용했으며, 위치당 위양성률 \(p\)가 작다고 가정했습니다. 우리는 모든 매개변수를 알고 있는 한, 그러한 매개변수 모델이 어떻게 극단적인 사건의 확률을 계산할 수 있게 해주는지 보았습니다.</p>
<p><strong>다항(multinomial) 분포</strong>는 세 가지 이상의 가능한 결과 또는 <strong>수준(levels)</strong>을 가진 이산 사건에 사용됩니다. 검정력 예제는 만약 우리가 다항 모델이 데이터와 일치하는지 테스트하고 싶다면, 얼마나 많은 데이터를 수집해야 할지 결정하기 위해 몬테카를로 시뮬레이션을 어떻게 사용할 수 있는지 보여주었습니다. 우리는 생성 모델에 대한 가정을 세움으로써 우리 데이터가 어떻게 생성되었는지에 대한 가설을 평가하기 위해 확률 분포와 확률 모델을 사용했습니다. 가설이 주어졌을 때 데이터를 볼 확률을 <strong>p-값(p-value)</strong>이라고 부릅니다. 이것은 가설이 참일 확률과는 다릅니다!</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="imgs/devil.png" title="P(H_0 | data)는 p-값 P(data | H_0)와 같지 않습니다."><img src="imgs/devil.png" class="img-fluid figure-img"></a></p>
<figcaption>P(H_0 | data)는 p-값 P(data | H_0)와 같지 않습니다.</figcaption>
</figure>
</div>
<p>\(P(H_0;|;)\)는 p-값 \(P(;|;H_0)\)과 같지 않습니다.</p>
</section>
<section id="더-읽을거리" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="더-읽을거리"><span class="header-section-number">3.4</span> 1.6 더 읽을거리</h2>
<ul>
<li><p>Freedman, Pisani, Purves (<a href="16-chap.html#ref-Freedman:1997">1997</a>)의 입문서는 여기서 언급하는 상자 모델 유형을 통해 확률에 대한 최고의 소개를 제공합니다.</p></li>
<li><p>Durbin 등 (<a href="16-chap.html#ref-DEKM">1998</a>)의 저서는 많은 유용한 확률 분포를 다루고 있으며 부록에서 확률 이론의 이론적 배경과 생물학 서열에 대한 적용에 대한 보다 완전한 견해를 제공합니다.</p></li>
<li><p>몬테카를로 방법은 현대 통계학에서 광범위하게 사용됩니다. Robert와 Casella (<a href="16-chap.html#ref-Casella2009">2009</a>)는 R을 사용한 이러한 방법의 입문서를 제공합니다.</p></li>
<li><p><a href="06-chap.html">6장</a>에서는 가설 검정 주제를 다룰 것입니다. 또한 데이터 분석에서 자주 사용하는 더 발전된 확률 분포인 베타, 감마, 지수 분포 유형에 유용한 심화 자료로 Rice (<a href="16-chap.html#ref-Rice:2007">2006</a>)를 추천합니다.</p></li>
</ul>
</section>
<section id="연습-문제" class="level2" data-number="3.5">
<h2 data-number="3.5" class="anchored" data-anchor-id="연습-문제"><span class="header-section-number">3.5</span> 1.7 연습 문제</h2>
<p>__</p>
<p>연습 문제 1.1</p>
<p>R은 알려진 모든 분포로부터 숫자를 생성할 수 있습니다. 우리는 이제 각 분포 유형에 맞춰진 특수한 R 함수들을 사용하여 임의의 이산 데이터를 생성하는 법을 압니다. 우리는 <code>rpois</code>, <code>rbinom</code>, <code>rmultinom</code>에서와 같이 <code>r</code>로 시작하는 함수들을 사용합니다. 만약 이러한 모델들 중 하나하에서 확률에 대한 이론적 계산이 필요하다면, 이산 이항 분포에서의 사건 확률을 계산하는 <code>dbinom</code>이나 연속 정규 분포에 대한 확률 밀도 함수를 계산하는 <code>dnorm</code>과 같이 <code>d</code>로 시작하는 함수들을 사용합니다. \(P(X&gt;a)\)와 같은 꼬리 확률을 계산할 때는 <code>p</code>로 시작하는 누적 분포 함수를 사용하는 것이 편리합니다. 위의 <code>XXXX</code> 부분을 대체할 수 있는 다른 이산 분포 두 가지를 찾아보세요.</p>
<p>__</p>
<p>연습 문제 1.2</p>
<p>이 장에서 우리는 확률이 셀 수 있는 값들의 세트에 집중되어 있는 <em>이산</em> 확률 변수에 집중했습니다. <code>dbinom</code>을 사용하여 이항 분포 \(B(10, 0.3)\)에 대해 \(X=2\)인 값에서의 <strong>확률 질량(probability mass)</strong>을 어떻게 계산하시겠습니까? <code>dbinom</code>을 사용하여 \(P(X)\)에 해당하는 값 2에서의 <strong>누적(cumulative)</strong> 분포를 계산하고, 다른 R 함수로 답을 확인해 보세요.</p>
<p>__</p>
<p>해결책</p>
<p>__</p>
<pre><code>dbinom(2, size = 10, prob = 0.3)__


[1] 0.2334744


pbinom(2, size = 10, prob = 0.3)__


[1] 0.3827828


sum(dbinom(0:2, size = 10, prob = 0.3)) __


[1] 0.3827828</code></pre>
<p>__</p>
<p>연습 문제 1.3</p>
<p>어떤 명령어 시퀀스가 계속 필요하다는 것을 알게 될 때마다, 이를 함수로 만드는 것이 좋습니다. 함수 본문(body)은 우리가 반복해서 수행하고 싶은 지시사항들을 포함하고, 함수 인수(arguments)는 우리가 변화시키고 싶은 것들을 받습니다. 비율이 <code>lambda</code>인 <code>n</code>개의 푸아송 변수들을 살펴볼 때 최댓값이 <code>m</code>만큼 클 확률을 계산하는 함수를 작성하세요.</p>
<p>__</p>
<p>해결책</p>
<p>__</p>
<pre><code>poismax = function(lambda, n, m) {
  epsilon = 1 - ppois(m - 1, lambda)
  1 - exp( -n * epsilon)
}
poismax(lambda = 0.5, n = 100, m = 7)__


[1] 0.0001002329


poismax(lambda = mean(e100), n = 100, m = 7)__


[1] 0.0001870183</code></pre>
<p>__</p>
<p>연습 문제 1.4</p>
<p>인수에 대한 기본값(즉, 함수 호출 시 인수가 지정되지 않았을 때 사용되는 값)을 갖도록 함수를 다시 작성하세요.</p>
<p>__</p>
<p>해결책</p>
<p>__</p>
<pre><code>poismax = function(lambda, n = 100, m = 7) {
  1 - exp( -n * (1 - ppois(m - 1, lambda)))
}
poismax(0.5)__


[1] 0.0001002329


poismax(0.5, m = 9)__


[1] 3.43549e-07</code></pre>
<p>__</p>
<p>연습 문제 1.5</p>
<p>에피토프 예제에서, 시뮬레이션을 사용하여 100번의 시행 중 최댓값이 9 이상일 확률을 찾으세요. “확률이 0.000001보다 작다”는 것을 증명하려면 몇 번의 시뮬레이션이 필요할까요?</p>
<p>__</p>
<p>연습 문제 1.6</p>
<p>R에서 <code>?Distributions</code>를 사용하여 가용한 분포 리스트를 확인해 보세요17. 다양한 분포에 대한 확률 질량 또는 밀도 함수 플롯을 만들고(<code>dXXXX</code> 함수 사용), 이산형이 아닌 분포 다섯 가지를 나열하세요.</p>
<p>17 이들은 단지 기본 R 설치 시 함께 제공되는 것들입니다. 추가 패키지들에는 더 많이 있으며, <a href="https://cran.r-project.org/web/views/Distributions.html">CRAN 태스크 뷰: 확률 분포</a>를 참조하세요.</p>
<p>__</p>
<p>연습 문제 1.7</p>
<p>Poisson(3) 확률 변수의 인스턴스 100개를 생성하세요. 평균은 얼마인가요? R 함수 <code>var</code>로 계산된 분산은 얼마인가요?</p>
<p>__</p>
<p>연습 문제 1.8</p>
<p><strong><em>C. elegans</em> 유전체 뉴클레오타이드 빈도:</strong> _C. elegans_의 미토콘드리아 서열이 뉴클레오타이드가 동일한 확률을 갖는다는 모델과 일치하나요?</p>
<ol type="1">
<li><p>바이오컨덕터의 <strong><a href="https://bioconductor.org/packages/Biostrings/">Biostrings</a></strong> 패키지에 있는 전 전용 함수를 사용하여 염색체 M의 뉴클레오타이드 빈도를 탐색하세요.</p></li>
<li><p>시뮬레이션을 사용하여 <em>C. elegans</em> 데이터가 균등 모델(모든 뉴클레오타이드 빈도가 동일함)과 일치하는지 테스트하세요. 힌트: 이번이 바이오컨덕터를 처음으로 사용해 볼 기회입니다. 바이오컨덕터의 패키지 관리는 CRAN보다 더 엄격하게 통제되므로, 바이오컨덕터 패키지를 설치하려면 (<strong><a href="https://cran.r-project.org/web/packages/BiocManager/">BiocManager</a></strong> 패키지의) 특별한 <code>install</code> 함수를 사용해야 합니다.</p></li>
</ol>
<pre><code>if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install(c("Biostrings", "BSgenome.Celegans.UCSC.ce2"))__</code></pre>
<p>그 후에, 다른 R 패키지들을 로드하는 것과 같이 유전체 서열 패키지를 로드할 수 있습니다.</p>
<p>__</p>
<p>해결책</p>
<p>__</p>
<pre><code>library("BSgenome.Celegans.UCSC.ce2")
Celegans __


| BSgenome object for Worm
| - organism: Caenorhabditis elegans
| - provider: UCSC
| - genome: ce2
| - release date: Mar. 2004
| - 7 sequence(s):
|     chrI   chrII  chrIII chrIV  chrV   chrX   chrM                       
| 
| Tips: call 'seqnames()' on the object to get all the sequence names, call
| 'seqinfo()' to get the full sequence info, use the '$' or '[[' operator to
| access a given sequence, see '?BSgenome' for more information.


seqnames(Celegans)__


[1] "chrI"   "chrII"  "chrIII" "chrIV"  "chrV"   "chrX"   "chrM"  


Celegans$chrM __


13794-letter DNAString object
seq: CAGTAAATAGTTTAATAAAAATATAGCATTTGGGTT...TATTTATAGATATATACTTTGTATATATCTATATTA


class(Celegans$chrM)__


[1] "DNAString"
attr(,"package")
[1] "Biostrings"


length(Celegans$chrM)__


[1] 13794


library("Biostrings")
lfM = letterFrequency(Celegans$chrM, letters=c("A", "C", "G", "T"))
lfM __


   A    C    G    T 
4335 1225 2055 6179 


sum(lfM)__


[1] 13794


lfM / sum(lfM)__


         A          C          G          T 
0.31426707 0.08880673 0.14897782 0.44794838 </code></pre>
<p><em>C. elegans</em> 염색체 M과 동일한 길이를 가진 무작위(각 글자가 동일한 확률을 가짐) 서열을 생성합니다:</p>
<pre><code>t(rmultinom(1, length(Celegans$chrM), p = rep(1/4, 4)))__


     [,1] [,2] [,3] [,4]
[1,] 3409 3486 3476 3423</code></pre>
<p>기대 빈도는 단지 다음과 같습니다.</p>
<pre><code>length(Celegans$chrM) / 4 __


[1] 3448.5</code></pre>
<p>우리는 두 다항 출력 결과가 서로 얼마나 가까운지 측정하는 통계량을 계산할 것입니다. 관측된(<code>o</code>) 카운트와 기대되는(<code>e</code>) 카운트 사이의 차이의 제곱의 평균을 구하고 이를 <code>e</code>로 스케일링하겠습니다. 이 함수를 <code>oestat</code>이라고 부르겠습니다.</p>
<pre><code>oestat = function(o, e) {
  sum((o-e)^2 / e)
}
oe = oestat(o = lfM, e = length(Celegans$chrM) / 4)
oe __


[1] 4386.634</code></pre>
<p>이것이 무작위성으로 설명될 수 있는 것보다 더 큰가요? 우리는 이미 위에서 귀무 모델하에서 기대할 수 있는 일련의 전형적인 카운트들을 보았습니다. 하지만 우리에게는 값들의 전체 세트(분포)가 필요합니다. 함수를 여러 번 평가해 주는 <code>replicate</code> 함수를 사용하여 이들을 계산합니다. 우리는 다음을 실행합니다:</p>
<pre><code>B = 10000
n = length(Celegans$chrM)
expected = rep(n / 4, 4)
oenull = replicate(B,
  oestat(e = expected, o = rmultinom(1, n, p = rep(1/4, 4))))__</code></pre>
<p>Durbin, Richard, Sean Eddy, Anders Krogh, and Graeme Mitchison. 1998. <em>Biological Sequence Analysis</em>. Cambridge University Press.</p>
<p>Freedman, David, Robert Pisani, and Roger Purves. 1997. <em>Statistics</em>. New York, NY: WW Norton.</p>
<p>Rice, John. 2006. <em>Mathematical Statistics and Data Analysis</em>. Cengage Learning.</p>
<p>Robert, Christian, and George Casella. 2009. <em>Introducing Monte Carlo Methods with R</em>. Springer Science &amp; Business Media.</p>
<p>페이지는 R 버전 4.5.1 (2025-06-13)을 사용하여 2025-09-01 01:33에 빌드되었습니다.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./00-chap.html" class="pagination-link" aria-label="이 책에는 무엇이 들어있나요?">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">이 책에는 무엇이 들어있나요?</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./02-chap.html" class="pagination-link" aria-label="매개변수가 핵심입니다.">
        <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">매개변수가 핵심입니다.</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>