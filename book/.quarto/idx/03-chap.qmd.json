{"title":"3.1 Goals for this chapter","markdown":{"headingText":"3.1 Goals for this chapter","containsRefs":false,"markdown":"![](imgs/xkcd-plotting.png)\n\nThere are (at least) two types of data visualization. The first enables a\nscientist to explore data and make discoveries about the complex processes at\nwork. The other type of visualization provides informative, clear and visually\nattractive illustrations of her results that she can show to others and\neventually include in a publication.\n\nBoth of these types of visualizations can be made with R. In fact, R offers\nmultiple graphics systems. This is because R is extensible, and because\nprogress in R graphics over the years has proceeded largely not by replacing\nthe old functions, but by adding packages. Each of the different graphics\nsystems has its advantages and limitations. In this chapter we will get to\nknow two of them. First, we have a cursory look at the base R plotting\nfunctions1. Subsequently we will switch to\n**[ggplot2](https://cran.r-project.org/web/packages/ggplot2/)**.\n\n1 They live in the\n**[graphics](https://cran.r-project.org/web/packages/graphics/)** package,\nwhich ships with every basic R installation.\n\n[![](imgs/Automatisches_Zeichengeraet_ZUSE_Z64_ubt_web.jpg)](imgs/Automatisches_Zeichengeraet_ZUSE_Z64_ubt_web.jpg\n\"FigureÂ 3.1: The ZUSE Plotter Z64 \\(presented in 1961\\). Source:\nhttps://en.wikipedia.org/wiki/Plotter.\")\n\nFigure 3.1: The ZUSE Plotter Z64 (presented in 1961). Source:\n<https://en.wikipedia.org/wiki/Plotter>.\n\nBase R graphics came historically first: simple, procedural, conceptually\nmotivated by drawing on a canvas. There are specialized functions for\ndifferent types of plots. These are easy to call â€“ but when you want to\ncombine them to build up more complex plots, or exchange one for another, this\nquickly gets messy, or even impossible. The user plots (the word harks back to\nsome of the first graphics devices â€“ see Figure 3.1) directly onto a\n(conceptual) canvas. She explicitly needs to deal with decisions such as how\nmuch space to allocate to margins, axes labels, titles, legends, subpanels;\nonce something is â€œplottedâ€ it cannot be moved or erased.\n\nThere is a more high-level approach: in the _grammar of graphics_ , graphics\nare built up from modular logical pieces, so that we can easily try different\nvisualization types for our data in an intuitive and easily deciphered way,\nlike we can switch in and out parts of a sentence in human language. There is\nno concept of a canvas or a plotter, rather, the user gives\n**[ggplot2](https://cran.r-project.org/web/packages/ggplot2/)** a high-level\ndescription of the plot she wants, in the form of an R object, and the\nrendering engine takes a wholistic view on the scene to lay out the graphics\nand render them on the output device.\n\n\nIn this chapter, we will:\n\n  * Learn how to rapidly and flexibly explore datasets by visualization.\n\n  * Create beautiful and intuitive plots for scientific presentations and publications.\n\n  * Review the basics of base R plotting.\n\n  * Understand the logic behind the _grammar of graphics_ concept.\n\n  * Introduce **[ggplot2](https://cran.r-project.org/web/packages/ggplot2/)** â€™s `ggplot` function.\n\n  * See how to plot data in one, two, or even three to five dimensions, and explore faceting.\n\n  * Create â€œalong-genomeâ€ plots for molecular biology data (or along other sequences, e.g., peptides).\n\n  * Discuss some of our options of interactive graphics.\n\n## 3.2 Base R plotting\n\nThe most basic function is `plot`. In the code below, the output of which is\nshown in Figure 3.2, it is used to plot data from an enzyme-linked\nimmunosorbent assay (ELISA) assay. The assay was used to quantify the activity\nof the enzyme deoxyribonuclease (DNase), which degrades DNA. The data are\nassembled in the R object `DNase`, which conveniently comes with base R. The\nobject `DNase` is a dataframe whose columns are `Run`, the assay run; `conc`,\nthe protein concentration that was used; and `density`, the measured optical\ndensity.\n\n    \n    \n    head(DNase)__\n    \n    \n      Run       conc density\n    1   1 0.04882812   0.017\n    2   1 0.04882812   0.018\n    3   1 0.19531250   0.121\n    4   1 0.19531250   0.124\n    5   1 0.39062500   0.206\n    6   1 0.39062500   0.215\n    \n    \n    plot(DNase$conc, DNase$density)__\n\n[![](03-chap_files/figure-html/fig-graphics-\nbasicplotting1-1.png)](03-chap_files/figure-html/fig-graphics-\nbasicplotting1-1.png \"FigureÂ 3.2: Plot of concentration vs.Â density for an\nELISA assay of DNase.\")\n\nFigure 3.2: Plot of concentration vs. density for an ELISA assay of DNase.\n\nThis basic plot can be customized, for example by changing the plot symbol and\naxis labels using the parameters `xlab`, `ylab` and `pch` (plot character), as\nshown in Figure 3.3. Information about the variables is stored in the object\n`DNase`, and we can access it with the `attr` function.\n\n    \n    \n    plot(DNase$conc, DNase$density,\n      ylab = attr(DNase, \"labels\")$y,\n      xlab = paste(attr(DNase, \"labels\")$x, attr(DNase, \"units\")$x),\n      pch = 3,\n      col = \"blue\")__\n\n[![](03-chap_files/figure-html/fig-graphics-\nbasicplotting2-1.png)](03-chap_files/figure-html/fig-graphics-\nbasicplotting2-1.png \"FigureÂ 3.3: Same data as in FigureÂ fig-graphics-\nbasicplotting1 but with better axis labels and a different plot symbol.\")\n\nFigure 3.3: Same data as in Figure 3.2 but with better axis labels and a\ndifferent plot symbol.\n\n__\n\nQuestion 3.1\n\nAnnotating dataframe columns with â€œmetadataâ€ such as longer descriptions,\nphysical units, provenance information, etc., seems like a useful feature. Is\nthis way of storing such information, as in the `DNase` object, standardized\nor common across the R ecosystem? Are there other standardized or common ways\nfor doing this?\n\n__\n\nSolution\n\n__\n\nThere is no good or widely used infrastructure in regular R _data.frame_ s for\nthis, nor in the tidyverse (_data_frame_ , _tibble_). But have a look at the\n_DataFrame_ class in the Bioconductor package\n**[S4Vectors](https://bioconductor.org/packages/S4Vectors/)**. Among other\nthings it is used to annotate the rows and columns of a\n_SummarizedExperiment_.\n\nBesides scatterplots, we can also use built-in functions to create histograms\nand boxplots (Figure 3.4).\n\n    \n    \n    hist(DNase$density, breaks=25, main = \"\")\n    boxplot(density ~ Run, data = DNase)__\n\n[![](03-chap_files/figure-html/fig-graphics-\nbasicplotting3-1.png)](03-chap_files/figure-html/fig-graphics-\nbasicplotting3-1.png \"FigureÂ 3.4Â \\(a\\): \")\n\n(a)\n\n[![](03-chap_files/figure-html/fig-graphics-\nbasicplotting3-2.png)](03-chap_files/figure-html/fig-graphics-\nbasicplotting3-2.png \"FigureÂ 3.4Â \\(b\\): \")\n\n(b)\n\nFigure 3.4: (a) Histogram of the density from the ELISA assay, and (b)\nboxplots of these values stratified by the assay run. The boxes are ordered\nalong the axis in lexicographical order because the runs were stored as text\nstrings. We could use Râ€™s type conversion functions to achieve numerical\nordering.\n\nBoxplots are convenient for showing multiple distributions next to each other\nin a compact space. We will see more about plotting multiple univariate\ndistributions in Section 3.6.\n\nThe base R plotting functions are great for quick interactive exploration of\ndata; but we run soon into their limitations if we want to create more\nsophisticated displays. We are going to use a visualization framework called\nthe grammar of graphics, implemented in the package\n**[ggplot2](https://cran.r-project.org/web/packages/ggplot2/)** , that enables\nstep by step construction of high quality graphics in a logical and elegant\nmanner. First let us introduce and load an example dataset.\n\n## 3.3 An example dataset\n\n[![](imgs/Yusukecells-2_web.jpg)](imgs/Yusukecells-2_web.jpg \"FigureÂ 3.5:\nSingle-section immunofluorescence image of the E3.5 mouse blastocyst stained\nfor Serpinh1, a marker of primitive endoderm \\(blue\\), Gata6 \\(red\\) and Nanog\n\\(green\\).\")\n\nFigure 3.5: Single-section immunofluorescence image of the E3.5 mouse\nblastocyst stained for Serpinh1, a marker of primitive endoderm (blue), Gata6\n(red) and Nanog (green).\n\nTo properly testdrive the\n**[ggplot2](https://cran.r-project.org/web/packages/ggplot2/)** functionality,\nwe are going to need a dataset that is big enough and has some complexity so\nthat it can be sliced and viewed from many different angles. Weâ€™ll use a gene\nexpression microarray dataset that reports the transcriptomes of around 100\nindividual cells from mouse embryos at different time points in early\ndevelopment. The mammalian embryo starts out as a single cell, the fertilized\negg. Through synchronized waves of cell divisions, the egg multiplies into a\nclump of cells that at first show no discernible differences between them. At\nsome point, though, cells choose different lineages. By further and further\nspecification, the different cell types and tissues arise that are needed for\na full organism. The aim of the experiment, explained by Ohnishi et al.\n([2014](16-chap.html#ref-Ohnishi2014)), was to investigate the gene expression\nchanges associated with the first symmetry breaking event in the embryo. Weâ€™ll\nfurther explain the data as we go. More details can be found in the paper and\nin the documentation of the Bioconductor data package\n**[Hiiragi2013](https://bioconductor.org/packages/Hiiragi2013/)**. We first\nload the data:\n\n![](imgs/devil.png)\n\nIt is unfortunate that the data object has the rather generic name `x`, rather\nthan a more descriptive name. To avoid name collisions, perhaps the most\npragmatic solution would be to run code such as following: `esHiiragi = x;\nrm(list=\"x\")`.\n\n    \n    \n    library(\"Hiiragi2013\")__\n    \n    \n    In chunk 'loadHiiragi': Warning: replacing previous import 'boot::logit' by 'gtools::logit' whenloading 'Hiiragi2013'\n    \n    \n    In chunk 'loadHiiragi': Warning: replacing previous import 'boot::inv.logit' by 'gtools::inv.logit'when loading 'Hiiragi2013'\n    \n    \n    data(\"x\")\n    dim(Biobase::exprs(x))__\n    \n    \n    [1] 45101   101\n\nYou can print out a more detailed summary of the _ExpressionSet_ object `x` by\njust typing `x` at the R prompt. The 101 columns of the data matrix (accessed\nabove through the `exprs` function from the\n**[Biobase](https://bioconductor.org/packages/Biobase/)** package) correspond\nto the samples (each of these is a single cell), the 45101 rows correspond to\nthe genes probed by the array, an Affymetrix mouse4302 array. The data were\nnormalized using the RMA method ([Irizarry et al. 2003](16-chap.html#ref-\nIrizarry:Biostat:2003)). The raw data are also available in the package (in\nthe data object `a`) and at EMBL-EBIâ€™s ArrayExpress database under the\naccession code E-MTAB-1681.\n\nLetâ€™s have a look at what information is available about the samples2.\n\n2 The notation #CAB2D6 is a hexadecimal representation of the RGB coordinates\nof a color; more on this in Section 3.10.2.\n\n    \n    \n    head(pData(x), n = 2)__\n    \n    \n            File.name Embryonic.day Total.number.of.cells lineage genotype\n    1 E3.25  1_C32_IN         E3.25                    32               WT\n    2 E3.25  2_C32_IN         E3.25                    32               WT\n              ScanDate sampleGroup sampleColour\n    1 E3.25 2011-03-16       E3.25      #CAB2D6\n    2 E3.25 2011-03-16       E3.25      #CAB2D6\n\nThe information provided is a mix of information about the cells (i.e., age,\nsize and genotype of the embryo from which they were obtained) and technical\ninformation (scan date, raw data file name). By convention, time in the\ndevelopment of the mouse embryo is measured in days, and reported as, for\ninstance, `E3.5`. Moreover, in the paper the authors divided the cells into 8\nbiological groups (`sampleGroup`), based on age, genotype and lineage, and\nthey defined a color scheme to represent these groups (`sampleColour`3). Using\nthe following code (see below for explanations), we define a small dataframe\n`groups` that contains summary information for each group: the number of cells\nand the preferred color.\n\n3 This identifier in the dataset uses the British spelling. Everywhere else in\nthis book, we use the US spelling (color). The\n**[ggplot2](https://cran.r-project.org/web/packages/ggplot2/)** package\ngenerally accepts both spellings.\n\n    \n    \n    library(\"dplyr\")\n    groups = group_by(pData(x), sampleGroup) |>\n      summarise(n = n(), color = unique(sampleColour))\n    groups __\n    \n    \n    # A tibble: 8 Ã— 3\n      sampleGroup         n color  \n      <chr>           <int> <chr>  \n    1 E3.25              36 #CAB2D6\n    2 E3.25 (FGF4-KO)    17 #FDBF6F\n    3 E3.5 (EPI)         11 #A6CEE3\n    4 E3.5 (FGF4-KO)      8 #FF7F00\n    5 E3.5 (PE)          11 #B2DF8A\n    6 E4.5 (EPI)          4 #1F78B4\n    7 E4.5 (FGF4-KO)     10 #E31A1C\n    8 E4.5 (PE)           4 #33A02C\n\nThe cells in the groups whose name contains `FGF4-KO` are from embryos in\nwhich the FGF4 gene, an important regulator of cell differentiation, was\nknocked out. Starting from E3.5, the wildtype cells (without the FGF4 knock-\nout) undergo the first symmetry breaking event and differentiate into\ndifferent cell lineages, called pluripotent epiblast (EPI) and primitive\nendoderm (PE).\n\nSince the code chunk above is the first instance that we encounter the pipe\noperator `|>` and the functions `group_by` and `summarise` from the\n**[dplyr](https://cran.r-project.org/web/packages/dplyr/)** package, letâ€™s\nunpack the code. First, the pipe `|>`4. Generally, the pipe is useful for\nmaking nested function calls easier to read for humans. The following two\nlines of code are equivalent to R.\n\n4 `|>` is the pipe operator that has been coming with base R since version\n4.1, released in 2021. The package\n**[magrittr](https://cran.r-project.org/web/packages/magrittr/)** has provided\nthe `%>%` operator, which has similar although not identical semantics,\nalready since a long time before, as well as several other piping related\noperators, such as `%<>%` and `%T>%`. As much of the book was written before\n2021, **[magrittr](https://cran.r-project.org/web/packages/magrittr/)** â€™s\n`%>%` operator is used in many places. We are occasionally updating from `%>%`\nto `|>` during book maintenance, as in the code shown here.\n\n    \n    \n    f(x) |> g(y) |> h()\n    h(g(f(x), y))__\n\nIt says: â€œEvaluate `f(x)`, then pass the result to function `g` as the first\nargument, while `y` is passed to `g` as the second argument. Then pass the\noutput of `g` to the function `h`.â€ You could repeat this ad infinitum.\nEspecially if the arguments `x` and `y` are complex expressions themselves, or\nif there is quite a chain of functions involved, the first version tends to be\neasier to read.\n\nThe `group_by` function simply â€œmarksâ€ the dataframe with a note that all\nsubsequent operations should not be applied to the whole dataframe at once,\nbut to blocks defined by the `sampleGroup` factor. Finally, `summarise`\ncomputes summary statistics; this could be, e.g., the `mean`, `sum`; in this\ncase, we just compute the number of rows in each block, `n()`, and the\nprevalent color.\n\n## 3.4 ggplot2\n\n**[ggplot2](https://cran.r-project.org/web/packages/ggplot2/)** is a package\nby Hadley Wickham ([Wickham 2016](16-chap.html#ref-ggplot2)) that implements\nthe idea of **grammar of graphics** â€“ a concept created by Leland Wilkinson in\nhis eponymous book ([Wilkinson 2005](16-chap.html#ref-GrofGrbook)). We will\nexplore some of its functionality in this chapter, and you will see many\nexamples of how it can be used in the rest of this book. Comprehensive\ndocumentation for the package can be found [on its\nwebsite](https://ggplot2.tidyverse.org). The online documentation includes\nexample use cases for each of the graphic types that are introduced in this\nchapter (and many more) and is an invaluable resource when creating figures.\n\nLetâ€™s start by loading the package and redoing the simple plot of Figure 3.2.\n\n    \n    \n    library(\"ggplot2\")\n    ggplot(DNase, aes(x = conc, y = density)) + geom_point()__\n\n[![](03-chap_files/figure-html/fig-graphics-\nfigredobasicplottingwithggplot-1.png)](03-chap_files/figure-html/fig-graphics-\nfigredobasicplottingwithggplot-1.png \"FigureÂ 3.6: Our first ggplot2 figure,\nsimilar to the base graphics FigureÂ fig-graphics-basicplotting1.\")\n\nFigure 3.6: Our first\n**[ggplot2](https://cran.r-project.org/web/packages/ggplot2/)** figure,\nsimilar to the base graphics Figure 3.2.\n\nWe just wrote our first â€œsentenceâ€ using the grammar of graphics. Letâ€™s\ndeconstruct this sentence. First, we specified the dataframe that contains the\ndata, `DNase`. The `aes` (this stands for **aesthetic**) argument states which\nvariables we want to see mapped to the \\\\(x\\\\)\\- and \\\\(y\\\\)-axes,\nrespectively. Finally, we stated that we want the plot to use points (as\nopposed to, say, lines or bars), by adding the result of calling the function\n`geom_point`.\n\nNow letâ€™s turn to the mouse single cell data and plot the number of samples\nfor each of the 8 groups using the `ggplot` function. The result is shown in\nFigure 3.7.\n\n    \n    \n    ggplot(groups, aes(x = sampleGroup, y = n)) +\n      geom_bar(stat = \"identity\")__\n\n[![](03-chap_files/figure-html/fig-graphics-\nqplot1-1.png)](03-chap_files/figure-html/fig-graphics-qplot1-1.png\n\"FigureÂ 3.7: A barplot, produced with the ggplot function from the table of\ngroup sizes in the mouse single cell data.\")\n\nFigure 3.7: A barplot, produced with the `ggplot` function from the table of\ngroup sizes in the mouse single cell data.\n\nWith `geom_bar` we now told `ggplot` that we want each data item (each row of\n`groups`) to be represented by a bar. Bars are one example of geometric object\n(**geom** in the\n**[ggplot2](https://cran.r-project.org/web/packages/ggplot2/)** packageâ€™s\nparlance) that `ggplot` knows about. We have already seen another such object\nin Figure 3.6: points, indicated by the `geom_point` function. We will\nencounter many other geoms later. We used the `aes` to indicate that we want\nthe groups shown along the \\\\(x\\\\)-axis and the sizes along the \\\\(y\\\\)-axis.\nFinally, we provided the argument `stat = \"identity\"` (in other words, do\nnothing) to the `geom_bar` function, since otherwise it would try to compute a\nhistogram of the data (the default value of `stat` is `\"count\"`). `stat` is\nshort for _statistic_ , which is what we call any function of data. Besides\nthe identity and count statistic, there are others, such as smoothing,\naveraging, binning, or other operations that reduce the data in some way.\n\nThese concepts â€“data, geometrical objects, statisticsâ€“ are some of the\ningredients of the grammar of graphics, just as nouns, verbs and adverbs are\ningredients of an English sentence.\n\n__\n\nTask\n\nFlip the \\\\(x\\\\)\\- and \\\\(y\\\\)-aesthetics to produce a horizontal barplot.\n\nThe plot in Figure 3.7 is not bad, but there are several potential\nimprovements. We can use color for the bars to help us quickly see which bar\ncorresponds to which group. This is particularly useful if we use the same\ncolor scheme in several plots. To this end, letâ€™s define a named vector\n`groupColor` that contains our desired colors for each possible value of\n`sampleGroup`.5\n\n5 The information is completely equivalent to that in the `sampleGroup` and\n`color` columns of the dataframe `groups`; we are just adapting to the fact\nthat **[ggplot2](https://cran.r-project.org/web/packages/ggplot2/)** expects\nthis information in the form of a named vector.\n\n    \n    \n    groupColor = setNames(groups$color, groups$sampleGroup)__\n\nAnother thing that we need to fix in Figure 3.7 is the readability of the bar\nlabels. Right now they are running into each other â€” a common problem when you\nhave descriptive names.\n\n    \n    \n    ggplot(groups, aes(x = sampleGroup, y = n, fill = sampleGroup)) +\n      geom_bar(stat = \"identity\") +\n      scale_fill_manual(values = groupColor, name = \"Groups\") +\n      theme(axis.text.x = element_text(angle = 90, hjust = 1))__\n\n[![](03-chap_files/figure-html/fig-graphics-\nqplot2-1.png)](03-chap_files/figure-html/fig-graphics-qplot2-1.png\n\"FigureÂ 3.8: Similar to FigureÂ fig-graphics-qplot1, but with colored bars and\nbetter bar labels.\")\n\nFigure 3.8: Similar to Figure 3.7, but with colored bars and better bar\nlabels.\n\nThis is now already a longer and more complex sentence. Letâ€™s dissect it. We\nadded an argument, `fill` to the `aes` function that states that we want the\nbars to be colored (filled) based on `sampleGroup` (which in this case co-\nincidentally is also the value of the `x` argument, but that need not always\nbe so). Furthermore we added a call to the `scale_fill_manual` function, which\ntakes as its input a color map â€“ i.e., the mapping from the possible values of\na variable to the associated colors â€“ as a named vector. We also gave this\ncolor map a title (note that in more complex plots, there can be several\ndifferent color maps involved). Had we omitted the call to\n`scale_fill_manual`,\n**[ggplot2](https://cran.r-project.org/web/packages/ggplot2/)** would have\nused its choice of default colors. We also added a call to `theme` stating\nthat we want the \\\\(x\\\\)-axis labels rotated by 90 degrees and right-aligned\n(`hjust`; the default would be to center).\n\n### 3.4.1 Data flow\n\n![](imgs/devil.png)\n\nThe function `ggplot` expects your data in a dataframe. If they are in a\nmatrix, in separate vectors, or other types of objects, you will have to\nconvert them. The packages\n**[dplyr](https://cran.r-project.org/web/packages/dplyr/)** and\n**[broom](https://cran.r-project.org/web/packages/broom/)** , among others,\noffer facilities to this end. We will discuss this more in [Section\n13.10](13-chap.html#sec-design-datarep), and you will see examples of such\nconversions throughout the book.\n\nThis includes the base R _data.frame_ as well as the _tibble_ (and synonymous\n_data_frame_) classes from the\n**[tibble](https://cran.r-project.org/web/packages/tibble/)** package in the\ntidyverse.\n\nThe result of a call to the `ggplot` is a _ggplot_ object. Letâ€™s recall a\npiece of code from above:\n\n    \n    \n    gg = ggplot(DNase, aes(x = conc, y = density)) + geom_point()__\n\nWe have now assigned the output of `ggplot` to the object `gg`, instead of\nsending it directly to the console, where it was â€œprintedâ€ and produced Figure\n3.6. The situation is completely analogous to what youâ€™re used to from working\nwith the R console: when you enter an expression such as `1+1` and hit\nâ€œEnterâ€, the result is printed. When the expression is an assignment, such as\n`s = 1+1`, the side effect takes place (the name `\"s\"` is bound to an object\nin memory that represents the value of `1+1`), but nothing is printed.\nSimilarly, when an expression is evaluated as part of a script called with\n`source`, it is not printed. Thus, the above code also does not create any\ngraphic output, since no `print` method is invoked. To print `gg`, type its\nname (in an interactive session) or call `print` on it:\n\n    \n    \n    gg\n    print(gg)__\n\n### 3.4.2 Saving figures\n\n**[ggplot2](https://cran.r-project.org/web/packages/ggplot2/)** has a built-in\nplot saving function called `ggsave`:\n\n    \n    \n    ggplot2::ggsave(\"DNAse-histogram-demo.pdf\", plot = gg)__\n\nThere are two major ways of storing plots: vector graphics and raster (pixel)\ngraphics. In vector graphics, the plot is stored as a series of geometrical\nprimitives such as points, lines, curves, shapes and typographic characters.\nThe preferred format in R for saving plots into a vector graphics format is\nPDF. In raster graphics, the plot is stored in a dot matrix data structure.\nThe main limitation of raster formats is their limited resolution, which\ndepends on the number of pixels available. In R, the most commonly used device\nfor raster graphics output is `png`. Generally, itâ€™s preferable to save your\nplots in a vector graphics format, since it is always possible later to\nconvert a vector graphics file into a raster format of any desired resolution,\nwhile the reverse is quite difficult. And you donâ€™t want the figures in your\ntalks or papers look poor because of pixelization artefacts!\n\n## 3.5 The grammar of graphics\n\nThe components of\n**[ggplot2](https://cran.r-project.org/web/packages/ggplot2/)** â€™s grammar of\ngraphics are\n\n  1. one or more datasets,\n\n  2. one or more geometric objects that serve as the visual representations of the data, â€“ for instance, points, lines, rectangles, contours,\n\n  3. descriptions of how the variables in the data are mapped to visual properties (aesthetics) of the geometric objects, and an associated scale (e. g., linear, logarithmic, rank),\n\n  4. one or more coordinate systems,\n\n  5. statistical summarization rules,\n\n  6. a facet specification, i.e. the use of multiple similar subplots to look at subsets of the same data,\n\n  7. optional parameters that affect the layout and rendering, such text size, font and alignment, legend positions.\n\nIn the examples above, Figures 3.7 and 3.8, the dataset was `groupsize`, the\nvariables were the numeric values as well as the names of `groupsize`, which\nwe mapped to the aesthetics \\\\(y\\\\)-axis and \\\\(x\\\\)-axis respectively, the\nscale was linear on the \\\\(y\\\\) and rank-based on the \\\\(x\\\\)-axis (the bars\nare ordered alphanumerically and each has the same width), and the geometric\nobject was the rectangular bar.\n\nItems 4â€“7 in the above list are optional. If you donâ€™t specify them, then the\nCartesian is used as the coordinate system, the statistical summary is the\ntrivial one (i.e., the identity), and no facets or subplots are made (weâ€™ll\nsee examples later on, in Section 3.8). The first three items are required: a\nvalid **[ggplot2](https://cran.r-project.org/web/packages/ggplot2/)**\nâ€œsentenceâ€ needs to contain at least one of each of them.\n\nIn fact, **[ggplot2](https://cran.r-project.org/web/packages/ggplot2/)** â€™s\nimplementation of the grammar of graphics allows you to use the same type of\ncomponent multiple times, in what are called **layers** ([Wickham\n2010](16-chap.html#ref-Wickham:LayeredGrammar)). For example, the code below\nuses three types of geometric objects in the same plot, for the same data:\npoints, a line and a confidence band.\n\n    \n    \n    dftx = data.frame(t(Biobase::exprs(x)), pData(x))\n    ggplot( dftx, aes( x = X1426642_at, y = X1418765_at )) +\n      geom_point( shape = 1 ) +\n      geom_smooth( method = \"loess\" )__\n\n[![](03-chap_files/figure-html/fig-graphics-\nscp2layers1-1.png)](03-chap_files/figure-html/fig-graphics-scp2layers1-1.png\n\"FigureÂ 3.9: A scatterplot with three layers that show different statistics of\nthe same data: points \\(geom_point\\), a smooth regression line and a\nconfidence band \\(the latter two from geom_smooth\\).\")\n\nFigure 3.9: A scatterplot with three layers that show different statistics of\nthe same data: points (`geom_point`), a smooth regression line and a\nconfidence band (the latter two from `geom_smooth`).\n\nHere we had to assemble a copy of the expression data (`Biobase::exprs(x)`)\nand the sample annotation data (`pData(x)`) all together into the dataframe\n`dftx` â€“ since this is the data format that\n**[ggplot2](https://cran.r-project.org/web/packages/ggplot2/)** functions most\neasily take as input (more on this in [Section 13.10](13-chap.html#sec-design-\ndatarep)).\n\nWe can further enhance the plot by using colors â€“ since each of the points in\nFigure 3.9 corresponds to one sample, it makes sense to use the `sampleColour`\ninformation in the object `x`.\n\n    \n    \n    ggplot(dftx, aes(x = X1426642_at, y = X1418765_at))  +\n      geom_point(aes(color = sampleGroup), shape = 19) +\n      scale_color_manual(values = groupColor, guide = \"none\") +\n      geom_smooth(method = \"loess\")__\n\n[![](03-chap_files/figure-html/fig-graphics-\nscp2layers2-1.png)](03-chap_files/figure-html/fig-graphics-scp2layers2-1.png\n\"FigureÂ 3.10: As FigureÂ fig-graphics-scp2layers1, but in addition with points\ncolored by the time point and cell lineage \\(as defined in FigureÂ fig-\ngraphics-qplot2\\). We can now see that the expression values of the gene Timd2\n\\(targeted by the probe 1418765_at, along the y-axis\\) are consistently high\nin the early time points, whereas its expression goes down in the EPI samples\nat days 3.5 and 4.5. In the FGF4-KO, this decrease is delayed - at E3.5, its\nexpression is still high. Conversely, the gene Fn1 \\(1426642_at, x-axis\\) is\noff in the early timepoints and then goes up at days 3.5 and 4.5. The PE\nsamples \\(green\\) show a high degree of cell-to-cell variability.\")\n\nFigure 3.10: As Figure 3.9, but in addition with points colored by the time\npoint and cell lineage (as defined in Figure 3.8). We can now see that the\nexpression values of the gene Timd2 (targeted by the probe 1418765_at, along\nthe y-axis) are consistently high in the early time points, whereas its\nexpression goes down in the EPI samples at days 3.5 and 4.5. In the FGF4-KO,\nthis decrease is delayed - at E3.5, its expression is still high. Conversely,\nthe gene Fn1 (1426642_at, x-axis) is off in the early timepoints and then goes\nup at days 3.5 and 4.5. The PE samples (green) show a high degree of cell-to-\ncell variability.\n\n__\n\nQuestion 3.2\n\nIn the code above we defined the `color` aesthetics (`aes`) only for the\n`geom_point` layer, while we defined the `x` and `y` aesthetics for all\nlayers. What happens if we set the `color` aesthetics for all layers, i.e.,\nmove it into the argument list of `ggplot`?\n\n__\n\nQuestion 3.3\n\nIs it always meaningful to visualize scatterplot data together with a\nregression line as in Figures 3.9 and 3.10?\n\nAs an aside, if we want to find out which genes are targeted by these probe\nidentifiers, and what they might do, we can call:\n\n![](imgs/devil.png)\n\nNote that here were need to use the original feature identifiers (e.,g.,\nâ€œ1426642_atâ€, without the leading â€œXâ€). This is the notation used by the\nmicroarray manufacturer, by the Bioconductor annotation packages, and also\ninside the object `x`. The leading â€œXâ€ that we used above when working with\n`dftx` was inserted during the creation of `dftx` by the constructor function\n`data.frame`, since its argument `check.names` is set to `TRUE` by default.\nAlternatively, we could have kept the original identifier notation by setting\n`check.names = FALSE`, but then our code (e.g., the calls to `aes()`) would\nneed to use backticks around the identifiers to make sure R interprets them\ncorrectly.\n\nNote the use of the `::` operator to call the `select` function by its fully\nqualified name, including the package. We already encountered this in [Chapter\n2](02-chap.html).\n\n    \n    \n    library(\"mouse4302.db\")__\n    \n    \n    AnnotationDbi::select(mouse4302.db,\n       keys = c(\"1426642_at\", \"1418765_at\"), keytype = \"PROBEID\",\n       columns = c(\"SYMBOL\", \"GENENAME\"))__\n    \n    \n         PROBEID SYMBOL                                            GENENAME\n    1 1426642_at    Fn1                                       fibronectin 1\n    2 1418765_at  Timd2 T cell immunoglobulin and mucin domain containing 2\n\nOften when using `ggplot` you will only need to specify the data, aesthetics\nand a geometric object. Most geometric objects implicitly call a suitable\ndefault statistical summary of the data. For example, if you are using\n`geom_smooth`, then\n**[ggplot2](https://cran.r-project.org/web/packages/ggplot2/)** uses `stat =\n\"smooth\"` by default and displays a line; if you use `geom_histogram`, the\ndata are binned and the result is displayed in barplot format. Hereâ€™s an\nexample:\n\n    \n    \n    dfx = as.data.frame(Biobase::exprs(x))\n    ggplot(dfx, aes(x = `20 E3.25`)) + geom_histogram(binwidth = 0.2)__\n\n[![](03-chap_files/figure-html/fig-graphics-\nhists-1.png)](03-chap_files/figure-html/fig-graphics-hists-1.png \"FigureÂ 3.11:\nHistogram of probe intensities for one particular sample, cell number 20,\nwhich was from day E3.25.\")\n\nFigure 3.11: Histogram of probe intensities for one particular sample, cell\nnumber 20, which was from day E3.25.\n\n__\n\nQuestion 3.4\n\nWhat is the difference between the objects `dfx` and `dftx`? Why did we need\nto create them both?\n\nLetâ€™s come back to the barplot example from above.\n\n    \n    \n    pb = ggplot(groups, aes(x = sampleGroup, y = n))__\n\nThis creates a plot object `pb`. If we try to display it, it creates an empty\nplot, because we havenâ€™t specified what geometric object we want to use. All\nthat we have in our `pb` object so far are the data and the aesthetics (Figure\n3.12).\n\n    \n    \n    class(pb)__\n    \n    \n    [1] \"gg\"     \"ggplot\"\n    \n    \n    pb __\n\n[![](03-chap_files/figure-html/fig-graphics-\nfigbpempty-1.png)](03-chap_files/figure-html/fig-graphics-figbpempty-1.png\n\"FigureÂ 3.12: pb: without a geometric object \\(a geom\\), the plot area remains\nempty. With the default style parameters, the tick labels on the x-axis are\nnot legible.\")\n\nFigure 3.12: `pb`: without a geometric object (a `geom`), the plot area\nremains empty. With the default style parameters, the tick labels on the\n\\\\(x\\\\)-axis are not legible.\n\nNow we can simply add on the other components of our plot through using the\n`+` operator (Figure 3.13):\n\n    \n    \n    pb = pb + geom_bar(stat = \"identity\")\n    pb = pb + aes(fill = sampleGroup)\n    pb = pb + theme(axis.text.x = element_text(angle = 90, hjust = 1))\n    pb = pb + scale_fill_manual(values = groupColor, name = \"Groups\")\n    pb __\n\n[![](03-chap_files/figure-html/fig-graphics-\nbpgg3-1.png)](03-chap_files/figure-html/fig-graphics-bpgg3-1.png \"FigureÂ 3.13:\nThe graphics object bp in its full glory.\")\n\nFigure 3.13: The graphics object `bp` in its full glory.\n\nThis step-wise buildup â€“taking a graphics object already produced in some way\nand then further refining itâ€“ can be more convenient and easy to manage than,\nsay, providing all the instructions upfront to the single function call that\ncreates the graphic.\n\nWe can quickly try out different visualization ideas without having to rebuild\nour plots each time from scratch, but rather store the partially finished\nobject and then modify it in different ways. For example we can switch our\nplot to polar coordinates to create an alternative visualization of the\nbarplot.\n\n    \n    \n    pb.polar = pb + coord_polar() +\n      theme(axis.text.x = element_text(angle = 0, hjust = 1),\n            axis.text.y = element_blank(),\n            axis.ticks = element_blank()) +\n      xlab(\"\") + ylab(\"\")\n    pb.polar __\n\n[![](03-chap_files/figure-html/fig-graphics-\nbpgg7-1.png)](03-chap_files/figure-html/fig-graphics-bpgg7-1.png \"FigureÂ 3.14:\nA barplot in a polar coordinate system.\")\n\nFigure 3.14: A barplot in a polar coordinate system.\n\nNote above that we can override previously set `theme` parameters by simply\nsetting them to a new value â€“ no need to go back to recreating `pb`, where we\noriginally set them.\n\n## 3.6 Visualizing data in 1D\n\nA common task in biological data analysis is the comparison between several\nsamples of univariate measurements. In this section weâ€™ll explore some\npossibilities for visualizing and comparing such samples. As an example, weâ€™ll\nuse the intensities of a set of four genes: Fgf4, Gata4, Gata6 and Sox26. On\nthe microarray, they are represented by\n\n6 You can read more about these genes in ([Ohnishi et al.\n2014](16-chap.html#ref-Ohnishi2014)).\n\n    \n    \n    selectedProbes = c( Fgf4 = \"1420085_at\", Gata4 = \"1418863_at\",\n                       Gata6 = \"1425463_at\",  Sox2 = \"1416967_at\")__\n\nTo extract data from this representation and convert them into a dataframe, we\nuse the function `melt` from the\n**[reshape2](https://cran.r-project.org/web/packages/reshape2/)** package7.\n\n7 Weâ€™ll talk more about the concepts and mechanics of different data\nrepresentations in [Section 13.10](13-chap.html#sec-design-datarep).\n\n    \n    \n    library(\"reshape2\")\n    genes = melt(Biobase::exprs(x)[selectedProbes, ],\n                 varnames = c(\"probe\", \"sample\"))__\n\nFor good measure, we also add a column that provides the gene symbol along\nwith the probe identifiers.\n\n    \n    \n    genes$gene =\n      names(selectedProbes)[match(genes$probe, selectedProbes)]\n    head(genes)__\n    \n    \n           probe  sample    value  gene\n    1 1420085_at 1 E3.25 3.027715  Fgf4\n    2 1418863_at 1 E3.25 4.843137 Gata4\n    3 1425463_at 1 E3.25 5.500618 Gata6\n    4 1416967_at 1 E3.25 1.731217  Sox2\n    5 1420085_at 2 E3.25 9.293016  Fgf4\n    6 1418863_at 2 E3.25 5.530016 Gata4\n\n### 3.6.1 Barplots\n\nA popular way to display data such as in our dataframe `genes` is through\nbarplots (Figure 3.15).\n\n    \n    \n    ggplot(genes, aes(x = gene, y = value)) +\n      stat_summary(fun = mean, geom = \"bar\")__\n\n[![](03-chap_files/figure-html/fig-graphics-\nonedbp1-1.png)](03-chap_files/figure-html/fig-graphics-onedbp1-1.png\n\"FigureÂ 3.15: Barplots showing the means of the distributions of expression\nmeasurements from four probes.\")\n\nFigure 3.15: Barplots showing the means of the distributions of expression\nmeasurements from four probes.\n\nIn Figure 3.15, each bar represents the mean of the values for that gene. Such\nplots are commonly used in the biological sciences, as well as in the popular\nmedia. However, summarizing the data into only a single number, the mean,\nloses much of the information, and given the amount of space they take,\nbarplot are a poor way to visualize data8.\n\n8 In fact, if the mean is not an appropriate summary, such as for highly\nskewed or multimodal distributions, or for datasets with large outliers, this\nkind of visualization can be outright misleading.\n\nSometimes we want to add error bars, and one way to achieve this in\n**[ggplot2](https://cran.r-project.org/web/packages/ggplot2/)** is as follows.\n\n    \n    \n    library(\"Hmisc\")\n    ggplot(genes, aes( x = gene, y = value, fill = gene)) +\n      stat_summary(fun = mean, geom = \"bar\") +\n      stat_summary(fun.data = mean_cl_normal, geom = \"errorbar\",\n                   width = 0.25)__\n\n[![](03-chap_files/figure-html/fig-graphics-\nonedbp2-1.png)](03-chap_files/figure-html/fig-graphics-onedbp2-1.png\n\"FigureÂ 3.16: Barplots with error bars indicating standard error of the\nmean.\")\n\nFigure 3.16: Barplots with error bars indicating standard error of the mean.\n\nHere, we see again the principle of layered graphics: we use two summary\nfunctions, `mean` and `mean_cl_normal`, and two associated geometric objects,\n`bar` and `errorbar`. The function `mean_cl_normal` is from the\n**[Hmisc](https://cran.r-project.org/web/packages/Hmisc/)** package and\ncomputes the standard error (or **c** onfidence **l** imits) of the mean; itâ€™s\na simple function, and we could also compute it ourselves using base R\nexpressions if we wished to do so. We have also colored the bars to make the\nplot more visually pleasing.\n\n### 3.6.2 Boxplots\n\nBoxplots take up a similar amount of space as barplots, but are much more\ninformative.\n\n    \n    \n    p = ggplot(genes, aes( x = gene, y = value, fill = gene))\n    p + geom_boxplot()__\n\n[![](03-chap_files/figure-html/fig-graphics-\nonedboxpl-1.png)](03-chap_files/figure-html/fig-graphics-onedboxpl-1.png\n\"FigureÂ 3.17: Boxplots.\")\n\nFigure 3.17: Boxplots.\n\nIn Figure 3.17 we see that two of the genes (Gata4, Gata6) have relatively\nconcentrated distributions, with only a few data points venturing out in the\ndirection of higher values. For Fgf4, we see that the distribution is right-\nskewed: the median, indicated by the horizontal black bar within the box is\ncloser to the lower (or left) side of the box. Conversely, for Sox2 the\ndistribution is left-skewed.\n\n### 3.6.3 Dot plots and beeswarm plots\n\nIf the number of data points is not too large, it is possible to show the data\npoints directly, and it is good practice to do so, compared to the summaries\nwe saw above. However, plotting the data directly will often lead to\noverlapping points, which can be visually unpleasant, or even obscure the\ndata. We can try to lay out the points so that they are as near possible to\ntheir proper locations without overlap ([Wilkinson 1999](16-chap.html#ref-\nWilkinson:DotPlots:1999)).\n\n    \n    \n    p + geom_dotplot(binaxis = \"y\", binwidth = 1/6,\n           stackdir = \"center\", stackratio = 0.75,\n           aes(color = gene))\n    library(\"ggbeeswarm\")\n    p + geom_beeswarm(aes(color = gene))__\n\n[![](03-chap_files/figure-html/fig-graphics-\noneddot-1.png)](03-chap_files/figure-html/fig-graphics-oneddot-1.png\n\"FigureÂ 3.18Â \\(a\\): \")\n\n(a)\n\n[![](03-chap_files/figure-html/fig-graphics-\noneddot-2.png)](03-chap_files/figure-html/fig-graphics-oneddot-2.png\n\"FigureÂ 3.18Â \\(b\\): \")\n\n(b)\n\nFigure 3.18: (a) Dot plots, made using `geom_dotplot` from\n**[ggplot2](https://cran.r-project.org/web/packages/ggplot2/)**. (b) Beeswarm\nplots, made using `geom_beeswarm` from\n**[ggbeeswarm](https://cran.r-project.org/web/packages/ggbeeswarm/)**.\n\nThe plot in panel (a) of Figure 3.18. The \\\\(y\\\\)-coordinates of the points\nare discretized into bins (above we chose a bin size of 1/6), and then they\nare stacked next to each other.\n\nAn alternative is provided by the package\n**[ggbeeswarm](https://cran.r-project.org/web/packages/ggbeeswarm/)** , which\nprovides `geom_beeswarm`. The plot is shown in panel (b) of Figure 3.18. The\nlayout algorithm aims to avoid overlaps between the points. If a point were to\noverlap an existing point, it is shifted along the \\\\(x\\\\)-axis by a small\namount sufficient to avoid overlap. Some tweaking of the layout parameters is\nusually needed for each new dataset to make a dot plot or a beeswarm plot look\ngood.\n\n### 3.6.4 Density plots\n\nYet another way to represent the same data is by density plots. Here, we try\nto estimate the underlying data-generating density by smoothing out the data\npoints (Figure 3.19).\n\n    \n    \n    ggplot(genes, aes( x = value, color = gene)) + geom_density()__\n\n[![](03-chap_files/figure-html/fig-graphics-\noneddens-1.png)](03-chap_files/figure-html/fig-graphics-oneddens-1.png\n\"FigureÂ 3.19: Density plots.\")\n\nFigure 3.19: Density plots.\n\nAs you can see from Figures 3.17â€”3.19, boxplots work fairly well for unimodal\ndata, but they can be misleading if the data distribution is multimodal, and\nthey also do not always give a fair impression of long-tailed distributions.\nBy showing the data points, or their densities, directly, Figures 3.18â€”3.19)\ngive a better impression of such features. For instance, we can see that the\ndata for Fgf4 and Sox2 are bimodal, while Gata4 and Gata6 have most of their\nvalues concentrated around a baseline, but a certain fraction of cells have\nelevated expression levels, across a wide range of values.\n\nDensity estimation has, however, a number of complications, in particular, the\nneed for choosing a smoothing window. A window size that is small enough to\ncapture peaks in the dense regions of the data may lead to instable (â€œwigglyâ€)\nestimates elsewhere. On the other hand, if the window is made bigger,\npronounced features of the density, such as sharp peaks, may be smoothed out.\nMoreover, the density lines do not convey the information on how much data was\nused to estimate them, and plots like Figure 3.19 can be especially\nproblematic if the sample sizes for the curves differ.\n\n### 3.6.5 Violin plots\n\nDensity plots such as Figure 3.19 can look crowded if there are several\ndensities, and one idea is to arrange the densities in a layout inspired by\nboxplots: the violin plot (Figure 3.20). Here, the density estimate is used to\ndraw a symmetric shape, which sometimes visually reminds of a violin.\n\n    \n    \n    p + geom_violin()__\n\n[![](03-chap_files/figure-html/fig-graphics-\nonedviolin-1.png)](03-chap_files/figure-html/fig-graphics-onedviolin-1.png\n\"FigureÂ 3.20: Violin plots.\")\n\nFigure 3.20: Violin plots.\n\n### 3.6.6 Ridgeline plots\n\nAnother play on density plots are ridgeline plots (Figure 3.21):\n\n    \n    \n    library(\"ggridges\")\n    ggplot(genes, aes(x = value, y = gene, fill = gene)) + \n      geom_density_ridges()__\n\n[![](03-chap_files/figure-html/fig-graphics-\nonedridge4-1.png)](03-chap_files/figure-html/fig-graphics-onedridge4-1.png\n\"FigureÂ 3.21: Ridgeline plots.\")\n\nFigure 3.21: Ridgeline plots.\n\nThis type of display is perhaps most appropriate if the number of densities\nshown goes into the dozens.\n\n    \n    \n    top42 = order(rowMeans(Biobase::exprs(x)), decreasing = TRUE)[1:42]\n    g42 = melt(Biobase::exprs(x)[rev(top42), ], varnames = c(\"probe\", \"sample\"))\n    ggplot(g42, aes(x = value, y = probe)) __\n\n[![](03-chap_files/figure-html/fig-graphics-\nonedridge42-1.png)](03-chap_files/figure-html/fig-graphics-onedridge42-1.png\n\"FigureÂ 3.22: Like FigureÂ fig-graphics-onedridge4, with more genes.\")\n\nFigure 3.22: Like Figure 3.21, with more genes.\n\n### 3.6.7 ECDF plots\n\nThe mathematically most convenient way to describe the distribution of a one-\ndimensional random variable \\\\(X\\\\) is its **cumulative distribution\nfunction** (**CDF**), i.e., the function defined by\n\n\\\\[ F(x) = P(X\\le x), \\tag{3.1}\\\\]\n\nwhere \\\\(x\\\\) takes all values along the real axis. The density of \\\\(X\\\\) is\nthen the derivative of \\\\(F\\\\), if it exists9. The finite sample version of\nthe probability 3.1 is called the **empirical cumulative distribution\nfunction** (**ECDF**),\n\n9 By its definition, \\\\(F\\\\) tends to 0 for small \\\\(x\\\\) (\\\\(x\\to-\\infty\\\\))\nand to 1 for large \\\\(x\\\\) (\\\\(x\\to+\\infty\\\\)).\n\n\\\\[ F_{n}(x) = \\frac{\\text{number of $i$ for which } x_i \\le x}{n} =\n\\frac{1}{n}\\sum_{i=1}^n ðŸ™({x\\le x_i}), \\tag{3.2}\\\\]\n\nwhere \\\\(x_1,...,x_n\\\\) denote a sample of \\\\(n\\\\) draws from \\\\(X\\\\) and\n\\\\(ðŸ™\\\\) is the indicator function, i.e., the function that takes the value 1\nif the expression in its argument is true and 0 otherwise. If this sounds\nabstract, we can get a perhaps more intuitive understanding from the following\nexample (Figure 3.23):\n\n    \n    \n    simdata = rnorm(70)\n    tibble(index = seq(along = simdata),\n              sx = sort(simdata)) %>%\n    ggplot(aes(x = sx, y = index)) + geom_step()__\n\n[![](03-chap_files/figure-html/fig-graphics-\necdfexample-1.png)](03-chap_files/figure-html/fig-graphics-ecdfexample-1.png\n\"FigureÂ 3.23: Sorted values of simdata versus their index. This is the\nempirical cumulative distribution function of simdata.\")\n\nFigure 3.23: Sorted values of `simdata` versus their index. This is the\nempirical cumulative distribution function of `simdata`.\n\nPlotting the sorted values against their ranks gives the essential features of\nthe ECDF (Figure 3.23). In practice, we do not need to do the sorting and the\nother steps in the above code manually and will rather use the `stat_ecdf()`\ngeometric object. The ECDFs of our data are shown in Figure 3.24.\n\n    \n    \n    ggplot(genes, aes( x = value, color = gene)) + stat_ecdf()__\n\n[![](03-chap_files/figure-html/fig-graphics-\nonedecdf-1.png)](03-chap_files/figure-html/fig-graphics-onedecdf-1.png\n\"FigureÂ 3.24: Empirical cumulative distribution functions \\(ECDF\\).\")\n\nFigure 3.24: Empirical cumulative distribution functions (ECDF).\n\nThe ECDF has several nice properties:\n\n  * It is lossless: the ECDF \\\\(F_{n}(x)\\\\) contains all the information contained in the original sample \\\\(x_1,...,x_n\\\\), except for the order of the values, which is assumed to be unimportant.\n\n  * As \\\\(n\\\\) grows, the ECDF \\\\(F_{n}(x)\\\\) converges to the true CDF \\\\(F(x)\\\\). Even for limited sample sizes \\\\(n\\\\), the difference between the two functions tends to be small. Note that this is not the case for the empirical density! Without smoothing, the empirical density of a finite sample is a sum of Dirac delta functions, which is difficult to visualize and quite different from any underlying smooth, true density. With smoothing, the difference can be less pronounced, but is difficult to control, as we discussed above.\n\n[![](imgs/Lawrence-TCGA-Nature-2013-Fig1.png)](imgs/Lawrence-TCGA-\nNature-2013-Fig1.png \"FigureÂ 3.25: Part of Figure 1 from\n@Lawrence:Nature:2013. Each dot corresponds to a tumour-normal pair, with\nvertical position indicating the total frequency of somatic mutations in the\nexome. The resulting curves are, in essence, ECDF plots, and conceptually this\nplot is similar to FigureÂ fig-graphics-onedecdf, just that the graphs are\nrotated by 90 degrees \\(i.e., the roles of x- and y-axis are exchanged\\) and\nthe curves for the individual tumor types are horizontally displaced to keep\nthem better apart.\")\n\nFigure 3.25: Part of Figure 1 from Lawrence et al. ([2013](16-chap.html#ref-\nLawrence:Nature:2013)). Each dot corresponds to a tumour-normal pair, with\nvertical position indicating the total frequency of somatic mutations in the\nexome. The resulting curves are, in essence, ECDF plots, and conceptually this\nplot is similar to Figure 3.24, just that the graphs are rotated by 90 degrees\n(i.e., the roles of \\\\(x\\\\)\\- and \\\\(y\\\\)-axis are exchanged) and the curves\nfor the individual tumor types are horizontally displaced to keep them better\napart.\n\n__\n\nTask\n\n**tibbles.** In the above code we saw the `tibble` for the first time. Have a\nlook at the vignette of the\n**[tibble](https://cran.r-project.org/web/packages/tibble/)** package for what\nit does.\n\n### 3.6.8 The effect of transformations on densities\n\nIt is tempting to look at histograms or density plots and inspect them for\nevidence of **bimodality** (or multimodality) as an indication of some\nunderlying biological phenomenon. Before doing so, it is important to remember\nthat the number of modes of a density depends on scale transformations of the\ndata, via the **chain rule**. For instance, letâ€™s look at the data from one of\nthe arrays in the Hiiragi dataset (Figure 3.26):\n\n    \n    \n    ggplot(dfx, aes(x = `64 E4.5 (EPI)`)) + geom_histogram(bins = 100)\n    ggplot(dfx, aes(x = 2 ^ `64 E4.5 (EPI)`)) + \n      geom_histogram(binwidth = 20) + xlim(0, 1500)__\n\n[![](03-chap_files/figure-html/fig-graphics-\nonedtrsf-1.png)](03-chap_files/figure-html/fig-graphics-onedtrsf-1.png\n\"FigureÂ 3.26Â \\(a\\): \")\n\n(a)\n\n[![](03-chap_files/figure-html/fig-graphics-\nonedtrsf-2.png)](03-chap_files/figure-html/fig-graphics-onedtrsf-2.png\n\"FigureÂ 3.26Â \\(b\\): \")\n\n(b)\n\nFigure 3.26: Histograms of the same data, with and without logarithm\ntransform. (a) The data are shown on the scale on which they are stored in the\ndata object `x`, which resulted from logarithm (base 2) transformation of the\nmicroarray fluorescence intensities ([Irizarry et al. 2003](16-chap.html#ref-\nIrizarry:Biostat:2003)); (b) after re-exponentiating them back to the\nfluorescence scale. For better use of space, we capped the \\\\(x\\\\)-axis range\nat 1500.\n\n__\n\nQuestion 3.5\n\n(Advanced:) Consider a random variable \\\\(X\\\\) and a non-linear 1:1\ntransformation \\\\(f: x \\mapsto y\\\\) that defines the transformed random\nvariable \\\\(Y = f(X)\\\\). Suppose the density function of \\\\(Y\\\\) is\n\\\\(p(y)\\\\). What is the density of \\\\(X\\\\)? How is the mode (or: the modes) of\n\\\\(X\\\\) related to the mode(s) of \\\\(Y\\\\)?  \nHint: note that a mode of a function \\\\(p\\\\) is a root of its derivative\n\\\\(p'=dp/dx\\\\). Is it generally true that if \\\\(x_0\\\\) is a mode of \\\\(X\\\\),\nthen \\\\(y_0=f(x_0)\\\\) is a mode of \\\\(Y\\\\)?\n\n__\n\nSolution\n\n__\n\nAccording to the chain rule, \\\\(p(y)\\, dy = p(f(x))\\,f'(x)\\,dx\\\\), so the\ndensity of \\\\(X\\\\) is \\\\(\\tilde{p}(x) = p(f(x))\\,f'(x)\\\\). The modes of\n\\\\(\\tilde{p}\\\\) are roots of its derivative \\\\(d\\tilde{p}/dx\\\\), i.e., they\nobey \\\\(p'(f(x))\\,f'^2(x) + p(f(x))f\"(x) = 0\\\\). The second term in the sum\nvanishes if \\\\(f\\\\) is affine linear (\\\\(f\"\\equiv0\\\\)), but in general there\nis no simple relationship between the roots of the two densities, and\ntherefore between the modes of \\\\(X\\\\) and \\\\(Y\\\\).\n\n## 3.7 Visualizing data in 2D: scatterplots\n\nScatterplots are useful for visualizing treatmentâ€“response comparisons (as in\nFigure 3.3), associations between variables (as in Figure 3.10), or paired\ndata (e.g., a disease biomarker in several patients before and after\ntreatment). We use the two dimensions of our plotting paper, or screen, to\nrepresent the two variables. Letâ€™s take a look at differential expression\nbetween a wildtype and an FGF4-KO sample.\n\n    \n    \n    scp = ggplot(dfx, aes(x = `59 E4.5 (PE)` ,\n                          y = `92 E4.5 (FGF4-KO)`))\n    scp + geom_point()__\n\n[![](03-chap_files/figure-html/fig-graphics-\ntwodsp1-1.png)](03-chap_files/figure-html/fig-graphics-twodsp1-1.png\n\"FigureÂ 3.27: Scatterplot of 45101 expression measurements for two of the\nsamples.\")\n\nFigure 3.27: Scatterplot of 45101 expression measurements for two of the\nsamples.\n\nThe labels 59 E4.5 (PE) and 92 E4.5 (FGF4-KO) refer to column names (sample\nnames) in the dataframe `dfx`, which we created above. Since they contain\nspecial characters (spaces, parentheses, hyphen) and start with numerals, we\nneed to enclose them with the downward sloping quotes to make them\nsyntactically digestible for R. The plot is shown in Figure 3.27. We get a\ndense point cloud that we can try and interpret on the outskirts of the cloud,\nbut we really have no idea visually how the data are distributed within the\ndenser regions of the plot.\n\nOne easy way to ameliorate the overplotting is to adjust the transparency\n(alpha value) of the points by modifying the `alpha` parameter of `geom_point`\n(Figure 3.28).\n\n    \n    \n    scp  + geom_point(alpha = 0.1)__\n\n[![](03-chap_files/figure-html/fig-graphics-\ntwodsp2-1.png)](03-chap_files/figure-html/fig-graphics-twodsp2-1.png\n\"FigureÂ 3.28: As FigureÂ fig-graphics-twodsp1, but with semi-transparent points\nto resolve some of the overplotting.\")\n\nFigure 3.28: As Figure 3.27, but with semi-transparent points to resolve some\nof the overplotting.\n\nThis is already better than Figure 3.27, but in the more dense regions even\nthe semi-transparent points quickly overplot to a featureless black mass,\nwhile the more isolated, outlying points are getting faint. An alternative is\na contour plot of the 2D density, which has the added benefit of not rendering\nall of the points on the plot, as in Figure 3.29.\n\nHowever, we see in Figure 3.29 that the point cloud at the bottom right (which\ncontains a relatively small number of points) is no longer represented. We can\nsomewhat overcome this by tweaking the bandwidth and binning parameters of\n`geom_density2d` (Figure 3.30, left panel).\n\n    \n    \n    scp + geom_density2d()__\n\n[![](03-chap_files/figure-html/fig-graphics-\ntwodsp3-1.png)](03-chap_files/figure-html/fig-graphics-twodsp3-1.png\n\"FigureÂ 3.29: As FigureÂ fig-graphics-twodsp1, but rendered as a contour plot\nof the 2D density estimate.\")\n\nFigure 3.29: As Figure 3.27, but rendered as a contour plot of the 2D density\nestimate.\n\n    \n    \n    scp + geom_density2d(h = 0.5, bins = 60)\n    library(\"RColorBrewer\")\n    colorscale = scale_fill_gradientn(\n        colors = rev(brewer.pal(9, \"YlGnBu\")),\n        values = c(0, exp(seq(-5, 0, length.out = 100))))\n    \n    scp + stat_density2d(h = 0.5, bins = 60,\n              aes( fill = after_stat(level)), geom = \"polygon\") +\n      colorscale + coord_fixed()__\n\n[![](03-chap_files/figure-html/fig-graphics-\ntwodsp4-1.png)](03-chap_files/figure-html/fig-graphics-twodsp4-1.png\n\"FigureÂ 3.30Â \\(a\\): \")\n\n(a)\n\n[![](03-chap_files/figure-html/fig-graphics-\ntwodsp4-2.png)](03-chap_files/figure-html/fig-graphics-twodsp4-2.png\n\"FigureÂ 3.30Â \\(b\\): \")\n\n(b)\n\nFigure 3.30: 2D density plots. (a) As Figure 3.29, but with smaller smoothing\nbandwidth and tighter binning for the contour lines. (b) With color filling.\n\nWe can fill in each space between the contour lines with the relative density\nof points by explicitly calling the function `stat_density2d` (for which\n`geom_density2d` is a wrapper) and using the geometric object _polygon_ , as\nin the right panel of Figure 3.30.\n\nWe used the function `brewer.pal` from the package\n**[RColorBrewer](https://cran.r-project.org/web/packages/RColorBrewer/)** to\ndefine the color scale, and we added a call to `coord_fixed` to fix the aspect\nratio of the plot, to make sure that the mapping of data range to \\\\(x\\\\)\\-\nand \\\\(y\\\\)-coordinates is the same for the two variables. Both of these\nissues merit a deeper look, and weâ€™ll talk more about plot shapes in Section\n3.7.1 and about colors in Section 3.9.\n\nThe density based plotting methods in Figure 3.30 are more visually appealing\nand interpretable than the overplotted point clouds of Figures 3.27 and 3.28,\nthough we have to be careful in using them as we lose much of the information\non the outlier points in the sparser regions of the plot. One possibility is\nusing `geom_point` to add such points back in.\n\nBut arguably the best alternative, which avoids the limitations of smoothing,\nis hexagonal binning ([Carr et al. 1987](16-chap.html#ref-Carr1987hexbin)).\n\n    \n    \n    scp + geom_hex() + coord_fixed()\n    scp + geom_hex(binwidth = c(0.2, 0.2)) + colorscale +\n      coord_fixed()__\n\n[![](03-chap_files/figure-html/fig-graphics-\ntwodsp6-1.png)](03-chap_files/figure-html/fig-graphics-twodsp6-1.png\n\"FigureÂ 3.31Â \\(a\\): \")\n\n(a)\n\n[![](03-chap_files/figure-html/fig-graphics-\ntwodsp6-2.png)](03-chap_files/figure-html/fig-graphics-twodsp6-2.png\n\"FigureÂ 3.31Â \\(b\\): \")\n\n(b)\n\nFigure 3.31: Hexagonal binning. (a) Default parameters. (b) Finer bin sizes\nand customized color scale.\n\n### 3.7.1 Plot shapes\n\nChoosing the proper shape for your plot is important to make sure the\ninformation is conveyed well. By default, the shape parameter, that is, the\nratio between the height of the graph and its width, is chosen by\n**[ggplot2](https://cran.r-project.org/web/packages/ggplot2/)** based on the\navailable space in the current plotting device. The width and height of the\ndevice are specified when it is opened in R, either explicitly by you or\nthrough default parameters10. Moreover, the graph dimensions also depend on\nthe presence or absence of additional decorations, like the color scale bars\nin Figure 3.31.\n\n10 See for example the manual pages of the `pdf` and `png` functions.\n\nThere are two simple rules that you can apply for scatterplots:\n\n  * If the variables on the two axes are measured in the same units, then make sure that the same mapping of data space to physical space is used â€“ i.e., use `coord_fixed`. In the scatterplots above, both axes are the logarithm to base 2 of expression level measurements; that is, a change by one unit has the same meaning on both axes (a doubling of the expression level). Another case is principal component analysis (PCA), where the \\\\(x\\\\)-axis typically represents component 1, and the \\\\(y\\\\)-axis component 2. Since the axes arise from an orthonormal rotation of input data space, we want to make sure their scales match. Since the variance of the data is (by definition) smaller along the second component than along the first component (or at most, equal), well-made PCA plots usually have a width thatâ€™s larger than the height.\n\n  * If the variables on the two axes are measured in different units, then we can still relate them to each other by comparing their dimensions. The default in many plotting routines in R, including **[ggplot2](https://cran.r-project.org/web/packages/ggplot2/)** , is to look at the range of the data and map it to the available plotting region. However, in particular when the data more or less follow a line, looking at the typical slope of the line can be useful. This is called **banking** ([William S. Cleveland, McGill, and McGill 1988](16-chap.html#ref-Cleveland:1988:Banking)).\n\nTo illustrate banking, letâ€™s use the classic sunspot data from Clevelandâ€™s\npaper.\n\n    \n    \n    library(\"ggthemes\")\n    sunsp = tibble(year   = time(sunspot.year),\n                   number = as.numeric(sunspot.year))\n    sp = ggplot(sunsp, aes(x = year, y = number)) + geom_line()\n    sp\n    ratio = with(sunsp, bank_slopes(year, number))\n    sp + coord_fixed(ratio = ratio)__\n\n[![](03-chap_files/figure-html/fig-graphics-\nbanking-1.png)](03-chap_files/figure-html/fig-graphics-banking-1.png\n\"FigureÂ 3.32Â \\(a\\): \")\n\n(a)\n\n[![](03-chap_files/figure-html/fig-graphics-\nbanking-2.png)](03-chap_files/figure-html/fig-graphics-banking-2.png\n\"FigureÂ 3.32Â \\(b\\): \")\n\n(b)\n\nFigure 3.32: The sunspot data. In (a), the plot shape is roughly quadratic, a\nfrequent default choice. In (b), a technique called **banking** was used to\nchoose the plot shape. (Note: the placement of the tick labels is not great in\nthis plot and would benefit from customization.)\n\nThe resulting plot is shown in the upper panel of Figure 3.32. We can clearly\nsee long-term fluctuations in the amplitude of sunspot activity cycles, with\nparticularly low maximum activities in the early 1700s, early 1800s, and\naround the turn of the 20\\\\(^\\text{th}\\\\) century. But now lets try out\nbanking.\n\nHow does the algorithm work? It aims to make the slopes in the curve be around\none. In particular, `bank_slopes` computes the median absolute slope, and then\nwith the call to `coord_fixed` we set the aspect ratio of the plot such that\nthis quantity becomes 1. The result is shown in the lower panel of Figure\n3.32. Quite counter-intuitively, even though the plot takes much smaller\nspace, we see more on it! In particular, we can see the saw-tooth shape of the\nsunspot cycles, with sharp rises and more slow declines.\n\n## 3.8 Visualizing more than two dimensions\n\nSometimes we want to show the relationships between more than two variables.\nObvious choices for including additional dimensions are the plot symbol shapes\nand colors. The `geom_point` geometric object offers the following aesthetics\n(beyond `x` and `y`):\n\n  * `fill`\n\n  * `color`\n\n  * `shape`\n\n  * `size`\n\n  * `alpha`\n\nThey are explored in the manual page of the `geom_point` function. `fill` and\n`color` refer to the fill and outline color of an object, and `alpha` to its\ntransparency level. Above, in Figures 3.28 and following, we have used color\nor transparency to reflect point density and avoid the obscuring effects of\noverplotting. We can also use these properties to show other dimensions of the\ndata. In principle, we could use all five aesthetics listed above\nsimultaneously to show up to seven-dimensional data; however, such a plot\nwould be hard to decipher. Usually we are better off to limit ourselves to\nchoosing only one or two of these aesthetics and varying them to show one or\ntwo additional dimensions in the data.\n\n### 3.8.1 Faceting\n\n[![Sometimes this is also called trellis or lattice graphics, in an allusion\nto how these arrays of plots look like. The first major R package to implement\nfaceting was lattice. In this book, weâ€™ll use the faceting functionalities\nprovided through ggplot2.](imgs/devil.png)](imgs/devil.png \"Sometimes this is\nalso called trellis or lattice graphics, in an allusion to how these arrays of\nplots look like. The first major R package to implement faceting was lattice.\nIn this book, weâ€™ll use the faceting functionalities provided through\nggplot2.\")\n\nSometimes this is also called _trellis_ or _lattice_ graphics, in an allusion\nto how these arrays of plots look like. The first major R package to implement\nfaceting was **[lattice](https://cran.r-project.org/web/packages/lattice/)**.\nIn this book, weâ€™ll use the faceting functionalities provided through\n**[ggplot2](https://cran.r-project.org/web/packages/ggplot2/)**.\n\nAnother way to show additional dimensions of the data is to show multiple\nplots that result from repeatedly subsetting (or â€œslicingâ€) our data based on\none (or more) of the variables, so that we can visualize each part separately.\nThis is called **faceting** and it enables us to visualize data in up to four\nor five dimensions. So we can, for instance, investigate whether the observed\npatterns among the other variables are the same or different across the range\nof the faceting variable. Letâ€™s look at an example:\n\n    \n    \n    library(\"magrittr\")\n    dftx$lineage %<>% sub(\"^$\", \"no\", .)\n    dftx$lineage %<>% factor(levels = c(\"no\", \"EPI\", \"PE\", \"FGF4-KO\"))\n    \n    ggplot(dftx, aes(x = X1426642_at, y = X1418765_at)) +\n      geom_point() + facet_grid( . ~ lineage )__\n\n[![](03-chap_files/figure-html/fig-graphics-\nfacet1-1.png)](03-chap_files/figure-html/fig-graphics-facet1-1.png\n\"FigureÂ 3.33: An example of faceting: the same data as in FigureÂ fig-graphics-\nscp2layers1, but now split by the categorical variable lineage.\")\n\nFigure 3.33: An example of **faceting** : the same data as in Figure 3.9, but\nnow split by the categorical variable `lineage`.\n\nThe result is shown in Figure 3.33. We have used Râ€™s formula language to\nspecify the variable by which we want to split the data, and that the separate\npanels should be in different columns: `facet_grid( . ~ lineage )`. In fact,\nwe can specify two faceting variables, as follows; the result is shown in\nFigure 3.34.\n\n    \n    \n    ggplot(dftx,\n      aes(x = X1426642_at, y = X1418765_at)) + geom_point() +\n       facet_grid( Embryonic.day ~ lineage )__\n\n[![](03-chap_files/figure-html/fig-graphics-\nfacet2-1.png)](03-chap_files/figure-html/fig-graphics-facet2-1.png\n\"FigureÂ 3.34: Faceting: the same data as in FigureÂ fig-graphics-scp2layers1,\nsplit by the categorical variables Embryonic.day \\(rows\\) and lineage\n\\(columns\\).\")\n\nFigure 3.34: **Faceting** : the same data as in Figure 3.9, split by the\ncategorical variables `Embryonic.day` (rows) and `lineage` (columns).\n\nAnother useful function is `facet_wrap`: if the faceting variable has too many\nlevels for all the plots to fit in one row or one column, then this function\ncan be used to wrap them into a specified number of columns or rows. So far we\nhave seen faceting by categorical variables, but we can also use it with\ncontinuous variables by discretizing them into levels. The function `cut` is\nuseful for this purpose.\n\n    \n    \n    ggplot(mutate(dftx, Tdgf1 = cut(X1450989_at, breaks = 4)),\n       aes(x = X1426642_at, y = X1418765_at)) + geom_point() +\n       facet_wrap( ~ Tdgf1, ncol = 2 )__\n\n[![](03-chap_files/figure-html/fig-graphics-\nfacet3-1.png)](03-chap_files/figure-html/fig-graphics-facet3-1.png\n\"FigureÂ 3.35: Faceting: the same data as in FigureÂ fig-graphics-scp2layers1,\nsplit by the continuous variable X1450989_at and arranged by facet_wrap.\")\n\nFigure 3.35: **Faceting** : the same data as in Figure 3.9, split by the\ncontinuous variable `X1450989_at` and arranged by `facet_wrap`.\n\nWe see in Figure 3.35 that the number of points in the four panels is\ndifferent. This is because `cut` splits into bins of equal length, not equal\nnumber of points. If we want the latter, then we can use `quantile` in\nconjunction with `cut`, or cut on the ranks of the variableâ€™s values.\n\n#### Axes scales\n\nIn Figures 3.33â€”3.35, the axes scales are the same for all panels.\nAlternatively, we could let them vary by setting the `scales` argument of the\n`facet_grid` and `facet_wrap` functions. This argument lets you control\nwhether \\\\(x\\\\)-axis and \\\\(y\\\\)-axis in each panel have the same scale, or\nwhether either of them or both adapt to each panelâ€™s data range. There is a\ntrade-off: adaptive axes scales might let us see more detail, on the other\nhand, the panels are then less comparable across the groupings.\n\n#### Implicit faceting\n\nYou can also facet your plots (without explicit calls to `facet_grid` and\n`facet_wrap`) by specifying the aesthetics. A very simple version of implicit\nfaceting is using a factor as your \\\\(x\\\\)-axis, such as in Figures 3.15â€”3.18.\n\n### 3.8.2 Interactive graphics\n\nThe plots generated thus far have been static images. You can add an enormous\namount of information and expressivity by making your plots interactive. We do\nnot try here to to convey interactive visualizations in any depth, but we\nprovide pointers to a few important resources. This is a dynamic space, so\nreaders should explore the R ecosystem for recent developments.\n\n#### shiny\n\nRstudioâ€™s **[shiny](https://cran.r-project.org/web/packages/shiny/)** is a web\napplication framework for R. It makes it easy to create interactive displays\nwith sliders, selectors and other control elements that allow changing all\naspects of the plot(s) shown â€“ since the interactive elements call back\ndirectly into the R code that produces the plot(s). See the [shiny\ngallery](https://shiny.posit.co/r/gallery) for some great examples.\n\nAs a graphics engine for\n**[shiny](https://cran.r-project.org/web/packages/shiny/)** -based interactive\nvisualizations you can use\n**[ggplot2](https://cran.r-project.org/web/packages/ggplot2/)** , and indeed,\nbase R graphics or any other graphics package. What may be a little awkward\nhere is that the language used for describing the interactive options is\nseparated from the production of the graphics via\n**[ggplot2](https://cran.r-project.org/web/packages/ggplot2/)** and the\ngrammar of graphics. The\n**[ggvis](https://cran.r-project.org/web/packages/ggvis/)** package aims to\novercome this limitation:\n\n#### ggvis\n\n**[ggvis](https://cran.r-project.org/web/packages/ggvis/)** 11 is an attempt\nat extending the good features of\n**[ggplot2](https://cran.r-project.org/web/packages/ggplot2/)** into the realm\nof interactive graphics. In contrast to\n**[ggplot2](https://cran.r-project.org/web/packages/ggplot2/)** , which\nproduces graphics into Râ€™s traditional graphics devices (PDF, PNG, etc.),\n**[ggvis](https://cran.r-project.org/web/packages/ggvis/)** builds upon a\nJavaScript infrastructure called [Vega](https://github.com/trifacta/vega), and\nits plots are intended to be viewed in an HTML browser. Like\n**[ggplot2](https://cran.r-project.org/web/packages/ggplot2/)** , the\n**[ggvis](https://cran.r-project.org/web/packages/ggvis/)** package is\ninspired by grammar of graphics concepts, but uses distinct syntax. It\nleverages **[shiny](https://cran.r-project.org/web/packages/shiny/)** â€™s\ninfrastructure to connect to R to perform the computations needed for the\ninteractivity. As its author put it12, â€œThe goal is to combine the best of R\n(e.g., every modeling function you can imagine) and the best of the web\n(everyone has a web browser). Data manipulation and transformation are done in\nR, and the graphics are rendered in a web browser, using Vega.â€\n\n11 At the time of writing (summer 2017), it is not clear whether the initial\nmomentum of **[ggvis](https://cran.r-project.org/web/packages/ggvis/)**\ndevelopment will be maintained, and its current functionality and maturity do\nno yet match **[ggplot2](https://cran.r-project.org/web/packages/ggplot2/)**.\n\n12 https://ggvis.rstudio.com\n\nAs a consequence of the interactivity in\n**[shiny](https://cran.r-project.org/web/packages/shiny/)** and\n**[ggvis](https://cran.r-project.org/web/packages/ggvis/)** , there needs to\nbe an R interpreter running with the underlying data and code to respond to\nthe userâ€™s actions while she views the graphic. This R interpreter can be on\nthe local machine or on a server; in both cases, the viewing application is a\nweb browser, and the interaction with R goes through web protocols (http or\nhttps). That is, of course, different from a graphic stored in a self-\ncontained file, which is produced once by R and can then be viewed in a PDF or\nHTML viewer without any connection to a running instance of R.\n\n#### plotly\n\nA great web-based tool for interactive graphic generation is **plotly**. You\ncan view some examples of interactive graphics online at <https://plot.ly/r>.\nTo create your own interactive plots in R, you can use code such as\n\n    \n    \n    library(\"plotly\")\n    plot_ly(economics, x = ~ date, y = ~ unemploy / pop)__\n\nAs with **[shiny](https://cran.r-project.org/web/packages/shiny/)** and\n**[ggvis](https://cran.r-project.org/web/packages/ggvis/)** , the graphics are\nviewed in an HTML browser; however, no running R session is required. The\ngraphics are self-contained HTML documents whose â€œlogicâ€ is coded in\nJavaScript, or more precisely, in the D3.js system.\n\n[![](imgs/chap3-rglvolcano.png)](imgs/chap3-rglvolcano.png \"FigureÂ 3.36: rgl\nrendering of the volcano data, the topographic information for Maunga Whau\n\\(Mt Eden\\), one of about 50 volcanos in the Auckland volcanic field.\")\n\nFigure 3.36: **[rgl](https://cran.r-project.org/web/packages/rgl/)** rendering\nof the `volcano` data, the topographic information for Maunga Whau (Mt Eden),\none of about 50 volcanos in the Auckland volcanic field.\n\n#### rgl, webgl\n\nFor visualizing 3D objects (say, a geometrical structure), there is the\npackage **[rgl](https://cran.r-project.org/web/packages/rgl/)**. It produces\ninteractive viewer windows (either in specialized graphics device on your\nscreen or through a web browser) in which you can rotate the scene, zoom and\nin out, etc. A screenshot of the scene produced by the code below is shown in\nFigure 3.36; such screenshots can be produced using the function `snapshot3d`.\n\n    \n    \n    data(\"volcano\")\n    volcanoData = list(\n      x = 10 * seq_len(nrow(volcano)),\n      y = 10 * seq_len(ncol(volcano)),\n      z = volcano,\n      col = terrain.colors(500)[cut(volcano, breaks = 500)]\n    )\n    library(\"rgl\")\n    with(volcanoData, persp3d(x, y, z, color = col))__\n\nIn the code above, the base R function `cut` computes a mapping from the value\nrange of the `volcano` data to the integers between 1 and 50013, which we use\nto index the color scale, `terrain.colors(500)`. For more information, consult\nthe packageâ€™s excellent vignette.\n\n13 More precisely, it returns a factor with as many levels, which we let R\nautoconvert to integers.\n\n## 3.9 Color\n\nAn important consideration when making plots is the coloring that we use in\nthem. Most R users are likely familiar with the built-in R color scheme, used\nby base R graphics, as shown in Figure 3.37.\n\n    \n    \n    pie(rep(1, 8), col=1:8)__\n\n[![](03-chap_files/figure-html/fig-graphics-\nsimplecolorpie-1.png)](03-chap_files/figure-html/fig-graphics-\nsimplecolorpie-1.png \"FigureÂ 3.37: The first eight colors in the base R color\npalette.\")\n\nFigure 3.37: The first eight colors in the base R color palette.\n\nThe origins of this color palette date back to 1980s hardware, where graphics\ncards handled colors by letting each pixel either use or not use each of the\nthree basic color channels of a cathode-ray tube: red, green and blue (RGB).\nThis led to \\\\(2^3=8\\\\) combinations at the eight corners of an RGB color\ncube14.\n\n14 Thus, the \\\\(8^\\text{th}\\\\) color in Figure 3.37 should be white, instead\nit is grey.\n\nThe first eight colors for a categorical variable in\n**[ggplot2](https://cran.r-project.org/web/packages/ggplot2/)** are shown in\nFigure 3.38:\n\n    \n    \n    ggplot(tibble(u = factor(1:8), v = 1), \n           aes(x = \"\",  y = v, fill = u)) +\n      geom_bar(stat = \"identity\", width = 1) + \n      coord_polar(\"y\", start = 0) + theme_void()__\n\n[![](03-chap_files/figure-html/fig-graphics-\nggplot2colorpie-1.png)](03-chap_files/figure-html/fig-graphics-\nggplot2colorpie-1.png \"FigureÂ 3.38: The first eight colors in the ggplot2\ncolor palette.\")\n\nFigure 3.38: The first eight colors in the\n**[ggplot2](https://cran.r-project.org/web/packages/ggplot2/)** color palette.\n\nThese defaults are appropriate for simple use cases, but often we will want to\nmake our own choices. In Section 3.7 we already saw the function\n`scale_fill_gradientn`, with which we created the smooth-looking color\ngradient used in Figures 3.30 and 3.31 by interpolating a set of color steps\nprovided by the function `brewer.pal` in the\n**[RColorBrewer](https://cran.r-project.org/web/packages/RColorBrewer/)**\npackage. This package defines a set of purpose-designed color palettes. We can\nsee all of them at a glance with the function `display.brewer.all` (Figure\n3.39).\n\n    \n    \n    display.brewer.all()__\n\n[![](03-chap_files/figure-html/fig-graphics-\nRColorBrewer-1.png)](03-chap_files/figure-html/fig-graphics-RColorBrewer-1.png\n\"FigureÂ 3.39: RColorBrewer palettes.\")\n\nFigure 3.39: RColorBrewer palettes.\n\nWe can get information about the available color palettes from\n`brewer.pal.info`.\n\n    \n    \n    head(brewer.pal.info)__\n    \n    \n         maxcolors category colorblind\n    BrBG        11      div       TRUE\n    PiYG        11      div       TRUE\n    PRGn        11      div       TRUE\n    PuOr        11      div       TRUE\n    RdBu        11      div       TRUE\n    RdGy        11      div      FALSE\n    \n    \n    table(brewer.pal.info$category)__\n    \n    \n     div qual  seq \n       9    8   18 \n\nThe palettes are divided into three categories:\n\n  * qualitative: for categorical properties that have no intrinsic ordering. The `Paired` palette supports up to 6 categories that each fall into two subcategories - such as _before_ and _after_ , _with_ and _without_ treatment, etc.\n\n  * sequential: for quantitative properties that go from _low_ to _high_\n\n  * diverging: for quantitative properties for which there is a natural midpoint or neutral value, and whose value can deviate both up- and down; weâ€™ll see an example in Figure 3.41.\n\nTo obtain the colors from a particular palette we use the function\n`brewer.pal`. Its first argument is the number of colors we want (which can be\nless than the available maximum number in `brewer.pal.info`).\n\n    \n    \n    brewer.pal(4, \"RdYlGn\")__\n    \n    \n    [1] \"#D7191C\" \"#FDAE61\" \"#A6D96A\" \"#1A9641\"\n\nIf we want more than the available number of preset colors (for example so we\ncan plot a heatmap with continuous colors) we can interpolate using the\n`colorRampPalette` function15.\n\n15 `colorRampPalette` returns a function of one parameter, an integer. In the\ncode shown, we call that function with the argument `100`.\n\n    \n    \n    mypalette  = colorRampPalette(\n        c(\"darkorange3\", \"white\",\"darkblue\")\n      )(100)\n    head(mypalette)__\n    \n    \n    [1] \"#CD6600\" \"#CE6905\" \"#CF6C0A\" \"#D06F0F\" \"#D17214\" \"#D27519\"\n    \n    \n    image(matrix(1:100, nrow = 100, ncol = 10), col = mypalette,\n            xaxt = \"n\", yaxt = \"n\", useRaster = TRUE)__\n\n[![](03-chap_files/figure-html/fig-graphics-\ncolorRampPalette-1.png)](03-chap_files/figure-html/fig-graphics-\ncolorRampPalette-1.png \"FigureÂ 3.40: A quasi-continuous color palette derived\nby interpolating between the colors darkorange3, white and darkblue.\")\n\nFigure 3.40: A quasi-continuous color palette derived by interpolating between\nthe colors `darkorange3`, `white` and `darkblue`.\n\n## 3.10 Heatmaps\n\nHeatmaps are a powerful way of visualizing large, matrix-like datasets and\nproviding a quick overview of the patterns that might be in the data. There\nare a number of heatmap drawing functions in R; one that is convenient and\nproduces a good-looking output is the function `pheatmap` from the eponymous\npackage16. In the code below, we first select the top 500 most variable genes\nin the dataset `x` and define a function `rowCenter` that centers each gene\n(row) by subtracting the mean across columns. By default, `pheatmap` uses the\n_RdYlBu_ color palette from\n**[RcolorBrewer](https://cran.r-project.org/web/packages/RcolorBrewer/)** in\nconjuction with the `colorRampPalette` function to interpolate the 11 colors\ninto a smooth-looking palette (Figure 3.41).\n\n16 A very versatile and modular alternative is the\n**[ComplexHeatmap](https://bioconductor.org/packages/ComplexHeatmap/)**\npackage.\n\n    \n    \n    library(\"pheatmap\")\n    topGenes = order(rowVars(Biobase::exprs(x)), decreasing = TRUE)[1:500]\n    rowCenter = function(x) { x - rowMeans(x) }\n    pheatmap(rowCenter(dfx[topGenes, ]), \n      show_rownames = FALSE, \n      show_colnames = FALSE, \n      breaks = seq(-5, +5, length = 101),\n      annotation_col = pData(x)[, c(\"sampleGroup\", \"Embryonic.day\", \"ScanDate\", \"genotype\") ],\n      annotation_colors = list(\n        sampleGroup = groupColor,\n        genotype = c(`FGF4-KO` = \"chocolate1\", `WT` = \"azure2\"),\n        Embryonic.day = setNames(brewer.pal(9, \"Blues\")[c(3, 6, 9)], c(\"E3.25\", \"E3.5\", \"E4.5\")),\n        ScanDate = setNames(brewer.pal(nlevels(x$ScanDate), \"YlGn\"), levels(x$ScanDate))\n      )\n    )__\n\n[![](03-chap_files/figure-html/fig-graphics-\nheatmap-1.png)](03-chap_files/figure-html/fig-graphics-heatmap-1.png\n\"FigureÂ 3.41: A heatmap of relative expression values, i.e., logarithmic fold\nchange compared to the average expression of that gene \\(row\\) across all\nsamples \\(columns\\). The color scale uses a diverging palette whose midpoint\nis at 0.\")\n\nFigure 3.41: A heatmap of relative expression values, i.e., logarithmic fold\nchange compared to the average expression of that gene (row) across all\nsamples (columns). The color scale uses a diverging palette whose midpoint is\nat 0.\n\nLetâ€™s take a minute to deconstruct this rather massive-looking call to\n`pheatmap`. The options `show_rownames` and `show_colnames` control whether\nthe row and column names are printed at the sides of the matrix. Because our\nmatrix is large in relation to the available plotting space, the labels would\nnot be readable, so we might as well suppress them. The `annotation_col`\nargument takes a data frame that carries additional information about the\nsamples. The information is shown in the colored bars on top of the heatmap.\nThere is also a similar `annotation_row` argument, which we havenâ€™t used here,\nto annotate the rows (genes) with colored bars at the side. The argument\n`annotation_colors` is a list of named vectors by which we can override the\ndefault choice of colors for the annotation bars. The `pheatmap` function has\nmany further options, and if you want to use it for your own data\nvisualizations, itâ€™s worth studying them.\n\n### 3.10.1 Dendrogram ordering\n\nIn Figure 3.41, the trees at the left and the top represent the result of a\nhierarchical clustering algorithm and are also called **dendrograms**. The\nordering of the rows and columns is based on the dendrograms. It has an\nenormous effect on the visual impact of the heatmap. However, it can be\ndifficult to decide which of the apparent patterns are real and which are\nconsequences of arbitrary tree layout decisions17. Letâ€™s keep in mind that:\n\n17 We will learn about clustering and methods for evaluating cluster\nsignificance in [Chapter 5](05-chap.html).\n\n  * Ordering the rows and columns by cluster dendrogram (as in Figure 3.41) is an arbitrary choice, and you could just as well make others.\n\n  * Even if you settle on dendrogram ordering, there is an essentially arbitrary choice at each internal branch, as each branch could be flipped without changing the topology of the tree (see also [Figure 5.21](05-chap.html#fig-mobile)).\n\n__\n\nQuestion 3.6\n\nHow does the `pheatmap` function deal with the decision of how to pick which\nbranches of the subtree go left and right?\n\n__\n\nSolution\n\n__\n\nThis is described in the manual page of the `hclust` function in the\n**[stats](https://cran.r-project.org/web/packages/stats/)** package, which, by\ndefault, is used by `pheatmap`.\n\n__\n\nQuestion 3.7\n\nWhat other ordering methods can you think of?\n\n__\n\nSolution\n\n__\n\nAmong the methods proposed is the travelling salesman problem ([McCormick Jr,\nSchweitzer, and White 1972](16-chap.html#ref-McCormick:1972:MatrixClustering))\nor projection on the first principal component (for instance, see the examples\nin the manual page of `pheatmap`).\n\n__\n\nQuestion 3.8\n\nCheck the argument `clustering_callback` of the `pheatmap` function.\n\n### 3.10.2 Color spaces\n\nColor perception in humans ([Helmholtz 1867](16-chap.html#ref-Helmholtz:1867))\nis three-dimensional18. There are different ways of parameterizing this space.\nAbove we already encountered the RGB color model, which uses three values in\n[0,1], for instance at the beginning of Section 3.4, where we printed out the\ncontents of `groupColor`:\n\n18 Physically, there is an infinite number of wave-lengths of light and an\ninfinite number of ways of mixing them, so for other species, or robots, color\nspace can have fewer or more dimensions.\n\n    \n    \n    groupColor[1]__\n    \n    \n        E3.25 \n    \"#CAB2D6\" \n\nHere, CA is the hexadecimal representation for the strength of the red color\nchannel, B2 of the green and D6 of the blue color channel. In decimal, these\nnumbers are 202, 178 and 214. The range of these values goes from to 0 to 255,\nso by dividing by this maximum value, an RGB triplet can also be thought of as\na point in the three-dimensional unit cube.\n\n[![](03-chap_files/figure-html/fig-graphics-hcl-1.png)](03-chap_files/figure-\nhtml/fig-graphics-hcl-1.png \"FigureÂ 3.42Â \\(a\\): \")\n\n(a)\n\n[![](03-chap_files/figure-html/fig-graphics-hcl-2.png)](03-chap_files/figure-\nhtml/fig-graphics-hcl-2.png \"FigureÂ 3.42Â \\(b\\): \")\n\n(b)\n\nFigure 3.42: Circles in HCL colorspace. (a) Luminance \\\\(L\\\\) fixed at\n\\\\(75\\\\), while the angular coordinate \\\\(H\\\\) (hue) varies from 0 to 360 and\nthe radial coordinate \\\\(C\\\\) takes the values \\\\(0, 10, ..., 60\\\\). (b)\nConstant chroma \\\\(C\\\\) at \\\\(50\\\\), \\\\(H\\\\) as above, and the radial\ncoordinate is luminance \\\\(L\\\\) at values \\\\(10, 20, ..., 90\\\\).\n\nThe function `hcl` uses a different coordinate system. Again this consists of\nthree coordinates: hue \\\\(H\\\\), an angle in the range \\\\([0, 360]\\\\), chroma\n\\\\(C\\\\), a positive number, and luminance \\\\(L\\\\), a value in \\\\([0, 100]\\\\).\nThe upper bound for \\\\(C\\\\) depends on on hue and luminance.\n\nThe `hcl` function corresponds to polar coordinates in the CIE-LUV19 and is\ndesigned for area fills. By keeping chroma and luminance coordinates constant\nand only varying hue, it is easy to produce color palettes that are harmonious\nand avoid irradiation illusions that make light colored areas look bigger than\ndark ones. Our attention also tends to get drawn to loud colors, and fixing\nthe value of chroma makes the colors equally attractive to our eyes.\n\n19 CIE: Commission Internationale de lâ€™Ã‰clairage â€“ see e.g. Wikipedia for more\non this.\n\nThere are many ways of choosing colors from a color wheel. _Triads_ are three\ncolors chosen equally spaced around the color wheel; for example,\n\\\\(H=0,120,240\\\\) gives red, green, and blue. _Tetrads_ are four equally\nspaced colors around the color wheel, and some graphic artists describe the\neffect as â€œdynamicâ€. _Warm colors_ are a set of equally spaced colors close to\nyellow, _cool colors_ a set of equally spaced colors close to blue. _Analogous\ncolor_ sets contain colors from a small segment of the color wheel, for\nexample, yellow, orange and red, or green, cyan and blue. _Complementary\ncolors_ are colors diametrically opposite each other on the color wheel. A\ntetrad is two pairs of complementaries. _Split complementaries_ are three\ncolors consisting of a pair of complementaries, with one partner split equally\nto each side, for example, \\\\(H=60,\\,240-30,\\,240+30\\\\). This is useful to\nemphasize the difference between a pair of similar categories and a third\ndifferent one. A more thorough discussion is provided in the references\n([Mollon 1995](16-chap.html#ref-Mollon:1995); [Ihaka 2003](16-chap.html#ref-\nIhakaColorPres)).\n\n#### Lines versus areas\n\nFor lines and points, we want a strong contrast to the background, so on a\nwhite background, we want them to be relatively dark (low luminance \\\\(L\\\\)).\nFor area fills, lighter, more pastel-type colors with low to moderate\nchromatic content are usually more pleasant.\n\n## 3.11 Data transformations\n\nPlots in which most points are huddled up in one area, with much of the\navailable space sparsely populated, are difficult to read. If the histogram of\nthe marginal distribution of a variable has a sharp peak and then long tails\nto one or both sides, transforming the data can be helpful. These\nconsiderations apply both to `x` and `y` aesthetics, and to color scales. In\nthe plots of this chapter that involved the microarray data, we used the\nlogarithmic transformation20 â€“ not only in scatterplots like Figure 3.27 for\nthe \\\\(x\\\\) and \\\\(y\\\\)-coordinates, but also in Figure 3.41 for the color\nscale that represents the expression fold changes. The logarithm\ntransformation is attractive because it has a definitive meaning - a move up\nor down by the same amount on a log-transformed scale corresponds to the same\nmultiplicative change on the original scale: \\\\(\\log(ax)=\\log a+\\log x\\\\).\n\n20 We used it implicitly since the data in the _ExpressionSet_ object `x`\nalready come log-transformed.\n\nSometimes the logarithm however is not good enough, for instance when the data\ninclude zero or negative values, or when even on the logarithmic scale the\ndata distribution is highly uneven. From the upper panel of Figure 3.43, it is\neasy to take away the impression that the distribution of `M` depends on `A`,\nwith higher variances for lower `A`. However, this is entirely a visual\nartefact, as the lower panel confirms: the distribution of `M` is independent\nof `A`, and the apparent trend we saw in the upper panel was caused by the\nhigher point density at smaller `A`.\n\n    \n    \n    gg = ggplot(tibble(A = Biobase::exprs(x)[, 1], M = rnorm(length(A))),\n                aes(y = M))\n    gg + geom_point(aes(x = A), size = 0.2)\n    gg + geom_point(aes(x = rank(A)), size = 0.2)__\n\n[![](03-chap_files/figure-html/fig-graphics-MA-1.png)](03-chap_files/figure-\nhtml/fig-graphics-MA-1.png \"FigureÂ 3.43Â \\(a\\): \")\n\n(a)\n\n[![](03-chap_files/figure-html/fig-graphics-MA-2.png)](03-chap_files/figure-\nhtml/fig-graphics-MA-2.png \"FigureÂ 3.43Â \\(b\\): \")\n\n(b)\n\nFigure 3.43: The effect of rank transformation on the visual perception of\ndependency.\n\n__\n\nQuestion 3.9\n\nCan the visual artefact be avoided by using a density- or binning-based\nplotting method, as in Figure 3.31?\n\n__\n\nQuestion 3.10\n\nCan the rank transformation also be applied when choosing color scales e.g.\nfor heatmaps? What does _histogram equalization_ in image processing do?\n\n## 3.12 Mathematical symbols and other fonts\n\nWe can use mathematical notation in plot labels, using a notation that is a\nmix of R syntax and LaTeX-like notation (see `help(\"plotmath\")` for details):\n\n[![](imgs/chap3-ecdfs-bauhaus93font.png)](imgs/chap3-ecdfs-bauhaus93font.png\n\"FigureÂ 3.44: As FigureÂ fig-graphics-onedecdf, with font â€œBauhaus 93â€.\")\n\nFigure 3.44: As Figure 3.24, with font â€œBauhaus 93â€.\n\n    \n    \n    volume = function(rho, nu)\n                pi^(nu/2) * rho^nu / gamma(nu/2+1)\n    \n    ggplot(tibble(nu    = 1:15,\n      Omega = volume(1, nu)), aes(x = nu, y = Omega)) +\n    geom_line() +\n    xlab(expression(nu)) + ylab(expression(Omega)) +\n    geom_text(label =\n    \"Omega(rho,nu)==frac(pi^frac(nu,2)~rho^nu, Gamma(frac(nu,2)+1))\",\n      parse = TRUE, x = 6, y = 1.5)__\n\n[![](03-chap_files/figure-html/fig-graphics-\nmathnot-1.png)](03-chap_files/figure-html/fig-graphics-mathnot-1.png\n\"FigureÂ 3.45: Volume \\\\Omega of the \\\\nu-dimensional sphere with radius\n\\\\rho=1, for \\\\nu=1,...,15.\")\n\nFigure 3.45: Volume \\\\(\\Omega\\\\) of the \\\\(\\nu\\\\)-dimensional sphere with\nradius \\\\(\\rho=1\\\\), for \\\\(\\nu=1,...,15\\\\).\n\nThe result is shown in Figure 3.45. Itâ€™s also easy to switch to other fonts,\nfor instance the serif font Times (Figure 3.46).\n\n    \n    \n    ggplot(genes, aes( x = value, color = gene)) + stat_ecdf() +\n      theme(text = element_text(family = \"Times\"))__\n\n[![](03-chap_files/figure-html/fig-graphics-\ntimesfont-1.png)](03-chap_files/figure-html/fig-graphics-timesfont-1.png\n\"FigureÂ 3.46: As FigureÂ fig-graphics-onedecdf, with a different font.\")\n\nFigure 3.46: As Figure 3.24, with a different font.\n\nIn fact, the set of fonts that can be used with a standard R installation are\nlimited, but luckily there is the package\n**[extrafont](https://cran.r-project.org/web/packages/extrafont/)** , which\nfacilitates using fonts other than Râ€™s standard set of PostScript fonts.\nThereâ€™s some extra work needed before we can use it, since fonts external to R\nfirst need to be made known to it. They could come shipped with your operating\nsystem, with a word processor or with another graphics application. The set of\nfonts available and their physical location is therefore not standardized, but\nwill depend on your operating system and further configurations. In the first\nsession after attaching the\n**[extrafont](https://cran.r-project.org/web/packages/extrafont/)** package,\nyou will need to run the function `font_import` to import fonts and make them\nknown to the package. Then in each session in which you want to use them, you\nneed to call the `loadfonts` function to register them with one or more of Râ€™s\ngraphics devices. Finally you can use the `fonttable` function to list the\navailable fonts. You will need to refer to the documentation of the\n**[extrafonts](https://cran.r-project.org/web/packages/extrafonts/)** package\nto see how to make this work on your machine.\n\n__\n\nTask\n\nUse the package\n**[extrafont](https://cran.r-project.org/web/packages/extrafont/)** to produce\na version of Figure 3.46 with the font â€œBauhaus 93â€ (or another one available\non your system).\n\n## 3.13 Genomic data\n\n[![](imgs/EBI-genomebrowser-rnaseq.png)](imgs/EBI-genomebrowser-rnaseq.png\n\"FigureÂ 3.47: Screenshot from Ensembl genome browser, showing gene annotation\nof a genomic region as well as a read pile-up visualization of an RNA-Seq\nexperiment.\")\n\nFigure 3.47: Screenshot from Ensembl genome browser, showing gene annotation\nof a genomic region as well as a read pile-up visualization of an RNA-Seq\nexperiment.\n\nTo visualize genomic data, in addition to the general principles we have\ndiscussed in this chapter, there are some specific considerations. The data\nare usually associated with genomic coordinates. In fact genomic coordinates\noffer a great organizing principle for the integration of genomic data. You\nwill probably have seen genome browser displays such as in Figure 3.47. Here\nwe will briefly show how to produce such plots programmatically, using your\ndata as well as public annotation. It will be a short glimpse, and we refer to\nresources such as [Bioconductor](https://www.bioconductor.org) for a fuller\npicture.\n\nThe main challenge of genomic data visualization is the size of genomes. We\nneed visualizations at multiple scales, from whole genome down to the\nnucleotide level. It should be easy to zoom in and and out, and we may need\ndifferent visualization strategies for the different size scales. It can be\nconvenient to visualize biological molecules (genomes, genes, transcripts,\nproteins) in a linear manner, although their embedding in the 3D physical\nworld can matter (a great deal).\n\nLetâ€™s start with some fun examples, an ideogram plot of human chromosome 1\n(Figure 3.48) and a plot of the genome-wide distribution of RNA editing sites\n(Figure 3.49).\n\n    \n    \n    library(\"ggbio\")\n    data(\"hg19IdeogramCyto\", package = \"biovizBase\")\n    plotIdeogram(hg19IdeogramCyto, subchr = \"chr1\")__\n\n[![](03-chap_files/figure-html/fig-graphics-\nideogram-1-1.png)](03-chap_files/figure-html/fig-graphics-ideogram-1-1.png\n\"FigureÂ 3.48: Chromosome 1 of the human genome: ideogram plot.\")\n\nFigure 3.48: Chromosome 1 of the human genome: ideogram plot.\n\nThe `darned_hg19_subset500` lists a selection of 500 RNA editing sites in the\nhuman genome. It was obtained from the _Database of RNA editing in Flies, Mice\nand Humans_ (DARNED, <https://darned.ucc.ie/>). The result is shown in Figure\n3.49.\n\n    \n    \n    library(\"GenomicRanges\")\n    data(\"darned_hg19_subset500\", package = \"biovizBase\")\n    autoplot(darned_hg19_subset500, layout = \"karyogram\",\n             aes(color = exReg, fill = exReg))__\n\n[![](03-chap_files/figure-html/fig-graphics-\ndarned1-1.png)](03-chap_files/figure-html/fig-graphics-darned1-1.png\n\"FigureÂ 3.49: Karyogram with RNA editing sites. exReg indicates whether a site\nis in the coding region \\(C\\), 3â€™- or 5â€™-UTR.\")\n\nFigure 3.49: Karyogram with RNA editing sites. `exReg` indicates whether a\nsite is in the coding region (C), 3â€™- or 5â€™-UTR.\n\n__\n\nQuestion 3.11\n\nHow do you fix the ordering of the chromosomes in Figure 3.49 and get rid of\nthe warning about chromosome lengths?\n\n__\n\nSolution\n\n__\n\nThe information on chromosome lengths in the hg19 assembly of the human genome\nis (for instance) stored in the `ideoCyto` dataset. We use the function\n`keepSeqlevels` to reorder the chromosomes. See Figure 3.50.\n\n    \n    \n    data(\"ideoCyto\", package = \"biovizBase\")\n    dn = darned_hg19_subset500\n    seqlengths(dn) = seqlengths(ideoCyto$hg19)[names(seqlengths(dn))]\n    dn = keepSeqlevels(dn, paste0(\"chr\", c(1:22, \"X\")))\n    autoplot(dn, layout = \"karyogram\", aes(color = exReg, fill = exReg))__\n\n[![](03-chap_files/figure-html/fig-graphics-\ndarned2-1.png)](03-chap_files/figure-html/fig-graphics-darned2-1.png\n\"FigureÂ 3.50: Improved version of FigureÂ fig-graphics-darned1.\")\n\nFigure 3.50: Improved version of Figure 3.49.\n\n__\n\nQuestion 3.12\n\nWhat type of object is `darned_hg19_subset500`?\n\n__\n\nSolution\n\n__\n\n    \n    \n    darned_hg19_subset500[1:2,]__\n    \n    \n    GRanges object with 2 ranges and 10 metadata columns:\n          seqnames    ranges strand |       inchr       inrna         snp\n             <Rle> <IRanges>  <Rle> | <character> <character> <character>\n      [1]     chr5  86618225      - |           A           I        <NA>\n      [2]     chr7  99792382      - |           A           I        <NA>\n                 gene      seqReg       exReg      source      ests      esta\n          <character> <character> <character> <character> <integer> <integer>\n      [1]        <NA>           O        <NA>    amygdala         0         0\n      [2]        <NA>           O        <NA>        <NA>         0         0\n               author\n          <character>\n      [1]    15342557\n      [2]    15342557\n      -------\n      seqinfo: 23 sequences from an unspecified genome; no seqlengths\n\nIt is a _GRanges_ object, that is, a specialized class from the Bioconductor\nproject for storing data that are associated with genomic coordinates. The\nfirst three columns are obligatory: `seqnames`, the name of the containing\nbiopolymer (in our case, these are names of human chromosomes), `ranges`, the\ngenomic coordinates of the intervals (in this case, the intervals all have\nlength 1, as they each refer to a single nucleotide), and the DNA `strand`\nfrom which the RNA is transcribed. You can find out more on how to use this\nclass and its associated infrastructure in the documentation, e.g., the\nvignette of the\n**[GenomicRanges](https://bioconductor.org/packages/GenomicRanges/)** package.\nLearning it is worth the effort if you want to work with genome-associated\ndatasets, as it allows for convenient, efficient and safe manipulation of\nthese data and provides many powerful utilities.\n\n## 3.14 Summary of this chapter\n\nVisualizing data, either â€œrawâ€ or along the various steps of processing,\nsummarization and inference, is one of the most important activities in\napplied statistics, and indeed, in science. It sometimes gets short shrift in\ntextbooks since there is not much deductive theory. However, there is a large\nnumber of good (and bad) practices, and once you pay attention to it, you will\nquickly see whether a certain graphic is effective in conveying its message,\nor what choices you could make to create powerful and aesthetically attrative\ndata visualizations. Among the important options are the plot type (what is\ncalled a `geom` in\n**[ggplot2](https://cran.r-project.org/web/packages/ggplot2/)**), proportions\n(incl. aspect ratios) and colors. The _grammar of graphics_ is a powerful set\nof concepts to reason about graphics and to communicate our intentions for a\ndata visualization to a computer.\n\nAvoid _laziness_ â€”just using the softwareâ€™s defaults without thinking about\nthe optionsâ€”, and avoid _getting carried away_ â€”adding lots of visual candy\nthat just clutters up the plot but has no real message. Creating your own\nvisualizations is in many ways like good writing. It is extremely important to\nget your message across (in talks, in papers), but there is no simple recipe\nfor it. Look carefully at lots of visualizations made by others, experiment\nwith making your own visualizations to learn the ropes, and then decide what\nis your style.\n\n## 3.15 Further reading\n\nThe most useful resources about\n**[ggplot2](https://cran.r-project.org/web/packages/ggplot2/)** are the second\nedition of Wickham ([2016](16-chap.html#ref-ggplot2)) and the\n[ggplot2](https://ggplot2.tidyverse.org) website. There are many\n**[ggplot2](https://cran.r-project.org/web/packages/ggplot2/)** code snippets\nonline, which you will find through search engines after some practice. But be\ncritical and check your sources: sometimes, code examples you find online\nrefer to outdated versions of the package, and sometimes they are of poor\nquality.\n\nThe foundation of the system is based on Wilkinson ([2005](16-chap.html#ref-\nGrofGrbook)) and the ideas by Tukey ([1977](16-chap.html#ref-Tukey77);\n[William S. Cleveland 1988](16-chap.html#ref-Tukey:1988)).\n\n## 3.16 Exercises\n\n__\n\nExercise 3.1\n\nUse _themes_ to change the visual appearance of your plots. Start by running\nthe following example:\n\n    \n    \n    ggcars = ggplot(mtcars, aes(x = hp, y = mpg)) + geom_point()\n    ggcars\n    ggcars + theme_bw()\n    ggcars + theme_minimal()__\n\nWhat other themes are there? (Hint: have a look at the section for themes in\nthe [online documentation of\nggplot2](https://ggplot2.tidyverse.org/reference).) Are these all the themes?\n(Hint: have a look at the\n**[ggthemes](https://cran.r-project.org/web/packages/ggthemes/)** package.)\nMake a version of the above plot in the style of the _Economist_ magazine. Add\na smoothing line\n\n__\n\nExercise 3.2\n\nWhat are admissible _color names_ in base R? Have a look at the manual page of\nthe `colors` function. Ryun the examples and the demo.\n\nUse an internet search engine to search for â€œR color namesâ€ and explore some\nof the resources that come up, e.g., cheat sheets with all the colors\ndiplayed.\n\nProduce a version of the heatmap in Figure 3.41 that uses a color palette from\nthe [R package **beyonce**](https://github.com/dill/beyonce).\n\n__\n\nExercise 3.3\n\nCreate plots in the style of the [xkcd](https://xkcd.com) webcomic. Have a\nlook at\n\n  * a thread on Stackoverflow titled [How can we make xkcd style graphs?](https://stackoverflow.com/questions/12675147/how-can-we-make-xkcd-style-graphs)\n\n  * the R source code of this book for the code that produces the chapterâ€™s opening figure,\n\n  * the vignette of the **[xkcd](https://cran.r-project.org/web/packages/xkcd/)** package.\n\n![](imgs/xkcdgraph.png)\n\n__\n\nExercise 3.4\n\nCheck out the **[shiny](https://cran.r-project.org/web/packages/shiny/)**\ntutorials on the RStudio website. Write a _shiny app_ that displays one of the\nplots from this chapter, but with interactive elements to control, e.g., which\ngenes are displayed (Figures 3.33â€”3.35).\n\n__\n\nExercise 3.5\n\nWhat options are there for _serializing_ a graphic, i.e., for storing a\ngraphic in a file that you can save for later use, or load up in another\nsoftware? How can you serialize interactive graphics?\n\n__\n\nExercise 3.6\n\nImportant and well done graphics do not have to be complex. For instance,\ncheck out Figure 9 (page 82) of the [public assessment report by the European\nMedicines Agency on Comirnaty](extras/comirnaty-epar-public-assessment-\nreport_en.pdf)21 and [XKCD 2400](https://xkcd.com/2400/).\n\n21 You can also get this from\n<https://www.ema.europa.eu/en/medicines/human/EPAR/comirnaty>.\n\nCarr, Daniel B, Richard J Littlefield, WL Nicholson, and JS Littlefield. 1987.\nâ€œScatterplot Matrix Techniques for Large N.â€ _Journal of the American\nStatistical Association_ 82 (398): 424â€“36.\n\nCleveland, William S. 1988. _The Collected Works of John w. Tukey: Graphics\n1965-1985_. Vol. 5. CRC Press.\n\nCleveland, William S., Marylyn E. McGill, and Robert McGill. 1988. â€œThe Shape\nParameter of a Two-Variable Graph.â€ _Journal of the American Statistical\nAssociation_ 83: 289â€“300.\n\nHelmholtz, H. von. 1867. _Handbuch Der Physiologischen Optik_. Leipzig:\nLeopold Voss.\n\nIhaka, Ross. 2003. â€œColor for Presentation Graphics.â€ In _Proceedings of the\n3rd International Workshop on Distributed Statistical Computing_ , edited by\nKurt Hornik and Friedrich Leisch. Vienna, Austria:\nhttp://www.r-project.org/conferences/DSC-2003/Proceedings/; ISSN 1609-395X.\n\nIrizarry, R. A., B. Hobbs, F. Collin, Y. D. Beazer-Barclay, K. J. Antonellis,\nU. Scherf, and T. P. Speed. 2003. â€œExploration, Normalization, and Summaries\nof High Density Oligonucleotide Array Probe Level Data.â€ _Biostatistics_ 4\n(2): 249â€“64.\n\nLawrence, Michael S., Petar Stojanov, Paz Polak, Gregory V. Kryukov, Kristian\nCibulskis, Andrey Sivachenko, Scott L. Carter, et al. 2013. â€œMutational\nHeterogeneity in Cancer and the Search for New Cancer-Associated Genes.â€\n_Nature_ 499 (7457): 214â€“18. <https://doi.org/10.1038/nature12213>.\n\nMcCormick Jr, William T, Paul J Schweitzer, and Thomas W White. 1972. â€œProblem\nDecomposition and Data Reorganization by a Clustering Technique.â€ _Operations\nResearch_ 20 (5): 993â€“1009.\n\nMollon, John. 1995. â€œSeeing Colour.â€ In _Colour: Art and Science_ , edited by\nT. Lamb and J. Bourriau. Cambridge Unversity Press.\n\nOhnishi, Y., W. Huber, A. Tsumura, M. Kang, P. Xenopoulos, K. Kurimoto, A. K.\nOles, et al. 2014. â€œCell-to-Cell Expression Variability Followed by Signal\nReinforcement Progressively Segregates Early Mouse Lineages.â€ _Nature Cell\nBiology_ 16 (1): 27â€“37.\n\nTukey, John W. 1977. â€œExploratory Data Analysis.â€ _Massachusetts: Addison-\nWesley_.\n\nWickham, Hadley. 2010. â€œA Layered Grammar of Graphics.â€ _Journal of\nComputational and Graphical Statistics_ 19 (1): 3â€“28.\n\nâ€”â€”â€”. 2016. _Ggplot2: Elegant Graphics for Data Analysis_. Springer New York.\n<http://had.co.nz/ggplot2/book>.\n\nWilkinson, Leland. 1999. â€œDot Plots.â€ _The American Statistician_ 53 (3): 276.\n\nâ€”â€”â€”. 2005. _The Grammar of Graphics_. Springer.\n\nPage built at 01:33 on 2025-09-01 using R version 4.5.1 (2025-06-13)\n\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["msmb.css"],"toc":true,"output-file":"03-chap.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.32","theme":"cosmo"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}