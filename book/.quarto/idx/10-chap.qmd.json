{"title":"10.1 Goals for this chapter","markdown":{"headingText":"10.1 Goals for this chapter","containsRefs":false,"markdown":"![](imgs/Darwin_Tree_1837_web.png)\n\nNetworks and trees are often used to represent knowledge about a biological\nsystem. They can also be used to directly encode observations from an\nexperiment or study. Phylogenetic trees were drawn to represent family and\nsimilarity relationships between species, even before Darwin’s famous notebook\nsketch that gave these trees a mechanistic, causal interpretation. The meaning\nof the nodes and edges in a network can differ, and needs to be specified. For\ninstance, a network might schematize relationships between proteins, such as\nin Figure 10.1, where the nodes could stand for genes or their encoded\nproteins, and edges could be direct physical interactions or more abstract\n“functional” or “genetic” interactions representing outcomes from an\nexperiment. In this book, we use the terms _graph_ and _network_ largely\nexchangeably. The former term is a bit more evocative of the mathematical\nstructure, the latter of the biological interpretation.\n\n[![](10-chap_files/figure-html/fig-chemo-1.png)](10-chap_files/figure-\nhtml/fig-chemo-1.png \"Figure 10.1: A small protein-protein network that\nrepresents pairwise relationships between proteins.\")\n\nFigure 10.1: A small protein-protein network that represents pairwise\nrelationships between proteins.\n\nWe saw in [Chapter 2](02-chap.html) that we could model sequences of state\ntransitions as a Markov chain, which can be represented as directed graphs\nwith weights on the edges. Metabolic pathways in which nodes are chemical\nmetabolites and the edges represent chemical reactions. Mutation history trees\nare used in cancer genomics to represent lineages of mutations.\n\nTransmission networks are important in studying the epidemiology of infectious\ndiseases. As real networks can be very large, we will need special methods for\nrepresenting and visualizing them. This chapter will be focused on ways of\nintegrating graphs into a data analytic workflow.\n\n\nIn this chapter we will\n\n  * Use the formal definition of a graph’s components: edges, vertices, layout to see how we can manipulate them in R using both adjacency matrices and lists of edges.\n\n  * We will transform a graph object from **[igraph](https://cran.r-project.org/web/packages/igraph/)** into an object that can be visualized according to the layers approach in **[ggplot2](https://bioconductor.org/packages/ggplot2/)** using **[ggraph](https://cran.r-project.org/web/packages/ggraph/)**. We will experiment with covariates that we attach to graph edges and nodes.\n\n  * Graphs are useful ways of encoding prior knowledge about a system, and we will see how they enable us to go from simple gene set analyses to meaningful biological recommendations by mapping significance scores onto the network to detect perturbation _hotspots_.\n\n  * We will build phylogenetic trees starting with from DNA sequences and then visualize these trees with the specifically designed R packages **[ape](https://cran.r-project.org/web/packages/ape/)** and **[ggtree](https://cran.r-project.org/web/packages/ggtree/)**.\n\n  * We will combine a phylogenetic tree built from microbiome 16S rRNA data with covariates to show how the hierarchical relationship between taxa can increase the power in multiple hypothesis testing.\n\n  * A special tree called a minimum spanning tree (MST) is very useful for testing the relations between a graph and other covariates. We’ll see how to implement different versions of what is known as the Friedman-Rafsky test. We’ll study both co-occurrence of bacteria in mice litters and strain similarities in HIV contagion networks.\n\n## 10.2 Graphs\n\n### 10.2.1 What is a graph and how can it be encoded?\n\nA **graph** is defined as a combination of two sets, often denoted as\n\\\\((V,E)\\\\). Here, \\\\(V\\\\) is a set of **nodes** or **vertices** , \\\\(E\\\\) is\na set of **edges** between vertices. Each element of \\\\(E\\\\) is a pair of\nnodes, i.e., consists of two elements of \\\\(V\\\\). An intuitive way to\nrepresent a graph is by its **from-to** representation. If we denote the set\nof vertices as \\\\(V=(\\text{A}, \\text{B}, \\text{C}, \\ldots)\\\\), then the from-\nto (or **edge list**) representation is a table of the following form.\n\n    \n    \n      from to\n    1    A  B\n    2    B  C\n    3    A  E\n    4    C  D\n    5    E  F\n\nThe ordering of the rows in the from-to table plays no role. In a **directed**\nor **oriented graph** , the edges are ordered pairs, i.e., the first line in\nthe above table states that there is an edge from A to B, but does not say\nwhether there is also an edge from B to A—this would need to be denoted in a\nseparate row of the table.\n\nIn an **undirected graph** , the edges are unordered pairs, i.e., an edge from\nA to B is not distinguished from an edge from B to A. Undirected graphs encode\nsymmetric relationships between the nodes, directed graphs represent\nasymmetric relationships.\n\nIt’s important not to confuse a graph with its visualization. It is possible\nto draw a graph onto a two-dimensional area like in Figure 10.1, but this is\noptional, and not unique—there are always many different ways to draw the same\ngraph. There is also no guarantee that in such a visualization, edges do not\noverlap. Depending on the graph, this can happen. Graphs do not live in\nphysical space (neither 2D nor 3D) but are literally just sets of nodes and\nedges.\n\nAn alternative representation, equivalent to the from-to table, is the\n**adjacency matrix** , a quadratic matrix with as many rows (and columns) as\nnodes in the graph. The matrix contains a non-zero entry in the \\\\(i\\\\)th row\nand \\\\(j\\\\)th column to encode that there is an edge between the \\\\(i\\\\)th and\n\\\\(j\\\\)th vertices.\n\n__\n\nQuestion 10.1\n\nFor undirected graphs, what is special about the adjacency matrix \\\\(A\\\\)?\n\n__\n\nSolution\n\n__\n\nThe adjacency matrix is symmetric, i.e., \\\\(M = M^T\\\\). An example is shown in\nFigures 10.2 and 10.3. `g1` is created from a from-to table (encoded in the\ntwo-column matrix `edges`) by the code below.\n\n    \n    \n    library(\"igraph\")\n    edges = matrix(c(1,3, 2,3, 3,4, 4,5, 4,6), byrow = TRUE, ncol = 2)\n    g1 = graph_from_edgelist(edges, directed = FALSE)\n    vertex_attr(g1, name = \"name\") = 1:6\n    plot(g1, vertex.size = 25, edge.width = 5, vertex.color = \"coral\")__\n\n[![](10-chap_files/figure-html/fig-igraphplot-1.png)](10-chap_files/figure-\nhtml/fig-igraphplot-1.png \"Figure 10.2: A small undirected graph with numbered\nnodes.\")\n\nFigure 10.2: A small undirected graph with numbered nodes.\n\n[![](10-chap_files/figure-html/fig-adjmatrix-1.png)](10-chap_files/figure-\nhtml/fig-adjmatrix-1.png \"Figure 10.3: The adjacency matrix of the graph shown\nin Figure fig-igraphplot is is a symmetric n \\\\times n matrix of 0s and 1s,\nwhere is n is the number of nodes.\")\n\nFigure 10.3: The adjacency matrix of the graph shown in Figure 10.2 is is a\nsymmetric \\\\(n \\times n\\\\) matrix of \\\\(0\\\\)s and \\\\(1\\\\)s, where is \\\\(n\\\\)\nis the number of nodes.\n\n__\n\nQuestion 10.2\n\nCan you give an alternative way to that shown in the answer to Question 10.1\nabove for creating a graph from a list of edges dataframe?\n\n__\n\nSolution\n\n__\n\n    \n    \n    edges = \"1,3\\n2,3\\n3,4\\n4,6\\n4,5\"\n    df = read.csv(textConnection(edges), header = FALSE)\n    sg = graph_from_data_frame(df, directed = FALSE)\n    sg __\n    \n    \n    IGRAPH 1467322 UN-- 6 5 -- \n    + attr: name (v/c)\n    + edges from 1467322 (vertex names):\n    [1] 1--3 2--3 3--4 4--6 4--5\n\nTypically, you would use the `read.csv` function to read the from-to table\nfrom a separate file. Here the authors of the book decided to create the\ncharacter string `edges` on the fly and to turn into a the equivalent of a\nfile using the function `textConnection`, to keep the example more compact.\nThe notation `\"\\n\"` indicates a line break.\n\n#### Elements of a simple graph\n\n  * The nodes or vertices. These are the colored circles with numbers in them in Figure 10.2.\n\n  * Edges or connections, the segments that join the nodes and which can be directed or not.\n\n  * Edge attributes, such edge length. When not specified, we suppose the edge lengths are all the same, typically, one. For instance, to compute the distance between two nodes in the graph, we sum up the lengths of the edges along the shortest path.\n\n  * Edge and node attributes: optionally, each edge or each node can be mapped to further continuous or categorical variables, such as type, color, weight, edge width, node size, \\\\(...\\\\) Pretty much anything is possible here, depending on the application and the intended computations.\n\nWe also call a directed graph with edge lengths a **network**. The adjacency\nmatric of a network is an \\\\(n\\times n\\\\) matrix of positive numbers\ncorresponding to the edge lengths.\n\n#### Basic concepts\n\nThe _degree_ of a node is the number of edges connected to it. In directed\ngraphs we differentiate between _in-degree_ and _out-degree_ for incoming and\noutgoing edges. We may further distinguish between directed graphs that\ncontain cycles and those that do not (termed cyclic and acyclic graphs).\n\nFor large graphs, on can summarize overall graph structure by looking at the\ndistributions of vertex degrees, and we can identify particularly interesting\nregions or specific nodes and edge in a graph with measures such as centrality\nand betweenness. These measures are available in various packages\n(**[network](https://cran.r-project.org/web/packages/network/)** ,\n**[igraph](https://cran.r-project.org/web/packages/igraph/)**).\n\nIf the number of edges is of the same order of magnitude as the number of\nnodes (written \\\\(\\\\#E\\sim O(\\\\#V)\\\\)), we say that the graph is **sparse**.\nSome graphs have many nodes, for instance, the package\n**[ppiData](https://bioconductor.org/packages/ppiData/)** contains a predicted\nprotein interaction (`ppipred`) graph on about 2500 proteins with around 20000\nedges1. A complete adjacency matrix for such a graph requires more than 6\nmillion memory units, of which most contain 0. This is needlessly wasteful.\nThe edge list representation of the same graph is more compact: it only uses\nstorage where there is an edge, in our example, this amounts to 20000 memory\nunits. One particular choice of edge list representation is sparse matrix\nencodings, such as implemented in the package\n**[Matrix](https://cran.r-project.org/web/packages/Matrix/)**.\n\n1 Gene and species phylogenies may even be much larger.\n\nOn the other hand, in a **dense** graph, the number of edges is of the same\norder of magnitude as the number of potential edges, i.e., the square of the\nnumber of nodes (written \\\\(\\\\#E\\sim O(\\\\#V^2)\\\\). Memory space can be an\nissue for the storage of large dense graphs.\n\n#### Graph layout\n\nWe will see several examples where the same graph is plotted in different\nways, either for aesthetic or practical reasons. This is done through the\nchoice of the **graph layout**.\n\nWhen the edges have lengths representing distances the problem of a 2D\nrepresentation of the graph is the same as the multidimensional scaling we saw\nin [Chapter 9](09-chap.html) It is often solved in a similar way by spreading\nout the vertex-points as much as possible. In the simple case of edges without\nlengths, the algorithms can choose different criteria. The method of\nFruchterman and Reingold is a basic choice. It is based on a physics-inspired\nmodel where similar points attract and repel each other as if under the effect\nof (Newtonian) physical forces.\n\n__\n\nTask\n\nUse the **[igraph](https://cran.r-project.org/web/packages/igraph/)** package\nto do the following\n\n  * Create a dense random graph with 12 nodes and more than 50 edges.\n\n  * Experiment plotting the graph with different layouts: place the nodes on a circle, or represent the graph as symmetrically as possible, avoid any overlapping nodes or edges.\n\n#### Graphs from data\n\nUsually data do not arrive in the form of graphs. Graphical or network\nrepresentations are often the result of transforming from other data types.\n\n**From distances or similarities:** graphs can simplify distance or similarity\nrelationships between objects by binarising them. Nodes are connected if they\nare similar or close, and not connected if not. Thus, the input is a\nsimilarity or distance measure between all pairs of objects of interest\n(genes, proteins, species, phenotypes, \\\\(...\\\\)), to which a threshold is\napplied. The set of measures could be realized in a dense matrix or be\ncomputed on the fly.\n\n**Bipartite graphs:** some data arrive naturally as absence or presence\nrelationships between two types of objects, for instance, finch species and\nislands in the Galapagos archipelago (Figure 10.4), or transcription factors\nand gene regulatory regions they are considered to bind to. Such relationships\ncan be encoded with 0/1 values in a rectangular matrix, where rows represent\none object type and columns the other. The resulting graph has two types of\nnodes, e.g., finch-nodes and island-nodes, and edges can only exist between\nnodes of different types, e.g., between a taxon and an island, but not between\ntaxa, nor between islands. Edges in Figure 10.4 represent _lives on_\nrelationships.\n\n[![](imgs/BipartiteTaxa.png)](imgs/BipartiteTaxa.png \"Figure 10.4: This\nbipartite graph connects each taxon to the sites where it was observed.\")\n\nFigure 10.4: This **bipartite** graph connects each taxon to the sites where\nit was observed.\n\n__\n\nQuestion 10.3\n\nLoad the `finch.csv` data and experiment plotting them to highlight that they\nrepresent a bipartite network.\n\n__\n\nSolution\n\n__\n\nThe output of the following code is shown in Figure 10.5.\n\n    \n    \n    finch = readr::read_csv(\"../data/finch.csv\", comment = \"#\", col_types = \"cc\")\n    finch __\n    \n    \n    # A tibble: 122 × 2\n       .tail .head             \n       <chr> <chr>             \n     1 C     Large ground finch\n     2 D     Large ground finch\n     3 E     Large ground finch\n     4 F     Large ground finch\n     5 G     Large ground finch\n     6 H     Large ground finch\n     7 I     Large ground finch\n     8 J     Large ground finch\n     9 L     Large ground finch\n    10 M     Large ground finch\n    # ℹ 112 more rows\n    \n    \n    library(\"network\")\n    finch.nw  = as.network(finch, bipartite = TRUE, directed = FALSE)\n    is.island = nchar(network.vertex.names(finch.nw)) == 1\n    plot(finch.nw, vertex.cex = 2.5, displaylabels = TRUE, \n         vertex.col = ifelse(is.island, \"forestgreen\", \"gold3\"),\n         label= sub(\" finch\", \"\", network.vertex.names(finch.nw)))\n    finch.nw |> as.matrix() |> t() |> (\\(x) x[, order(colnames(x))])()__\n    \n    \n                              A B C D E F G H I J K L M N O P Q\n    Large ground finch        0 0 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1\n    Medium ground finch       1 1 1 1 1 1 1 1 1 1 0 1 0 1 1 0 0\n    Small ground finch        1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 0 0\n    Sharp-beaked ground finch 0 0 1 1 1 0 0 1 0 1 0 1 1 0 1 1 1\n    Cactus ground finch       1 1 1 0 1 1 1 1 1 1 0 1 0 1 1 0 0\n    Large cactus ground finch 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0\n    Large tree finch          0 0 1 1 1 1 1 1 1 0 0 1 0 1 1 0 0\n    Medium tree finch         0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0\n    Small tree finch          0 0 1 1 1 1 1 1 1 1 0 1 0 0 1 0 0\n    Vegetarian finch          0 0 1 1 1 1 1 1 1 1 0 1 0 1 1 0 0\n    Woodpecker finch          0 0 1 1 1 0 1 1 0 1 0 0 0 0 0 0 0\n    Mangrove finch            0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0\n    Warbler finch             1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n\n[![](10-chap_files/figure-html/fig-finches-1-1.png)](10-chap_files/figure-\nhtml/fig-finches-1-1.png \"Figure 10.5: The finches graph. There are many ways\nto improve the layout, including better taking into account the bipartite\nnature of the graph.\")\n\nFigure 10.5: The `finches` graph. There are many ways to improve the layout,\nincluding better taking into account the bipartite nature of the graph.\n\n__\n\nQuestion 10.4\n\nMake a plot of the graph `g1` using the\n**[ggraph](https://cran.r-project.org/web/packages/ggraph/)** package, with a\nchoice of layout and provided geoms such as `geom_edge_link`,\n`geom_node_point` and `geom_node_text`.\n\n__\n\nSolution\n\n__\n\nThe output of the following code is shown in Figure 10.6.\n\n    \n    \n    library(\"ggraph\")\n    ggraph(g1, layout = \"nicely\") + \n      geom_edge_link() + \n      geom_node_point(size=6,color=\"#8856a7\") + \n      geom_node_text(label=vertex_attr(g1)$name,  color=\"white\")__\n\n[![](10-chap_files/figure-html/fig-\nggnetworkong1-1-1.png)](10-chap_files/figure-html/fig-ggnetworkong1-1-1.png\n\"Figure 10.6: A ggraph example.\")\n\nFigure 10.6: A **[ggraph](https://cran.r-project.org/web/packages/ggraph/)**\nexample.\n\n#### An example: a four state Markov chain\n\nIn [Chapter 2](02-chap.html), we saw how a Markov chain can summarize\ntransitions between nucleotides (considered the states of the system). This is\noften schematized by a graph. The\n**[igraph](https://cran.r-project.org/web/packages/igraph/)** package provides\nmany choices for graph “decoration”:\n\n    \n    \n    library(\"markovchain\")\n    statesNames = c(\"A\", \"C\", \"G\",\"T\")\n    T1MC = new(\"markovchain\", states = statesNames, transitionMatrix =\n      matrix(c(0.2,0.1,0.4,0.3,0,1,0,0,0.1,0.2,0.2,0.5,0.1,0.1,0.8,0.0),\n             nrow = 4,byrow = TRUE, dimnames = list(statesNames, statesNames)))\n    plot(T1MC, edge.arrow.size = 0.4, vertex.color = \"purple\",\n         edge.arrow.width = 2.2, edge.width = 5, edge.color = \"blue\",\n         edge.curved = TRUE, edge.label.cex = 2.5, vertex.size= 32,\n         vertex.label.cex = 3.5, edge.loop.angle = 3,\n         vertex.label.family = \"sans\", vertex.label.color = \"white\")__\n\n[![](imgs/MarkovACGT.png)](imgs/MarkovACGT.png \"Figure 10.7: A four state\nMarkov chain with arrows representing possible transitions between states.\")\n\nFigure 10.7: A four state Markov chain with arrows representing possible\ntransitions between states.\n\nMarkov chains are simple models of dynamical systems, and the states are\nrepresented by the nodes in the graph. The transition matrix gives us the\nweights on the **directed** edges (arrows) between the states.\n\n__\n\nQuestion 10.5\n\nWhich state do you think this Markov chain will end up in?\n\n__\n\nSolution\n\n__\n\nAll nodes except C have outgoing edges, C only has in-going edges and a self-\nedge. Thus, C is an absorbing state. Sooner or later any process from this\nchain ends up and stays in C.\n\n__\n\nTask\n\n  1. Try changing your `set.seed` function input and see if it changes the plot.\n\n  2. Access the help for this particular `plot` function.\n\n  3. Redo the graph and label the edges with the transition probabilities in green and vertices in brown.\n\nWe will see how to build a complete example of annotated state space Markov\nchain graph in Exercise 10.3.\n\n### 10.2.2 Graphs with many layers: labels on edges and nodes\n\nHere is an example of plotting a graph downloaded from the\n[STRING](https://string-db.org) database with annotations at the vertices.\n\n    \n    \n    datf = read.table(\"../data/string_graph.txt\", header = TRUE)\n    grs = graph_from_data_frame(datf[, c(\"node1\", \"node2\")], directed = FALSE)\n    E(grs)$weight = 1\n    V(grs)$size = centr_degree(grs)$res\n    ggraph(grs) +\n      geom_edge_arc(color = \"black\",  strength = 0.05, alpha = 0.8)+\n      geom_node_point(size = 2.5, alpha = 0.5, color = \"orange\") +\n      geom_node_label(aes(label=vertex_attr(grs)$name), size = 3, alpha = 0.9, color = \"#8856a7\", repel = TRUE) __\n\n[![](10-chap_files/figure-html/fig-\ncompletechemokine-1.png)](10-chap_files/figure-html/fig-\ncompletechemokine-1.png \"Figure 10.8: Perturbed chemokine subnetwork uncovered\nin @YuGXNA using differential gene expression patterns in sorted T-cells.\nNotice the clique-like structure of the genes CXCR3, CXCL13, CCL19, CSCR5 and\nCCR7 in the right hand corner.\")\n\nFigure 10.8: Perturbed chemokine subnetwork uncovered in Yu et al.\n([2012](16-chap.html#ref-YuGXNA)) using differential gene expression patterns\nin sorted T-cells. Notice the clique-like structure of the genes CXCR3,\nCXCL13, CCL19, CSCR5 and CCR7 in the right hand corner.\n\nFigure 10.8 shows the full perturbed chemokine subnetwork discovered in the\nstudy of breast cancer metastasis using GXNA ([Nacu et al.\n2007](16-chap.html#ref-GXNA)) and reported by Yu et al.\n([2012](16-chap.html#ref-YuGXNA)).\n\n## 10.3 From gene set enrichment to networks\n\n[![A long unstructured laundry list of possibly differentially expressed genes\ncan be daunting.](imgs/devil.png)](imgs/devil.png \"A long unstructured laundry\nlist of possibly differentially expressed genes can be daunting.\")\n\nA long unstructured laundry list of possibly differentially expressed genes\ncan be daunting.\n\nIn [Chapter 8](08-chap.html), we studied methods for finding a list of\ndifferentially expressed genes. Small sample sizes, coupled with efforts to\nmaintain low FDRs, often result in low power to detect differential\nexpression. Therefore, obtaining a long list of genes that can be confidently\ndeclared as differentially expressed is, initially, a triumph. However,\nunderstanding the underlying biology requires more than just a laundry list of\nsignificant players in a biological system.\n\n### 10.3.1 Methods using pre-defined gene sets (GSEA)\n\nOne of the earliest approaches was to look for gene attributes that are\n**overrepresented** or **enriched** in the laundry list of significant genes.\nThese gene classes are often based on Gene Ontology (GO) categories (for\nexample, genes that are involved in organ growth, or genes that are involved\nin feeding behavior). The Gene Ontology (GO) is a collection of three\nontologies that describe genes and gene products. These ontologies are\nrestricted vocabularies that have the structure of directed acyclic graphs\n(DAGS). The most specific terms are the leaves of the graph. The GO graph\nconsists of nodes (here, Gene Ontology terms) and edges from more specific\nterms (children) to less specific (parents), often these edges are directed.\nNodes and edges can have multiple attributes that can be visualized. The main\npurpose of using GO annotations for a particular set of Genes designated as\nsignificant in an experiment is to look for the **enrichment** of a GO term in\nthis list, we will give this term a statistical meaning below. Many other\nuseful lists of important gene sets exist.\n\n__\n\nTask\n\nFind a useful database of gene sets.\n\nFor instance, the `MsigDB` Molecular Signature Database ([Liberzon et al.\n2011](16-chap.html#ref-MSigDB)) contains many gene sets that can be accessed\nfrom within R using the function `getBroadSets` from the Bioconductor package\n**[GSEABase](https://bioconductor.org/packages/GSEABase/)** roughly as\nfollows:\n\n    \n    \n    library(\"GSEABase\")\n    ## This requires a login to the website.\n    fl   =  \"/path/to/msigdb_v5.1.xml\"\n    gss  =  getBroadSets(fl) \n    organism(gss[[1]])\n    table(sapply(gss, organism))__\n\n### 10.3.2 Gene set analysis with two-way table tests\n\nTable 10.1: Although there are the same number of each category of gene found\nin the _significant_ set, both the simulation below and the theory of testing\nin two-way tables shows us that the blue category is enriched.\n\n| Yellow | Blue | Red  \n---|---|---|---  \nSignificant | 25 | 25 | 25  \nUniverse | 500 | 100 | 400  \n  \nHere, we start by explaining a basic approach often called **Fisher’s “exact”\ntest** or **hypergeometric test** ing.\n\n[![So-called ‘exact’ tests because they are nonparametric and based on\nexhaustive enumerations: not because we are sure of the answer – this is\nstatistics after all.](imgs/devil.png)](imgs/devil.png \"So-called ‘exact’\ntests because they are nonparametric and based on exhaustive enumerations: not\nbecause we are sure of the answer – this is statistics after all.\")\n\nSo-called ‘exact’ tests because they are nonparametric and based on exhaustive\nenumerations: **not** because we are sure of the answer – this is statistics\nafter all.\n\nDefine a universe of candidate genes that may potentially be significant; say\nthis universe is of size \\\\(N\\\\). We also have a record of the genes that\nactually **did** come out significant, of which we suppose there were \\\\(m\\\\).\n\nWe make a toy model involving balls in boxes, with a total of \\\\(N\\\\) balls\ncorresponding to the genes identified in the gene universe. These genes are\nsplit into different functional categories, suppose there are \\\\(N=1,000\\\\)\ngenes, of which 500 are yellow, 100 are blue and 400 are red. Then a subset of\n\\\\(m=75\\\\) genes are labeled as **significant** , suppose among these\nsignificantly interesting genes, there are 25 yellow, 25 red and 25 blue. Is\nthe blue category enriched or overrepresented?\n\nWe use this hypergeometric two-way table testing to account for the fact that\nsome categories are extremely numerous and others are rarer.\n\n__\n\nQuestion 10.6\n\nRun a Monte Carlo experiment with 20,000 simulations and compute the p-value\nof significance of having 25 blues under the null hypothesis that no category\nis over-represented in the significant set.\n\n__\n\nSolution\n\n__\n\nUnder the null the 75 are sampled randomly from our unequal boxes as follows:\n\n    \n    \n    universe = c(rep(\"Yellow\", 500), rep(\"Blue\", 100), rep(\"Red\", 400))\n    countblue = replicate(20000, {\n      pick75 = sample(universe, 75, replace = FALSE)\n      sum(pick75 == \"Blue\")\n    })\n    summary(countblue)__\n    \n    \n       Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n      0.000   6.000   7.000   7.496   9.000  20.000 \n\nThe histogram in Figure 10.9 shows that having a value as large as 25 under\nthe null model would be extremely rare.\n\n[![](10-chap_files/figure-html/fig-histblue-1.png)](10-chap_files/figure-\nhtml/fig-histblue-1.png \"Figure 10.9: We can see that even in 20000\nsimulations, no blue count comes close to being 25. We can reject such an\nevent as having happened by chance and conclude that the blue are enriched.\")\n\nFigure 10.9: We can see that even in 20000 simulations, no blue count comes\nclose to being 25. We can reject such an event as having happened by chance\nand conclude that the blue are **enriched**.\n\nIn the general case, the gene universe is an urn with \\\\(N\\\\) balls, if we\npick the \\\\(m\\\\) balls at random and there is a proportion of \\\\(k/N\\\\) blue\nballs, we expect to see \\\\(km/N\\\\) blue balls in a draw of size \\\\(k\\\\).\n\n#### Plotting gene enrichment networks with\n**[GOplot](https://cran.r-project.org/web/packages/GOplot/)**\n\nHere we show an attractive way of summarizing the connections between the gene\nfunctional categories and the significant gene set.\n\n    \n    \n    library(\"GOplot\")\n    data(\"EC\")\n    circ  =  circle_dat(EC$david, EC$genelist)\n    chord =  chord_dat(circ, EC$genes, EC$process)\n    GOChord(chord, limit = c(0, 5))__\n\n[![](10-chap_files/figure-html/fig-GOplotEC-1.jpeg)](10-chap_files/figure-\nhtml/fig-GOplotEC-1.jpeg \"Figure 10.10: This graph shows the correspondence\nbetween GO terms and significantly changed genes in a study on differential\nexpression in endothelial cells from two steady state tissues \\(brain and\nheart, see @Nolan:2013\\). After normalization a differential expression\nanalysis was performed giving a list of genes. A gene-annotation enrichment\nanalysis of the set of differentially expressed genes \\(adjusted p-value <\n0.05\\) was then performed with the GOplot package.\")\n\nFigure 10.10: This graph shows the correspondence between GO terms and\nsignificantly changed genes in a study on differential expression in\nendothelial cells from two steady state tissues (brain and heart, see Nolan et\nal. ([2013](16-chap.html#ref-Nolan:2013))). After normalization a differential\nexpression analysis was performed giving a list of genes. A gene-annotation\nenrichment analysis of the set of differentially expressed genes (adjusted\np-value < 0.05) was then performed with the\n**[GOplot](https://cran.r-project.org/web/packages/GOplot/)** package.\n\nIn fact, the Gene Ontology graph does not necessarily capture meaningful _gene\ninteractions_ as genes from different processes often interact productively. A\nlarge amount of information remains unused, for example, all significant genes\nare usually given equal weight, despite the potentially large variations in\ntheir p-values.\n\n### 10.3.3 Significant subgraphs and high scoring modules\n\nWe have at our disposal more than just the Gene Ontology. There are many\ndifferent databases of gene networks from which we can choose a **known\nskeleton** graph onto which we project significance scores such as p-values\nfrom our differential expression experiment. We will follow an idea first\nsuggested by Ideker et al. ([2002](16-chap.html#ref-Ideker:2002)). This is\nfurther developed in Nacu et al. ([2007](16-chap.html#ref-GXNA)). A careful\nimplementation with many improvements is available as the Bioconductor package\n**[BioNet](https://bioconductor.org/packages/BioNet/)** ([Beisser et al.\n2010](16-chap.html#ref-BioNet)). These methods all search for the subgraphs or\nmodules of a scored-skeleton network that seem to be particularly\n**perturbed**.\n\nEach gene-node in the network is assigned a score that can either be\ncalculated from a t-statistic or a p-value. Often pathways contain both\nupregulated and downregulated genes; as pointed out in Ideker et al.\n([2002](16-chap.html#ref-Ideker:2002)), this can be captured by taking\nabsolute values of the test statistic or just incorporating scores computed\nfrom the p-values2. Beisser et al. ([2010](16-chap.html#ref-BioNet)) model the\np-values of the genes as we did in [Chapter 6](06-chap.html): mixture of non-\nperturbed genes whose p-values will be uniformly distributed and non uniformly\ndistributed p-values from the perturbed genes. We model the signal in the data\nusing a beta distribution for the p-values following Pounds and Morris\n([2003](16-chap.html#ref-Pounds2003)).\n\n2 We’ll want something like \\\\(-\\log p\\\\), so that small p-values give large\nscores.\n\nGiven our node-scoring function, we search for connected hotspots in the\ngraph, i.e., a subgraph of genes with high combined scores.\n\n#### Using a subgraph search algorithm\n\nFinding the maximal scoring subgraph of a generic graph is known to be\nintractable in general (we say it is an NP-hard problem), so various\napproximate algorithms have been proposed. Ideker et al.\n([2002](16-chap.html#ref-Ideker:2002)) suggested using simulated annealing,\nhowever this is slow and tends to produce large subgraphs that are difficult\nto interpret. Nacu et al. ([2007](16-chap.html#ref-GXNA)) started with a seed\nvertex and gradually expand around it. Beisser et al.\n([2010](16-chap.html#ref-BioNet)) started the search with a so-called minimal\nspanning tree (MST), a graph we we will study later in this chapter.\n\n### 10.3.4 An example with the BioNet implementation\n\nTo illustrate the method, we show data from the\n**[BioNet](https://bioconductor.org/packages/BioNet/)** package.\n\nThe `interactome` data contains a connected component of the network\ncomprising 2034 different gene products and 8399 interactions. This\nconstitutes the skeleton graph with which we will work, see Beisser et al.\n([2010](16-chap.html#ref-BioNet)).\n\nThe `dataLym` contains the relevant pvalues and \\\\(t\\\\) statistics for 3,583\ngenes, you can access them and do the analysis as follows:\n\n    \n    \n    library(\"BioNet\")\n    library(\"DLBCL\")\n    data(\"dataLym\")\n    data(\"interactome\")\n    interactome __\n    \n    \n    A graphNEL graph with undirected edges\n    Number of Nodes = 9386 \n    Number of Edges = 36504 \n    \n    \n    pval = dataLym$t.pval\n    names(pval)  =  dataLym$label\n    subnet = subNetwork(dataLym$label, interactome)\n    subnet = rmSelfLoops(subnet)\n    subnet __\n    \n    \n    A graphNEL graph with undirected edges\n    Number of Nodes = 2559 \n    Number of Edges = 7788 \n\n#### Fit a Beta-Uniform model\n\nThe p-values are fit to the type of mixture we studied in [Chapter\n4](04-chap.html), with a uniform component from the null with probability\n\\\\(\\pi_0\\\\) and a beta distribution (proportional to \\\\(a x^{a - 1}\\\\)) for\nthe p-values corresponding to the alternatives ([Pounds and Morris\n2003](16-chap.html#ref-Pounds2003)). \\\\[f(x|a,\\pi_0)= \\pi_0 + (1-\\pi_0) a x^{a\n- 1}\\qquad \\mbox{ for } 0 <x \\leq 1; \\; 0<a<1\\\\] Running the model with an\n\\\\[fdr\\\\] of 0.001:\n\nThe package actually gives a different name to \\\\(\\\\\\pi_0\\\\): it uses\n\\\\(\\\\\\lambda\\\\) and calls it the mixing parameter.\n\n    \n    \n    fb = fitBumModel(pval, plot = FALSE)\n    fb __\n    \n    \n    Beta-Uniform-Mixture (BUM) model\n    \n    3583 pvalues fitted\n    \n    Mixture parameter (lambda): 0.482\n    shape parameter (a):        0.180\n    log-likelihood:         4471.8\n    \n    \n    scores=scoreNodes(subnet, fb, fdr = 0.001)__\n\n[![](10-chap_files/figure-html/fig-plotFITBum-1.png)](10-chap_files/figure-\nhtml/fig-plotFITBum-1.png \"Figure 10.11: The qqplot shows the quality of the\nfit of beta-uniform mixture model to the data. The red points have the\ntheoretical quantiles from the beta distribution as the x coordinates the\nobserved quantiles and the y coordinates. The blue line shows that this model\nfits nicely.\")\n\nFigure 10.11: The qqplot shows the quality of the fit of beta-uniform mixture\nmodel to the data. The red points have the theoretical quantiles from the beta\ndistribution as the x coordinates the observed quantiles and the y\ncoordinates. The blue line shows that this model fits nicely.\n\n[![](10-chap_files/figure-html/fig-histFITBum-1.png)](10-chap_files/figure-\nhtml/fig-histFITBum-1.png \"Figure 10.12: A histogram of the mixture components\nfor the p-values, the beta in red and the uniform in blue, \\\\pi_0 is the\nmixing proportion assigned to the null component whose distribution should be\nuniform.\")\n\nFigure 10.12: A histogram of the mixture components for the p-values, the beta\nin red and the uniform in blue, \\\\(\\pi_0\\\\) is the mixing proportion assigned\nto the null component whose distribution should be uniform.\n\nThen we run a heuristic search for a high scoring subgraph using:\n\n    \n    \n    hotSub  =  runFastHeinz(subnet, scores)\n    hotSub __\n    \n    \n    A graphNEL graph with undirected edges\n    Number of Nodes = 144 \n    Number of Edges = 221 \n    \n    \n    logFC=dataLym$diff\n    names(logFC)=dataLym$label __\n\n__\n\nQuestion 10.7\n\nWe made Figure 10.13 using the following code:\n\n    \n    \n    plotModule(hotSub, layout = layout.davidson.harel, scores = scores,\n                      diff.expr = logFC)__\n\n[![](10-chap_files/figure-html/fig-plotBioNet-1.png)](10-chap_files/figure-\nhtml/fig-plotBioNet-1.png \"Figure 10.13: The subgraph found as maximally\nenriched for differential expression between ABC and GCB B-cell lymphoma. The\nnodes are colored in red and green: green shows an upregulation in ACB and red\nan upregulation in GBC. The shape of the nodes depicts the score: rectangles\nindicate a negative score, circles a positive score.\")\n\nFigure 10.13: The subgraph found as maximally enriched for differential\nexpression between ABC and GCB B-cell lymphoma. The nodes are colored in red\nand green: green shows an upregulation in ACB and red an upregulation in GBC.\nThe shape of the nodes depicts the score: rectangles indicate a negative\nscore, circles a positive score.\n\nUsing the function `igraph.from.graphNEL`, transform the module object and\nplot it using the\n**[ggraph](https://cran.r-project.org/web/packages/ggraph/)** method shown in\nSection 10.2.2.\n\n## 10.4 Phylogenetic Trees\n\n[![](imgs/SameTreePhyl.png)](imgs/SameTreePhyl.png \"Figure 10.14: As\nmathematical objects, the hierarchical clustering trees \\(studied in sec-\nclustering\\) are the same as phylogenetic trees. They are rooted binary trees\nwith labels at the tips.\")\n\nFigure 10.14: As mathematical objects, the hierarchical clustering trees\n(studied in [Chapter 5](05-chap.html)) are the same as phylogenetic trees.\nThey are **rooted binary** trees with labels at the tips.\n\nOne really important use of graphs in biology is the construction of\nphylogenetic trees. Trees are graphs with no **cycles** (the official word for\nloops, whether self loops, or ones that go through several vertices).\nPhylogenetic trees are usually rooted binary trees that only have labels on\nthe leaves corresponding to contemporary3 taxa at the tips. The inner nodes\ncorrespond to **ancestral** sequences which have to be inferred from the\n**contemporaneous** data on the tips. Many methods use aligned DNA sequences\nfrom the different species or populations to infer or estimate the tree. The\ntips of the tree are usually called **OTU** s (Operational Taxonomic Units).\nThe statistical **parameter** of interest in these analyses is the rooted\nbinary tree with OTU labels on its leaves (see Holmes\n([1999](16-chap.html#ref-holmesima), [2003b](16-chap.html#ref-holmes2003b))\nfor details).\n\n3 Because they are contemporary, the trees are often represented so that the\nleaves are a ll the same distance from the root.\n\n#### The example of HIV\n\n[![](imgs/hivtreeplos.png)](imgs/hivtreeplos.png \"Figure 10.15: This\nphylogenetic tree describes the history of different HIV/SIV strains in Africa\n\\[@Wertheim:2009\\], \\[Figure from\\].\")\n\nFigure 10.15: This phylogenetic tree describes the history of different\nHIV/SIV strains in Africa ([Wertheim and Worobey 2009](16-chap.html#ref-\nWertheim:2009)), [Figure from].\n\nHIV is a virus that protects itself by evolving very fast (within months,\nseveral mutations can appear). Its evolution can thus be followed in real\ntime; whereas the evolution of large organisms which has happened over\nmillions of years. HIV trees are built for medical purposes such as the\ndetection and understanding of drug resistance. They are estimated for\nindividual genes. Different genes can show differences in their evolutionary\nhistories and thus produce different **gene trees**. The phylogenetic tree in\nFigure 10.15 shows times when the virus switched from monkeys to humans\n([Wertheim and Worobey 2009](16-chap.html#ref-Wertheim:2009)).\n\n#### Special elements in phylogenies\n\n  * Most phylogenetic trees are shown rooted, the `root’ is usually found by including an outgroup in the tree tips, as we will see later.\n\n  * Characters that are derived from this common ancestry are called homologous (geneticists doing population studies replace the term homology by identity by descent (IBD)).\n\n  * Sisters on the tree defined by a common ancestor are called clades or monophyletic groups, they have more than just _similarities_ in common.\n\n### 10.4.1 Markovian models for evolution.\n\nTo infer what happened in the ancestral species from contemporary data\ncollected on the tips of the tree, we have to make assumptions about how\nsubstitutions and deletions occur through time. The models we use are all\nMarkovian and said to be time homogeneous: the mutation rate is constant\nacross history.\n\n[![This is called the molecular clock hypothesis, if we do not make this\nassumption we run into what is known as non-identifiability \\(ie we can’t tell\nthe difference between the many possible mutational histories given the\nobserved data\\).](imgs/devil.png)](imgs/devil.png \"This is called the\nmolecular clock hypothesis, if we do not make this assumption we run into what\nis known as non-identifiability \\(ie we can’t tell the difference between the\nmany possible mutational histories given the observed data\\).\")\n\nThis is called the **molecular clock** hypothesis, if we do not make this\nassumption we run into what is known as non-identifiability (ie we can’t tell\nthe difference between the many possible mutational histories given the\nobserved data).\n\n#### Continuous Markov chain and generator matrix\n\nWe are going to use the Markov chain we saw in Figure 10.7 on the states\n[A,C,G,T]; however now we consider that the changes of state, i.e. mutations,\noccur at random times. The gaps between these mutational events will follow an\nexponential distribution. These continuous time Markov chains have the\nfollowing properties:\n\n  * **No Memory**. \\\\(P(Y(u+t)=j\\;|\\;Y(t)=i)\\\\) does not depend on times before \\\\(t\\\\).\n\n  * **Time homogeneity**. The probability \\\\(P(Y(h+t)=j\\,|\\,Y(t)=i)\\\\) does not depend on \\\\(t\\\\), but on \\\\(h\\\\), the time between the events and on \\\\(i\\\\) and \\\\(j\\\\).\n\n  * **Linearity**. The instantaneous transition rate is of an approximately linear form\n\n[![We use an error term written here as o\\(h\\), we read this little o of h,\nwhich just means that this error terms grows much slower \\(i.e., sublinear\\)\nthan h.](imgs/devil.png)](imgs/devil.png \"We use an error term written here as\no\\(h\\), we read this little o of h, which just means that this error terms\ngrows much slower \\(i.e., sublinear\\) than h.\")\n\nWe use an error term written here as \\\\(o(h)\\\\), we read this little \\\\(o\\\\)\nof \\\\(h\\\\), which just means that this error terms grows much slower (i.e.,\nsublinear) than \\\\(h\\\\).\n\n\\\\[ \\begin{align} P_{ij}(h)&=q_{ij}h+o(h), \\quad\\text{for }j\\neq i\\\\\\\nP_{ii}(h)&=1-q_i(h)+ o(h), \\qquad\\text{where }q_i=\\sum_{j\\neq i}q_{ij}.\n\\end{align} \\tag{10.1}\\\\]\n\n\\\\(q_{ij}\\\\) is known as the instantaneous transition rate. These rates define\nmatrices as in Table 10.2.\n\n  * **Exponential distribution**. Times between changes are supposed to be exponentially distributed.\n\n\\\\(Q = \\begin{array}{lcccc} & A & T & C & G \\\\\\ A & -3\\alpha & \\alpha & \\alpha & \\alpha \\\\\\ T & \\alpha & -3\\alpha & \\alpha & \\alpha \\\\\\ C & \\alpha & \\alpha & -3\\alpha & \\alpha \\\\\\ G & \\alpha & \\alpha & \\alpha & -3\\alpha \\\\\\ \\end{array}\\\\) | \\\\(Q = \\begin{array}{lcccc} & A & T & C & G \\\\\\ A & -\\alpha-2 \\beta & \\beta & \\beta & \\alpha \\\\\\ T & \\beta & -\\alpha-2 \\beta & \\alpha & \\beta \\\\\\ C & \\beta & \\alpha & -\\alpha-2 \\beta & \\beta \\\\\\ G & \\alpha & \\beta & \\beta & -\\alpha-2 \\beta \\\\\\ \\end{array}\\\\)  \n---|---  \n  \nTable 10.2: Two examples of rate matrices, on the left:the Jukes-Cantor\n(`JC69`) model, on the right is shown the Kimura (`K80`) two parameter model.\n\nthe instantaneous change probability matrix called **the generator**. In the\nsimplest possible model, called a Jukes-Cantor model; all the mutations are\nequally likely (see the left of Table 10.2). A slightly more flexible model,\ncalled the Kimura model is shown on the right in Table 10.2.\n\n__\n\nQuestion 10.8\n\nWhy do we say the Kimura model is more flexible?\n\n__\n\nSolution\n\n__\n\nThe Jukes-Cantor only has one parameter, that model supposes all transitions\nand transversions are equally likely. In the Kimura, there is one parameter\nfor transitions and another for the transversions (mutations occurring from\npurine to pyrimidines, or vice versa).\n\n![Vocabulary overload here! : Transitions in this context mean mutational\nchanges within the purines (A<->G]) or within the pyrimidines (C <-> T);\nwhereas when we talked about Markov chains earlier our **transition** matrix\ncontains all probabilities of any state changes.](imgs/devil.png){fig-\nalign=‘center’ width=123}\n\nThe most flexible model is called the Generalized Time Reversible (GTR) model;\nit has 6 free parameters. We are going to show an example of data simulated\naccording to these generative models from a known tree.\n\n### 10.4.2 Simulating data and plotting a tree\n\nSuppose we already know our phylogenetic tree and want to simulate the\nevolution of the nucleotides down this tree. First we visualize the tree\n`tree1` using `ggtree`; loading the tree and the relevant packages with:\n\n    \n    \n    library(\"phangorn\")\n    library(\"ggtree\")\n    load(file.path(DATA,\"tree1.RData\"))__\n\n__\n\nTask\n\nUse the `ggtree` function to plot `tree1`; make the tips of the tree green\ntriangles, the ancestral nodes, red circles.\n\n    \n    \n    ggtree(tree1, lwd = 2, color = \"darkgreen\", alpha = 0.8, right = TRUE) +\n      geom_tiplab(size = 7, angle = 90, offset = 0.05) +\n      geom_point(aes(shape = isTip, color = isTip), size = 5, alpha = 0.6)__\n\n[![](10-chap_files/figure-html/fig-Atree1b-1.png)](10-chap_files/figure-\nhtml/fig-Atree1b-1.png \"Figure 10.16: This is the tree we use as our true\nparameter. We generate nucleotides one at a time from the root and `dropping’\nthem down the tree. With some probability proportional to the edge lengths,\nmutations occur down the branches.\")\n\nFigure 10.16: This is the tree we use as our _true_ parameter. We generate\nnucleotides one at a time from the root and `dropping’ them down the tree.\nWith some probability proportional to the edge lengths, mutations occur down\nthe branches.\n\nNow we generate some sequences from our tree. Each sequence starts with a new\nnucleotide letter generated randomly at the root; mutations may occur as we go\ndown the tree. You can see in Figure 10.17 that the colors are not equally\nrepresented, because the frequency at the root was chosen to be different from\nthe uniform, see the following code.\n\n    \n    \n    seqs6 = simSeq(tree1, l = 60, type = \"DNA\", bf = c(1, 1, 3, 3)/8, rate = 0.1)\n    seqs6 __\n    \n    \n    6 sequences with 60 character and 30 different site patterns.\n    The states are a c g t \n    \n    \n    mat6df = data.frame(as.character(seqs6))\n    p = ggtree(tree1, lwd = 1.2) + geom_tiplab(aes(x = branch), size = 5, vjust = 2)\n    gheatmap(p, mat6df[, 1:60], offset = 0.01, colnames = FALSE)__\n\n[![](10-chap_files/figure-html/fig-\nggtreeAlignment-1.png)](10-chap_files/figure-html/fig-ggtreeAlignment-1.png\n\"Figure 10.17: The tree on the left was used to generate the sequences on the\nright according to a Jukes Cantor model. The nucleotide frequencies generated\nat the root were quite unequal, with A and C being generated more rarely. As\nthe sequences percolate down the tree, mutations occur, they are more likely\nto occur on the longer branches.\")\n\nFigure 10.17: The tree on the left was used to generate the sequences on the\nright according to a Jukes Cantor model. The nucleotide frequencies generated\nat the root were quite unequal, with `A` and `C` being generated more rarely.\nAs the sequences percolate down the tree, mutations occur, they are more\nlikely to occur on the longer branches.\n\n__\n\nQuestion 10.9\n\nExperiment with the code above. Change the `bf` and `rate` arguments in the\n`simSeq` function to make mutations more likely. Do you think sequences\ngenerated with a very high mutation rate would make it easier to infer the\ntree that generated them?\n\n__\n\nSolution\n\n__\n\nVery high mutation rates result in mutations overwriting themselves and make\ninference more difficult. Of course, there is a sweet spot because some\nmutations have to occur in order for us to resolve the tree branches. After a\ncertain time and a certain number of mutations it may be very difficult to see\nwhat was happening at the root. See Mossel ([2003](16-chap.html#ref-\nMossel:2003)) for details.\n\n__\n\nQuestion 10.10\n\n**Estimation bias: distance underestimation.**  \n1) If we only count the number of changes between two sequences using a simple\nHamming distance, but there has been much evolutionary change between the two,\nwhy do we underestimate the distance between the sequences?  \n2) Will be the bias be larger for smaller evolutionary distances?\n\nThe standard Markovian models of evolution we saw above enable us to improve\nthese estimates.\n\n### 10.4.3 Estimating a phylogenetic tree\n\n![](imgs/Magnify.png)\n\n“In solving a problem of this sort, the grand thing is to be able to reason\nbackward. That is a very useful accomplishment, and a very easy one, but\npeople do not practise it much. In the everyday affairs of life it is more\nuseful to reason forward, and so the other comes to be neglected. There are\nfifty who can reason synthetically for one who can reason analytically”.\n**Sherlock Holmes**\n\nWhen the true tree-parameter is known, the above-mentioned probabilistic\ngenerative models of evolution tells us what patterns to expect in the\nsequences. As we have seen in earlier chapters, statistics means going back\nfrom the data to reasonable estimates of the parameters; here the tree itself\nand the branch lengths, even the evolutionary rates can be considered to be\nthe parameters.\n\n[![](10-chap_files/figure-html/fig-igraphsteiner-1.png)](10-chap_files/figure-\nhtml/fig-igraphsteiner-1.png \"Figure 10.18: A Steiner tree, the inner points\nare represented as squares. The method for creating the shortest tree that\npasses through all outer 1,2,5,6 is to create two inside \\(“ancester”\\) points\n3 and 4.\")\n\nFigure 10.18: A Steiner tree, the inner points are represented as squares. The\nmethod for creating the shortest tree that passes through all outer 1,2,5,6 is\nto create two inside (“ancester”) points 3 and 4.\n\nThere are several approaches to estimation: tree `building’ is no exception,\nhere are the main ones:\n\n**A nonparametric estimate: the parsimony tree** Parsimony is a nonparametric\nmethod that minimizes the number of changes necessary to explain the data,\nit’s solution is the same as that of the Steiner tree problem (see Figure\n10.18).\n\n**A parametric estimate: the maximum likelihood tree** In order to estimate\nthe tree using a maximum likelihood or Bayesian approach one needs a model for\nmolecular evolution that integrates mutation rates and branch edge lengths. ML\nestimation (e.g., `Phyml`, `FastML`, `RaxML`) use efficient optimization\nalgorithms to maximize the likelihood of a tree under the model assumptions.\n\n**Bayesian posterior distributions for trees** Bayesian estimation, MrBayes\n([Ronquist et al. 2012](16-chap.html#ref-mrbayes3)) or BEAST ([Bouckaert et\nal. 2014](16-chap.html#ref-beast)) both use MCMC to find posterior\ndistributions of the phylogenies. Bayesian methods are not directly integrated\ninto R and require the user to import the collections of trees generated by\nMonte Carlo methods in order to summarize them and make confidence statements\nsee Chakerian and Holmes ([2012](16-chap.html#ref-distory-paper)) for simple\nexamples.\n\n**The semi-parametric approach: distance based methods** These methods, called\nNeighbor Joining and UPGMA, are quite similar to the hierachical clusering\nalgorithms we already encountered in [Chapter 5](05-chap.html). However, the\ndistance estimation steps uses the parametric evolutionary models of Table\n10.2; the `parametric’ part of why we call the method semi-parametric.\n\nThe neighbor-joining algorithm itself uses Steiner points as the summary of\ntwo combined points, and proceeds iteratively as in hierarchical clustering.\nIt can be quite fast and is often used as a good starting point for the more\ntime-consuming methods.\n\nLet’s start by estimating the tree from the data `seqs6` using the `nj`\n(neighbor joining) on DNA distances based on the one-parameter Jukes-Cantor\nmodel, we make Figure 10.19 using the `ggtree` function:\n\n    \n    \n    tree.nj = nj(dist.ml(seqs6, \"JC69\"))\n    ggtree(tree.nj) + geom_tiplab(size = 7) __\n\n[![](10-chap_files/figure-html/fig-njtree1-1.png)](10-chap_files/figure-\nhtml/fig-njtree1-1.png \"Figure 10.19: Trees built with a neighbor joining\nalgorithm are very fast to compute and are often used as initial values for\nmore expensive estimation procedures such as the maximum likelihood or\nparsimony.\")\n\nFigure 10.19: Trees built with a neighbor joining algorithm are very fast to\ncompute and are often used as initial values for more expensive estimation\nprocedures such as the maximum likelihood or parsimony.\n\n__\n\nQuestion 10.11\n\nGenerate the maximum likelihood scores of the tree1 given the `seqs6` data and\ncompare them to those of the neighbor joining tree.\n\n__\n\nSolution\n\n__\n\n    \n    \n    fit = pml(tree1, seqs6, k = 4)__\n\n__\n\nQuestion 10.12\n\nWhen we have aligned amino acids from which we want to infer a tree, we use\n(\\\\(20 \\times 20\\\\)) transition matrices. The methods for estimating the\nphylogenetic are very similar. Try this in phangorn with an HIV amino acid\nsequence downloaded from\n<https://www.hiv.lanl.gov/content/sequence/NEWALIGN/align.html>.\n\nThe quality of the tree estimates depend on the number of sequences per taxa\nand the distance to the root. We can evaluate the quality of the estimates\neither by using parametric and nonparametric bootstraps or performing Bayesian\ntree estimation using MCMC. For examples of how to visualize and compare the\nsampling distribution of trees, see Chakerian and Holmes\n([2012](16-chap.html#ref-distory-paper)).\n\n### 10.4.4 Application to 16S rRNA data\n\nIn [Chapter 5](05-chap.html) we saw how to use a probabilistic clustering\nmethod to denoise 16S rRNA sequences. We can now reload these denoised\nsequences and preprocess them before building their phylogeny4.\n\n4 In order to keep all the information and be able to compare sequences from\ndifferent experiments, we use the sequences themselves as their\nlabel([Callahan, McMurdie, and Holmes 2017](16-chap.html#ref-Callahan:2017)).\n\n    \n    \n    library(\"dada2\")\n    seqtab = readRDS(file.path(DATA,\"seqtab.rds\"))\n    seqs = getSequences(seqtab)\n    names(seqs) = seqs __\n\nOne of the benefits of using well-studied marker loci such as the 16S rRNA\ngene is the ability to taxonomically classify the sequenced variants.\n**[dada2](https://bioconductor.org/packages/dada2/)** includes a naive\nBayesian classifier method for this purpose ([Wang et al.\n2007](16-chap.html#ref-wang2007naive)). This classifier compares sequence\nvariants to training sets of classified sequences. Here we use the RDP v16\ntraining set ([Cole et al. 2009](16-chap.html#ref-cole2009rdp))5. For example,\ncode for such a classification might look like this.\n\n5 See the download link on the dada2 website:\n<https://benjjneb.github.io/dada2/training.html>\n\n    \n    \n    fastaRef = \"../tmp/rdp_train_set_16.fa.gz\"\n    taxtab = assignTaxonomy(seqtab, refFasta = fastaRef)__\n\nSince the `assignTaxonomy` function runs for a while, the above code is not\nlive and we here load a previously computed result, a table of taxonomic\ninformation:\n\n    \n    \n    taxtab = readRDS(file.path(DATA,\"taxtab16.rds\"))\n    dim(taxtab)__\n    \n    \n    [1] 268   6\n\n__\n\nQuestion 10.13\n\nWrite one line of code using R’s pipe operator `|>` that shows just the first\n6 rows of the taxonomic information without the row names.\n\n__\n\nSolution\n\n__\n\n    \n    \n    head(taxtab) |> `rownames<-`(NULL)__\n    \n    \n         Kingdom    Phylum          Class         Order          \n    [1,] \"Bacteria\" \"Bacteroidetes\" \"Bacteroidia\" \"Bacteroidales\"\n    [2,] \"Bacteria\" \"Bacteroidetes\" \"Bacteroidia\" \"Bacteroidales\"\n    [3,] \"Bacteria\" \"Bacteroidetes\" \"Bacteroidia\" \"Bacteroidales\"\n    [4,] \"Bacteria\" \"Bacteroidetes\" \"Bacteroidia\" \"Bacteroidales\"\n    [5,] \"Bacteria\" \"Bacteroidetes\" \"Bacteroidia\" \"Bacteroidales\"\n    [6,] \"Bacteria\" \"Bacteroidetes\" \"Bacteroidia\" \"Bacteroidales\"\n         Family               Genus        \n    [1,] \"Porphyromonadaceae\" NA           \n    [2,] \"Porphyromonadaceae\" NA           \n    [3,] \"Porphyromonadaceae\" NA           \n    [4,] \"Porphyromonadaceae\" \"Barnesiella\"\n    [5,] \"Bacteroidaceae\"     \"Bacteroides\"\n    [6,] \"Porphyromonadaceae\" NA           \n\n__\n\nQuestion 10.14\n\nWhat is the difference between taxonomic and phylogenetic information?\n\nNote that as the `seqs` data are randomly generated, they are “cleaner” than\nthe real data we will have to handle.\n\nIn particular naturally occurring raw sequences have to be **aligned**. This\nis necessary as there are often extra nucleotides in some sequences, a\nconsequence of what we call _indel_ events6. Also mutations occur and appear\nas substitutions of one nucleotide by another.\n\n6 A nucleotide is deleted or inserted and it is often hard to distinguish\nwhich took place.\n\nHere is an example of what the first few characters of **aligned** sequences\nlooks like:\n\n    \n    \n    readLines(file.path(DATA,\"mal2.dna.txt\")) |> head(12) |> cat(sep=\"\\n\")__\n    \n    \n        11   1620\n    Pre1        GTACTTGTTA GGCCTTATAA GAAAAAAGT- TATTAACTTA AGGAATTATA\n    Pme2        GTATCTGTTA AGCCTTATAA AAAGATAGT- T-TAAATTAA AGGAATTATA\n    Pma3        GTATTTGTTA AGCCTTATAA GAGAAAAGTA TATTAACTTA AGGA-TTATA\n    Pfa4        GTATTTGTTA GGCCTTATAA GAAAAAAGT- TATTAACTTA AGGAATTATA\n    Pbe5        GTATTTGTTA AGCCTTATAA GAAAAA--T- TTTTAATTAA AGGAATTATA\n    Plo6        GTATTTGTTA AGCCTTATAA GAAAAAAGT- TACTAACTAA AGGAATTATA\n    Pfr7        GTACTTGTTA AGCCTTATAA GAAAGAAGT- TATTAACTTA AGGAATTATA\n    Pkn8        GTACTTGTTA AGCCTTATAA GAAAAGAGT- TATTAACTTA AGGAATTATA\n    Pcy9        GTACTCGTTA AGCCTTTTAA GAAAAAAGT- TATTAACTTA AGGAATTATA\n    Pvi10       GTACTTGTTA AGCCTTTTAA GAAAAAAGT- TATTAACTTA AGGAATTATA\n    Pga11       GTATTTGTTA AGCCTTATAA GAAAAAAGT- TATTAATTTA AGGAATTATA\n\nWe will perform this multiple-alignment on our `seqs` data using the\n**[DECIPHER](https://bioconductor.org/packages/DECIPHER/)** package ([Wright\n2015](16-chap.html#ref-wright2015decipher)):\n\n    \n    \n    library(\"DECIPHER\")\n    alignment = AlignSeqs(DNAStringSet(seqs), anchor = NA, verbose = FALSE)__\n\nWe use the **[phangorn](https://cran.r-project.org/web/packages/phangorn/)**\npackage to build the MLE tree (under the GTR model), but will use the\nneighbor-joining tree as our starting point.\n\n    \n    \n    phangAlign = phangorn::phyDat(as(alignment, \"matrix\"), type = \"DNA\")\n    dm = phangorn::dist.ml(phangAlign)\n    treeNJ = phangorn::NJ(dm)   # Note: tip order != sequence order\n    fit = phangorn::pml(treeNJ, data = phangAlign)\n    fitGTR = update(fit, k = 4, inv = 0.2)\n    fitGTR = phangorn::optim.pml(fitGTR, model = \"GTR\", optInv = TRUE,\n             optGamma = TRUE,  rearrangement = \"stochastic\",\n             control = phangorn::pml.control(trace = 0))__\n\n## 10.5 Combining phylogenetic trees into a data analysis\n\nWe now need to combine the phylogenetic tree and the denoised read abundances\nwith the complementary information provided about the samples from which the\nreads were gathered. This information about the sample is often provided as a\nspreadhseet (or `.csv`), and sometimes called the _meta_ -data7. This data\ncombination step is facilitated by the specialized containers and accessors\nthat **[phyloseq](https://bioconductor.org/packages/phyloseq/)** provides.\n\n7 We consider the prefix _meta_ unhelpful and potentially confusing here: the\ndata about the samples is just that: data.\n\nThe following set of steps contains a few data cleanup and reorganization\ntasks—a dull but necessary part of applied statistics—that end in the creation\nof the object `ps1`.\n\n    \n    \n    samples = read.csv(\"../data/MIMARKS_Data_combined.csv\", header = TRUE)\n    samples$SampleID = paste0(gsub(\"00\", \"\", samples$host_subject_id), \n                              \"D\", samples$age-21) \n    samples = samples[!duplicated(samples$SampleID), ] \n    stopifnot(all(rownames(seqtab) %in% samples$SampleID))\n    rownames(samples) = samples$SampleID \n    keepCols = c(\"collection_date\", \"biome\", \"target_gene\", \"target_subfragment\", \n      \"host_common_name\", \"host_subject_id\", \"age\", \"sex\", \"body_product\", \"tot_mass\",\n      \"diet\", \"family_relationship\", \"genotype\", \"SampleID\") \n    samples = samples[rownames(seqtab), keepCols] __\n\nThe sample-by-sequence feature table, the sample (meta)data, the sequence\ntaxonomies, and the phylogenetic tree—are combined into a single object as\nfollows:\n\n    \n    \n    library(\"phyloseq\")\n    pso = phyloseq(tax_table(taxtab), \n                   sample_data(samples),\n                   otu_table(seqtab, taxa_are_rows = FALSE), \n                   phy_tree(fitGTR$tree))__\n\nWe have already encountered several cases of combining heterogeneous datasets\ninto special data classes that automate the linking and keeping consistent the\ndifferent parts of the dataset (e.g., in [Chapter 8](08-chap.html), when we\nstudied the `pasilla` data).\n\n__\n\nTask\n\nLook at the detailed\n**[phyloseq](https://bioconductor.org/packages/phyloseq/)** [documentation\nhere](https://joey711.github.io/phyloseq/tutorials-index.html). Try a few\nfiltering operations. For instance, create a subset of the data that contains\nthe tree, taxa abundance table, the sample and taxa information for only the\nsamples that have more than 5000 reads.\n\nThis can be done in one line:\n\n    \n    \n    prune_samples(rowSums(otu_table(pso)) > 5000, pso)__\n    \n    \n    phyloseq-class experiment-level object\n    otu_table()   OTU Table:         [ 268 taxa and 10 samples ]\n    sample_data() Sample Data:       [ 10 samples by 14 sample variables ]\n    tax_table()   Taxonomy Table:    [ 268 taxa by 6 taxonomic ranks ]\n    phy_tree()    Phylogenetic Tree: [ 268 tips and 266 internal nodes ]\n\nWe can also make other data transformations while maintaining the integrity of\nthe links between all the data components.\n\n__\n\nQuestion 10.15\n\nWhat do the following lines of code do?\n\n    \n    \n    prevalence = apply(X = otu_table(pso),\n                       MARGIN = ifelse(taxa_are_rows(pso), yes = 1, no = 2),\n                       FUN = function(x) {sum(x > 0)})\n    prevdf = data.frame(Prevalence = prevalence,\n                        TotalAbundance = taxa_sums(pso),\n                        tax_table(pso))\n    tab = table(prevdf$Phylum)\n    keepPhyla = names(tab)[tab>5]\n    prevdf1   = subset(prevdf,   Phylum %in% keepPhyla)\n    ps2v      = subset_taxa(pso, Phylum %in% keepPhyla)__\n\nPlotting the abundances for certain bacteria can be done using barcharts.\n**[ggplot2](https://cran.r-project.org/web/packages/ggplot2/)** expressions\nhave been hardwired into suitable one-line calls in the\n**[phyloseq](https://bioconductor.org/packages/phyloseq/)** package. There is\nalso an interactive [Shiny-phyloseq](http://joey711.github.io/shiny-phyloseq/)\nbrowser based tool ([McMurdie and Holmes 2015](16-chap.html#ref-\nmcmurdie2015)). For more details, please see the online vignettes.\n\n### 10.5.1 Hierarchical multiple testing\n\nHypothesis testing can identify individual bacteria whose abundance relates to\nsample variables of interest. A standard approach is very similar to the\napproach we already visited in [Chapter 6](06-chap.html). Compute a test\nstatistic for each taxa individually; then jointly adjust p-values to ensure a\nfalse discovery rate upper bound. However, this procedure does not exploit the\nstructure among the tested hypotheses. For example, if we observe that one\nRuminococcus species is strongly associated with age, but the biological\nreason for this sits at the genus level, then we would expect other species to\nhave such an association as well. To integrate such information, Benjamini and\nYekutieli ([2003](16-chap.html#ref-benjamini2003hierarchical)) and Benjamini\nand Bogomolov ([2014](16-chap.html#ref-benjamini2014selective)) proposed a\nhierarchical testing procedure, where lower level taxonomic groups are only\ntested if higher levels are found to be be associated. In the case where many\nrelated species have a slight signal, this pooling of information can increase\npower.\n\nWe apply this method to test the association between microbial abundance and\nage. We use the data object `ps1`, which is similar to `pso` from above, but\nhas undergone some additional transformation and filtering steps. We also need\nto apply the normalization protocols available in the\n**[DESeq2](https://bioconductor.org/packages/DESeq2/)** package, which we\ndiscussed in [Chapter 8](08-chap.html), following Love, Huber, and Anders\n([2014](16-chap.html#ref-LoveDESeq2)) for RNA-Seq data and McMurdie and Holmes\n([2014](16-chap.html#ref-mcmurdie2014)) for 16S rRNA generated count data.\n\n    \n    \n    # warning: !expr c(\"DESeqDataSet.se, design = design, ignoreRank.: some variables in design formula are characters, converting to factors\")\n    library(\"DESeq2\")\n    ps1 = readRDS(file.path(DATA,\"ps1.rds\"))\n    ps_dds = phyloseq_to_deseq2(ps1, design = ~ ageBin + family_relationship)\n    geometricmean = function(x)\n       if (all(x == 0)) { 0 } else { exp(mean(log(x[x != 0]))) }\n    geoMeans = apply(counts(ps_dds), 1, geometricmean)\n    ps_dds = estimateSizeFactors(ps_dds, geoMeans = geoMeans)\n    ps_dds = estimateDispersions(ps_dds)\n    abund = getVarianceStabilizedData(ps_dds)__\n\nWe use the **[structSSI](https://cran.r-project.org/web/packages/structSSI/)**\npackage to perform the hierarchical testing ([Sankaran and Holmes\n2014](16-chap.html#ref-sankaran2014structssi)). For more convenient printing,\nwe first shorten the names of the taxa:\n\n    \n    \n    rownames(abund) = substr(rownames(abund), 1, 5) |> make.names(unique = TRUE)__\n\nThe hierarchical testing procedure we are now going to do differs from\nstandard multiple hypothesis testing in that univariate tests are done not\nonly for every taxon, but for each higher-level taxonomic group. A helper\nfunction, `treePValues`, is available for this: it expects an edge list\nencoding parent-child relationships, with the first row specifying the root\nnode.\n\n    \n    \n    library(\"structSSI\")\n    el = phy_tree(ps1)$edge\n    el0 = el\n    el0 = el0[rev(seq_len(nrow(el))), ]\n    el_names = c(rownames(abund), seq_len(phy_tree(ps1)$Nnode))\n    el[, 1] = el_names[el0[, 1]]\n    el[, 2] = el_names[el0[, 2]]\n    unadj_p = treePValues(el, abund, sample_data(ps1)$ageBin)__\n\nWe can now do our FDR calculations using the hierarchical testing procedure.\nThe test results are guaranteed to control several variants of FDR, but at\ndifferent levels; we defer details to ([Benjamini and Yekutieli\n2003](16-chap.html#ref-benjamini2003hierarchical); [Benjamini and Bogomolov\n2014](16-chap.html#ref-benjamini2014selective); [Sankaran and Holmes\n2014](16-chap.html#ref-sankaran2014structssi)).\n\n__\n\nTask\n\nTry the following code, including the interactive plotting command that will\nopen a browser window:\n\n    \n    \n    hfdr_res = hFDR.adjust(unadj_p, el, 0.75)\n    summary(hfdr_res)\n    #plot(hfdr_res, height = 5000) # not run: opens in a browser __\n\n[![](imgs/structssi-screenshot.png)](imgs/structssi-screenshot.png\n\"Figure 10.20: A screenshot of a subtree with many differentially abundant\nmicrobes, as determined by the hierarchical testing procedure. Currently the\nuser is hovering over the node associated with microbe GCGAG.33; this causes\nthe adjusted p-value \\(0.029\\) to appear.\")\n\nFigure 10.20: A screenshot of a subtree with many differentially abundant\nmicrobes, as determined by the hierarchical testing procedure. Currently the\nuser is hovering over the node associated with microbe GCGAG.33; this causes\nthe adjusted p-value (0.029) to appear.\n\nThe plot opens in a new browser – a static screenshot of a subtree is\ndisplayed in Figure 10.20. Nodes are shaded according to p-values, from blue\nto orange, representing the strongest to weakest associations. Grey nodes were\nnever tested, to focus power on more promising subtrees. Scanning the full\ntree; it becomes clear that the association between age group and taxonomic\nabundances is present in only a few isolated taxonomic groups. It is quite\nstrong in those groups. To give context to these results, we can retrieve the\ntaxonomic identity of the rejected hypotheses.\n\n    \n    \n    library(\"dplyr\")\n    options(digits = 3)\n    tax = tax_table(ps1)[, c(\"Family\", \"Genus\")] |> data.frame()\n    tax$seq = rownames(abund)\n    hfdr_res@p.vals$seq = rownames(hfdr_res@p.vals)\n    left_join(tax, hfdr_res@p.vals[,-3]) |>\n      arrange(adjp) |> head(9) |> dplyr::select(1,2,4,5)__\n    \n    \n                  Family       Genus hypothesisName hypothesisIndex\n    1 Porphyromonadaceae        <NA>           <NA>              NA\n    2 Porphyromonadaceae        <NA>           <NA>              NA\n    3 Porphyromonadaceae        <NA>           <NA>              NA\n    4 Porphyromonadaceae Barnesiella           <NA>              NA\n    5     Bacteroidaceae Bacteroides           <NA>              NA\n    6 Porphyromonadaceae Barnesiella           <NA>              NA\n    7      Rikenellaceae   Alistipes           <NA>              NA\n    8 Porphyromonadaceae        <NA>           <NA>              NA\n    9 Porphyromonadaceae        <NA>           <NA>              NA\n\nIt seems that the most strongly associated bacteria all belong to family\n_Lachnospiraceae_.\n\n## 10.6 Minimum spanning trees\n\nA very simple and useful graph is the so-called **minimum spanning tree**\n(**MST**). Given a set of vertices, a **spanning tree** is a tree that goes\nthrough all points at least once. Examples are shown in Figure 10.21. Given\ndistances between vertices, the MST is the spanning tree with the minimum\ntotal length (see Figure 10.21).\n\nGreedy algorithms work well for computing the MST and there are many\nimplementations in R: `mstree` in\n**[ade4](https://cran.r-project.org/web/packages/ade4/)** , `mst` in\n**[ape](https://cran.r-project.org/web/packages/ape/)** , `spantree` in\n**[vegan](https://cran.r-project.org/web/packages/vegan/)** , `mst` in\n**[igraph](https://cran.r-project.org/web/packages/igraph/)**.\n\n[![](10-chap_files/figure-html/fig-graphs-MST-1.png)](10-chap_files/figure-\nhtml/fig-graphs-MST-1.png \"Figure 10.21 \\(a\\): \")\n\n(a)\n\n[![](10-chap_files/figure-html/fig-graphs-MST-2.png)](10-chap_files/figure-\nhtml/fig-graphs-MST-2.png \"Figure 10.21 \\(b\\): \")\n\n(b)\n\nFigure 10.21: Two spanning trees for the same set of six vertices. The blue\ngraph is the minimum spanning tree, if the Euclidean distances between the\npoints in the 2D plane are used.\n\nHere we are going to take the DNA sequence distances between strains of HIV\nfrom patients all over the world and construct their minimum spanning tree.\nThe result is shown in Figure 10.22.\n\n    \n    \n    load(file.path(DATA, \"dist2009c.RData\"))\n    country09 = attr(dist2009c, \"Label\")\n    mstree2009 = ape::mst(dist2009c)\n    gr09 = graph_from_adjacency_matrix(mstree2009, mode = \"undirected\")\n    ggraph(gr09, layout=\"fr\") +\n      geom_edge_link(color = \"black\",alpha=0.5) +\n      geom_node_point(aes(color = vertex_attr(gr09)$name), size = 2) +\n      geom_node_text(aes(label = vertex_attr(gr09)$name), color=\"black\",size=2) +\n      theme_void() +\n      guides(color=guide_legend(keyheight=0.1,keywidth=0.1,\n          title=\"Countries\"))__\n\n[![](10-chap_files/figure-html/fig-HIVMSTi-1.png)](10-chap_files/figure-\nhtml/fig-HIVMSTi-1.png \"Figure 10.22: The minimum spanning tree computed from\nDNA distances between HIV sequences from samples taken in 2009 and whose\ncountry of origin was known, data as published in the HIVdb database\n\\[@HIVdb\\].\")\n\nFigure 10.22: The minimum spanning tree computed from DNA distances between\nHIV sequences from samples taken in 2009 and whose country of origin was\nknown, data as published in the `HIVdb` database ([Rhee et al.\n2003](16-chap.html#ref-HIVdb)).\n\n__\n\nQuestion 10.16\n\nMake the network plot again, but replace `geom_node_text` with labels that\nrepel each other to minimize the overlapping node labels.\n\n__\n\nSolution\n\n__\n\nSee Figure 10.23. Maybe a better, or additional approach would be to first\ncluster those vertices that are very close together and from the same country.\n\n    \n    \n    library(\"ggraph\")\n    ggraph(gr09, layout=\"fr\") +\n      geom_edge_link(color = \"black\",alpha=0.5) +\n      geom_node_point(aes(color = vertex_attr(gr09)$name), size = 2) +\n      geom_node_label(aes(label = vertex_attr(gr09)$name), color=\"black\",size=2,repel=TRUE) +\n      theme_void() +\n      guides(color=guide_legend(keyheight=0.1,keywidth=0.1,\n          title=\"Countries\"))__\n\n[![](10-chap_files/figure-html/fig-graphs-\nnetworklabelrepel-1.png)](10-chap_files/figure-html/fig-graphs-\nnetworklabelrepel-1.png \"Figure 10.23: Solution to Question wrn-graphs-\nnetworklabelrepel.\")\n\nFigure 10.23: Solution to Question 10.16.\n\nIt could be preferable to use a **graph layout** that incorporates the known\ngeographic coordinates. Thus, we might be able to see how the virus jumped\nlarge distances across the world through traveller mobility. We introduce\napproximate country coordinates, which we then **jitter** slightly to reduce\noverlapping.\n\n    \n    \n    library(\"rworldmap\")\n    mat = match(country09, countriesLow$NAME)\n    coords2009 = data.frame(\n      lat = countriesLow$LAT[mat],\n      lon = countriesLow$LON[mat],\n      country = country09)\n    layoutCoordinates = cbind(\n      x = jitter(coords2009$lon, amount = 15),\n      y = jitter(coords2009$lat, amount = 8))\n    labc = names(table(country09)[which(table(country09) > 1)])\n    matc = match(labc, countriesLow$NAME)\n    dfc = data.frame(\n      latc = countriesLow$LAT[matc],\n      lonc = countriesLow$LON[matc],\n      labc)\n    dfctrans = dfc\n    dfctrans[, 1] = (dfc[,1] + 31) / 93\n    dfctrans[, 2] = (dfc[,2] + 105) / 238\n    Countries = vertex_attr(gr09)$name \n    \n    ggraph(gr09, layout=layoutCoordinates) +\n      geom_node_point(aes(color=Countries),size = 3, alpha=0.75) +\n      geom_edge_arc(color = \"black\", alpha = 0.5, strength=0.15) +\n      geom_label(data=dfc,aes(x=lonc,y=latc,label=labc,fill=labc),colour=\"white\",alpha=0.8,size=3,show.legend=F) +\n      theme_void()  __\n\n[![](10-chap_files/figure-html/fig-HIVmap-1.png)](10-chap_files/figure-\nhtml/fig-HIVmap-1.png \"Figure 10.24: A minimum spanning tree between HIV\ncases. The geographic locations of the cases were jittered to reduce\noverlapping. The DNA sequence distances between the HIV strains were used as\ninput to an undirected minimum spanning tree algorithm.\")\n\nFigure 10.24: A minimum spanning tree between HIV cases. The geographic\nlocations of the cases were jittered to reduce overlapping. The DNA sequence\ndistances between the HIV strains were used as input to an undirected minimum\nspanning tree algorithm.\n\nThe input to the minimum spanning tree algorithm is a distance matrix or a\ngraph with a length edge attribute. Figure 10.24 is the minimum spanning tree\nbetween cases of HIV, for which strain information was made available through\nthe HIVdb database@HIVdb. The DNA distances were computed using the Jukes-\nCantor mutation model.\n\n__\n\nQuestion 10.17\n\nThe above analysis provided an **undirected** network of connections, in fact\nseveral implementations of the minimum spanning tree (ie for instance `mstree`\nin **[ade4](https://cran.r-project.org/web/packages/ade4/)**) provide a\ndirected path through the points, which can provide meaningful information on\nthe (apparent) spread of disases. Make a directed network version of the above\nmaps.\n\nMST is a very useful component of a simple nonparametric test for detecting\ndifferences between factors that are mapped onto its vertices.\n\n### 10.6.1 MST based testing: the Friedman–Rafsky test\n\nGraph-based two-sample tests8 were introduced by Friedman and Rafsky\n([Friedman and Rafsky 1979](16-chap.html#ref-friedman1979multivariate)) as a\ngeneralization of the Wald-Wolfowitz runs test (see Figure 10.25). Our\nprevious examples show graph vertices associated with covariates such as\ncountry of origin. Here we test whether the covariate is significantly\n**associated** to the graph structure.\n\n8 Tests that explore whether two samples are drawn from the same distribution.\n\nThe **Friedman-Rafsky** tests for two/multiple sample segregation on a minimum\nspanning tree. It was conceived as a generalization of the univariate Wald-\nWolfowitz runs test. If we are comparing two samples, say men and women, whose\ncoordinates represent a measurement of interest. We color the two groups blue\nand red as in Figure 10.25, the Wald-Wolfowitz test looks for long runs of the\nsame color that would indicate that the two groups have different means.\n\n[![](10-chap_files/figure-html/fig-WWtest-1.png)](10-chap_files/figure-\nhtml/fig-WWtest-1.png \"Figure 10.25: Seeing the number of runs in a one-\ndimensional, two-sample, nonparametric Wald-Wolfowitz test can indicate\nwhether the two groups have the same distributions.\")\n\nFigure 10.25: Seeing the number of runs in a one-dimensional, two-sample,\nnonparametric Wald-Wolfowitz test can indicate whether the two groups have the\nsame distributions.\n\nInstead of looking for consecutive values of one type (‘runs’), we count the\nnumber of connected nodes of the same type.\n\nOnce the minimum spanning tree has been constructed, the vertices are assigned\n`colors’ according to the different levels of a categorical variable. We call\n**pure** edges those whose two nodes have the same level of the factor\nvariable. We use \\\\(S_O\\\\), the number of **pure** edges as our test\nstatistic. To evaluate whether our observed value could have occurred by\nchance when the groups have the same distributions, we permute the vertix\nlabels (colors) randomly and recount how many pure edges there are. This label\nswapping is repeated many times, creating our null distribution for \\\\(S\\\\).\n\n### 10.6.2 Example: Bacteria sharing between mice\n\nHere we illustrate the idea on a collection of samples from mice whose stool\nwere analyzed for their microbial content. We read in a data set with many\nmice and many taxa, we compute the Jaccard distance and then use the `mst`\nfunction from the\n**[igraph](https://cran.r-project.org/web/packages/igraph/)** package. We\nannotate the graph with the relevant covariates as shown in the code below:\n\n    \n    \n    ps1  = readRDS(file.path(DATA,\"ps1.rds\"))\n    sampledata = data.frame( sample_data(ps1))\n    d1 = as.matrix(phyloseq::distance(ps1, method=\"jaccard\"))\n    gr = graph_from_adjacency_matrix(d1,  mode = \"undirected\", weighted = TRUE)\n    net = igraph::mst(gr)\n    V(net)$id = sampledata[names(V(net)), \"host_subject_id\"]\n    V(net)$litter = sampledata[names(V(net)), \"family_relationship\"]__\n\nWe make a `ggraph` object from the resulting igraph generated minimum spanning\ntree and then plot it, as shown in Figure 10.26.\n\n    \n    \n    ggraph(net, layout=\"fr\")+\n      geom_edge_arc(color = \"darkgray\") +\n      geom_node_point(aes(color = id, shape = litter)) + \n      theme(legend.position=\"bottom\")__\n\n[![](10-chap_files/figure-html/fig-mstplot-1.png)](10-chap_files/figure-\nhtml/fig-mstplot-1.png \"Figure 10.26: The minimum spanning tree based on\nJaccard dissimilarity and annotated with the mice ID and litter factors\")\n\nFigure 10.26: The minimum spanning tree based on Jaccard dissimilarity and\nannotated with the mice ID and litter factors\n\nNow we compute the null distribution and p-value for the test, this is\nimplemented in the **phyloseqGraphTest** package:\n\n    \n    \n    library(\"phyloseqGraphTest\")\n    gt = graph_perm_test(ps1, \"host_subject_id\", distance=\"jaccard\",\n                         type=\"mst\",  nperm=1000)\n    gt$pval __\n    \n    \n    [1] 0.000999\n\nWe can take a look at the complete histogram of the null distribution\ngeneratedby permutation using:\n\n    \n    \n    plot_permutations(gt)__\n\n[![](10-chap_files/figure-html/fig-mstJaccard-1.png)](10-chap_files/figure-\nhtml/fig-mstJaccard-1.png \"Figure 10.27: The permutation histogram of the\nnumber of pure edges in the network obtained from the minimal spanning tree\nwith Jaccard similarity.\")\n\nFigure 10.27: The permutation histogram of the number of pure edges in the\nnetwork obtained from the minimal spanning tree with Jaccard similarity.\n\n#### Different choices for the skeleton graph\n\nIt is not necessary to use an MST for the skeleton graph that defines the\nedges. Graphs made by linking nearest neighbors ([Schilling\n1986](16-chap.html#ref-schilling1986multivariate)) or distance thresholding\nwork as well.\n\nThe Bioconductor package\n**[phyloseq](https://bioconductor.org/packages/phyloseq/)** has functionality\nfor creating graphs based on thresholding a distance matrix through the\nfunction `make_network`. We create a network by creating an edge between\nsamples whose Jaccard dissimilarity is less than a threshold, which we set\nbelow via the parameter `max.dist`. We can also use the\n**[ggraph](https://cran.r-project.org/web/packages/ggraph/)** package to add\nattributes to the vertices indicating which mouse the sample came from and\nwhich litter the mouse was in. We see that in the resulting network, shown in\nFigure 10.28, there is grouping of the samples by both mouse and litter.\n\n    \n    \n    net = make_network(ps1, max.dist = 0.35)\n    sampledata = data.frame(sample_data(ps1))\n    V(net)$id = sampledata[names(V(net)), \"host_subject_id\"]\n    V(net)$litter = sampledata[names(V(net)), \"family_relationship\"]__\n    \n    \n    ggraph(net, layout=\"fr\") +\n      geom_edge_link(color = \"darkgray\") +\n      geom_node_point(aes(color = id, shape = litter)) + \n        theme(plot.margin = unit(c(0, 5, 2, 0), \"cm\"))+\n        theme(legend.position = c(1.4, 0.3),legend.background = element_blank(),\n              legend.margin=margin(0, 3, 0, 0, \"cm\"))+\n             guides(color=guide_legend(ncol=2))+\n      theme_graph(background = \"white\")__\n\n[![](10-chap_files/figure-html/fig-\nggnetworkplotJ-1.png)](10-chap_files/figure-html/fig-ggnetworkplotJ-1.png\n\"Figure 10.28: A co-occurrence network created by using a threshold on the\nJaccard dissimilarity matrix. The colors represent which mouse the sample came\nfrom; the shape represents which litter the mouse was in.\")\n\nFigure 10.28: A co-occurrence network created by using a threshold on the\nJaccard dissimilarity matrix. The colors represent which mouse the sample came\nfrom; the shape represents which litter the mouse was in.\n\nNote that no matter which graph we build between the samples, we can\napproximate a null distribution by permuting the labels of the nodes of the\ngraph. However, sometimes it will preferable to adjust the permutation\ndistribution to account for known structure between the covariates.\n\n### 10.6.3 Friedman–Rafsky test with nested covariates\n\nIn the test above, we took a rather naïve approach and showed there was a\nsignificant difference between individual mice (the `host_subject_id`\nvariable). Here we perform a slightly different permutation test to find out\nif we control for the difference between mice; is there a litter (the\n`family_relationship` variable) effect? The setup of the test is similar, it\nis simply how the permutations are generated which differs. We maintain the\nnested structure of the two factors using the `grouping` argument. We permute\nthe `family_relationship` labels but keep the `host_subject_id` structure\nintact.\n\n    \n    \n    gt = graph_perm_test(ps1, \"family_relationship\",\n            grouping = \"host_subject_id\",\n            distance = \"jaccard\", type = \"mst\", nperm= 1000)\n    gt$pval __\n    \n    \n    [1] 0.002\n\nThis test has a small p-value, and we reject the null hypothesis that the two\nsamples come from the same distribution. From the plot of the minimum spanning\ntree in Figure 10.27, we see by eye that the samples group by litter more than\nwe would expect by chance.\n\n    \n    \n    plot_permutations(gt)__\n\n[![](10-chap_files/figure-html/fig-\nmstpermplotNest-1.png)](10-chap_files/figure-html/fig-mstpermplotNest-1.png\n\"Figure 10.29: The permutation histogram obtained from the minimal spanning\ntree with Jaccard similarity.\")\n\nFigure 10.29: The permutation histogram obtained from the minimal spanning\ntree with Jaccard similarity.\n\n__\n\nQuestion 10.18\n\nThe \\\\(k\\\\)-nearest neighbors graph is obtained by putting an edge between two\nsamples whenever one of them is in the set of \\\\(k\\\\)-nearest neighbors of the\nother. Redo the test, defining the graph using nearest neighbors defined with\nthe Jaccard distance. What would you conclude?\n\n__\n\nSolution\n\n__\n\n    \n    \n    gtnn1 = graph_perm_test(ps1, \"family_relationship\",\n                          grouping = \"host_subject_id\",\n                          distance = \"jaccard\", type = \"knn\", knn = 1)\n    gtnn1$pval __\n    \n    \n    [1] 0.004\n\nFigure 10.30 shows that pairs of samples having edges between them in this\nnearest neighbor graph are much more likely to be from the same litter.\n\n    \n    \n    plot_test_network(gtnn1)__\n\n[![](10-chap_files/figure-html/fig-knn-1-plot-1.png)](10-chap_files/figure-\nhtml/fig-knn-1-plot-1.png \"Figure 10.30: The graph obtained from a nearest-\nneighbor graph with Jaccard similarity.\")\n\nFigure 10.30: The graph obtained from a nearest-neighbor graph with Jaccard\nsimilarity.\n\n**Note: The dual graph**  \nIn the examples above we sought to show relationships between samples through\ntheir shared taxa. It can also be of interest to ask the question about taxa:\ndo some of the taxa co-occur more often than one would expect? This approach\ncan help study microbial `communities’ as they assemble in the microbiome. The\nmethods we developed above all apply to this use-case, all one really does is\ntranspose the data. It is always preferable with sparse data such as the\nmicrobiome to use Jaccard and not build correlation networks that can be\nappropriate in other settings.\n\n## 10.7 Summary of this chapter\n\n#### Annotated graphs\n\nIn this chapter we have learnt how to store and plot data that have more\nstructure than simple arrays: graphs have edges and nodes that can also be\nassociated to extra annotations that can be displayed usefully.\n\n#### Important examples of graphs and useful R packages\n\nWe started by specific examples such as Markov chain graphs, phylogenetic\ntrees and minimum spanning trees. We saw how to use the\n**[ggraph](https://cran.r-project.org/web/packages/ggraph/)** and\n**[igraph](https://cran.r-project.org/web/packages/igraph/)** packages to\nvisualize graphs and show as much information as possible by using specific\ngraph layout algorithms.\n\n#### Combining graphs with statistical data\n\nWe then approached the problem of incorporating a known `skeleton’ graph into\ndifferential expression analyses. This enables use to pinpoint perturbation\nhotspots in a network. We saw how evolutionary models defined along rooted\nbinary trees serve as the basis for phylogenetic tree estimation and how we\ncan incorporate these trees as supplementary information in a differential\nabundance analysis using the R packages\n**[structSSI](https://cran.r-project.org/web/packages/structSSI/)** and\n**[phyloseq](https://bioconductor.org/packages/phyloseq/)**.\n\n#### Linking co-occurrence to other variables\n\nGraph and network tools also enable the creation of networks from co-\noccurrence data and can be used to visualize and test the effect of factor\ncovariates. We saw the Friedman-Rafsky test which provides an easy way of\ntesting dependencies of a variable with the edge structure of a skeleton\ngraph.\n\n#### Context and intepretation aids\n\nThis chapter illustrated ways of incorporating interactions of players in a\nnetwork and we saw how useful it was to combine this with statistical scores.\nThis often provides biological insight into analyses of complex biological\nsystems.\n\n#### Previous knowledge or outcome\n\nWe saw that graphs can be both useful to encode our previous knowledge,\nmetabolic network information, gene ontologies and phylogenetic trees of known\nbacteria are all available in standard databases. It is beneficial in a study\nto incorprate all known information and doing so by combining these skeleton\nnetworks with observed data enhances our understanding of experimental results\nin the context of what is already known.\n\nOn the other hand, the graph can be the outcome that we want to predict and we\nsaw how to build graphs from data (phylogenetic trees, co-occurrence networks\nand minimum spanning trees).\n\n## 10.8 Further reading\n\nFor complete developments and many important consequences of the evolutionary\nmodels used in phylogenetic trees, see the books by Li\n([1997](16-chap.html#ref-WHLi); [Li and Graur 1991](16-chap.html#ref-\nLiandGraur)). The book by Felsenstein ([2004](16-chap.html#ref-fels:book)) is\nthe classic text on estimating phylogenetic trees.\n\nThe book written by the author of the\n**[ape](https://cran.r-project.org/web/packages/ape/)** packages, Paradis\n([2011](16-chap.html#ref-paradis:2011)) contains many use-cases and details\nabout manipulation of trees in R. A review of bootstrapping for phylogenetic\ntrees can be found in Holmes ([2003a](16-chap.html#ref-Holmes-2003)).\n\nWe can use a tree as well as abundances in a contingency table data through an\nextension of PCoA-MDS called DPCoA (Double principal coordinate analysis). For\nmicrobiome data, the phylogenetic tree provides distances between taxa; these\ndistances serve as the basis for the first PCoA. A second PCoA enables the\nprojection of the weighted sample points. This has proved very effective in\nmicrobial ecology applications, see Purdom ([2010](16-chap.html#ref-\nPurdom2010)) or Fukuyama et al. ([2012](16-chap.html#ref-Fukuyama:2012)) for\ndetails.\n\nGraphs can be used to predict vertex covariates. There is a large field of\napplied statistics and machine learning that considers the edges in the graph\nas a response variable for which one can make predictions based on covariates\nor partial knowledge of the graph; these include **ERGM** ’s (Exponential\nRandom Graph Models, Robins et al. ([2007](16-chap.html#ref-robins:2007))) and\nkernel methods for graphs ([Schölkopf, Tsuda, and Vert 2004](16-chap.html#ref-\nVertKernel)).\n\nFor theoretical properties of the Friedman-Rafsky test and more examples see\nBhattacharya ([2015](16-chap.html#ref-Bhattacharya:2015)).\n\nA full list packages that deal with graphs and networks is available at:\n<http://www.bioconductor.org/packages/release/BiocViews.html#___GraphAndNetwork>.\n\n## 10.9 Exercises\n\n__\n\nExercise 10.1\n\nCreate a function that plots a graph starting from an adjacency matrix. Show\nhow it works on an example.\n\n__\n\nSolution\n\n__\n\n    \n    \n    ggplotadjacency = function(a) {\n      n = nrow(a)\n      p = ncol(a)\n      fromto  = reshape2::melt(a)\n      stopifnot(identical(nrow(fromto), n*p))\n      fromto$value = as.factor(fromto$value)\n      cols = c(\"white\", \"darkblue\")\n      ggplot(data = fromto, aes(x = Var1, y = Var2, fill = value)) +\n        geom_tile(colour = \"black\") +\n        coord_fixed(ratio = 1, ylim = c(0.5, n + 0.5), xlim = c(0.5, p + 0.5)) +\n        scale_fill_manual(values = cols) +\n        scale_x_continuous(name = \"\" , breaks = 1:p, labels = paste(1:p)) +\n        scale_y_reverse(  name = \"\" , breaks = n:1, labels = paste(n:1)) + \n        theme_bw() +\n        theme(axis.text = element_text(size = 14),\n          legend.key = element_rect(fill = \"white\"),\n          legend.background = element_rect(fill = \"white\"),\n          panel.border = element_blank(),\n          panel.grid.major = element_blank(),\n          panel.grid.minor = element_blank(),\n          axis.line = element_line(color = \"white\"),\n          axis.ticks.x = element_blank(),\n          axis.ticks.y = element_blank() \n        )\n    }__\n\n__\n\nExercise 10.2\n\nThe relationships between gene functions is organized hierarchically into a\ngraph called the Gene Ontology (GO) graph. The biological processes are\norganized at finer and finer scale. Take one of the databases providing the GO\ninformation for the organisms you are interested in. Choose a gene list and\nbuild the GO graph for that list.  \nHint: Some examples can be found in the packages , , .\n\n__\n\nExercise 10.3\n\n_Markov chain graph of transitions between states of the vaginal microbiota_ :\nIn DiGiulio et al. ([2015](16-chap.html#ref-DigiulioCallahan:2015)) the\nauthors use an **[igraph](https://cran.r-project.org/web/packages/igraph/)**\nplot to represent the transitions rates between community state types CSTs\nusing the\n**[markovchain](https://cran.r-project.org/web/packages/markovchain/)**\npackage. Load the data and the transition rates and state names into an object\nof the special class `markovchain` and tailor the layout carefully to include\nthe percentage of preterm birth as a covariate for the vertices (make the\nvertex size proportional to this variable). Include the size of transitions\nbetween states as the width of the arrows.\n\n__\n\nSolution\n\n__\n\nNote: the below code is not live, a version of it used to run for the authors\nat one point, here it is given as a starting point for the reader to finish,\nit has opportunities for modernization and improvement.\n\n[![](imgs/PSB_MC_s.png)](imgs/PSB_MC_s.png \"Figure 10.31: This figure was\noriginally created for the study done in @DigiulioCallahan:2015, where the\nnodes designate states of the vaginal microbiome and arrows represent\ntransitions between states with different probabilities.\")\n\nFigure 10.31: This figure was originally created for the study done in\nDiGiulio et al. ([2015](16-chap.html#ref-DigiulioCallahan:2015)), where the\nnodes designate states of the vaginal microbiome and arrows represent\ntransitions between states with different probabilities.\n\n    \n    \n    library(\"markovchain\")\n    # Make Markov chain object\n    mcPreg  =  new(\"markovchain\", states = CSTs,\n                  transitionMatrix = trans, name=\"PregCST\")\n    mcPreg\n    # Set up igraph of the markov chain\n    netMC  =  markovchain:::.getNet(mcPreg, round = TRUE)__\n\nNow define a number of plotting parameters, and assign node colors based on\nthe association of that CST and preterm outcome.\n\n    \n    \n    wts  =  E(netMC)$weight/100\n    edgel  =  get.edgelist(netMC)\n    elcat  =  paste(edgel[,1], edgel[,2])\n    elrev  =  paste(edgel[,2], edgel[,1])\n    edge.curved  =  sapply(elcat, function(x) x %in% elrev)\n    samples_def  =  data.frame(sample_data(ps))\n    samples_def  =  samples_def[samples$Preterm | samples$Term,] # Only those definitely assigned, i.e. not marginal\n    premat  =  table(samples_def$CST, samples_def$Preterm)\n    rownames(premat)  =  markovchain::states(mcPreg)\n    colnames(premat)  =  c(\"Term\", \"Preterm\")\n    premat\n    premat  =  premat/rowSums(premat)\n    vert.CSTclrs  =  CSTColors __\n    \n    \n    default.par  =  par(no.readonly = TRUE)\n    # Define color scale\n    # Plotting function for markov chain\n    plotMC  =  function(object, ...) {\n        netMC  =  markovchain:::.getNet(object, round = TRUE)\n        plot.igraph(x = netMC, ...)\n    }\n    # Color bar for the markov chain visualization, gradient in strength of preterm association\n    color.bar  =  function(lut, min, max=-min, nticks=11, ticks=seq(min, max, len=nticks), title=NULL) {\n        scale = (length(lut)-1)/(max-min)\n        cur.par = par(no.readonly = TRUE)\n        par(mar = c(0, 4, 1, 4) + 0.1, oma = c(0, 0, 0, 0) + 0.1)\n        par(ps = 10, cex = 0.8)\n        par(tcl=-0.2, cex.axis=0.8, cex.lab = 0.8)\n        plot(c(min,max), c(0,10), type='n', bty='n', xaxt='n', xlab=\", yaxt='n', ylab=\", main=title)\n        axis(1, c(0, 0.5, 1))\n        for (i in 1:(length(lut)-1)) {\n          x = (i-1)/scale + min\n          rect(x,0,x+1/scale,10, col=lut[i], border=NA)\n        }\n    }\n    \n    pal  =  colorRampPalette(c(\"grey50\", \"maroon\", \"magenta2\"))(101)\n    vert.clrs  =  sapply(states(mcPreg), function(x) pal[1+round(100*premat[x,\"Preterm\"])])\n    vert.sz  =  4 + 2*sapply(states(mcPreg),\n                  function(x) nrow(unique(sample_data(ps)[sample_data(ps)$CST==x,\"SubjectID\"])))\n    vert.sz  =  vert.sz * 0.85\n    vert.font.clrs  =  c(\"white\", \"white\", \"white\", \"white\", \"white\")\n    \n    # E(netMC) to see edge list, have to define loop angles individually by the # in edge list, not vertex\n    edge.loop.angle = c(0, 0, 0, 0, 3.14, 3.14, 0, 0, 0, 0, 3.14, 0, 0, 0, 0, 0)-0.45\n    layout  =  matrix(c(0.6,0.95, 0.43,1, 0.3,0.66, 0.55,0.3, 0.75,0.65), nrow = 5, ncol = 2, byrow = TRUE)\n    \n    # Color by association with preterm birth\n    layout(matrix(c(1,1,2,2), 2, 2, byrow = TRUE), heights=c(1,10))\n    color.bar(pal, min=0, max=1, nticks=6, title=\"Fraction preterm\")\n    par(mar=c(0,1,1,1)+0.1)\n    edge.arrow.size=0.8\n    edge.arrow.width=1.4\n    edge.width = (15*wts + 0.1)*0.6\n    edge.labels  =  as.character(E(netMC)$weight/100)\n    edge.labels[edge.labels<0.4]  =  NA  # labels only for self-loops\n    plotMC(mcPreg, edge.arrow.size=edge.arrow.size, edge.arrow.width = edge.arrow.width,\n           edge.width=edge.width, edge.curved=edge.curved,\n           vertex.color=vert.clrs, vertex.size=(vert.sz),\n           vertex.label.font = 2, vertex.label.cex = 1,\n           vertex.label.color = vert.font.clrs, vertex.frame.color = NA,\n           layout=layout, edge.loop.angle = edge.loop.angle)\n    par(default.par)__\n\n__\n\nExercise 10.4\n\n**Protein interaction networks** : Read the Wikipedia article about the\n[STRING](https://en.wikipedia.org/wiki/STRING) database (http://www.string-\ndb.org).  \nThe protein Cyclin B1 is encoded by the CCNB1 gene. You can read about it on\nwikipedia here: <https://en.wikipedia.org/wiki/Cyclin_B1>.  \nUse STRING to generate a text file (call it _ccnb1datsmall.txt_) of edges\naround the CCNB1 gene. Choose nodes that are connected by evidence of co-\nexpression with a confidence higher than 0.9. Collect no more than 50\ninteractions and additional nodes that are two steps away from CCNB1 in the\ngraph.\n\n__\n\nSolution\n\n__\n\n  1. Go to <http://www.string-db.org>.\n\n  2. Enter CCNB1 as the protein name and Homo sapiens as the organism. Click “Continue!”\n\n  3. Select the option with protein CCNB1 (the top one).\n\n  4. Scroll down to “info and Parameters …” 4a. For Active Prediction Methods – unselect everything except “Co-Expression” 4b. For required confidence – select “highest confidence (0.900) 4c. For interactors shown – select”no more than 50 interactors” 4d. For additional (white) nodes – select “100” (these are nodes two steps away from CCNB1) 4e. Click “Update Parameters”. You should get something that looks like the image below.\n\n  5. Click “save” under the picture (showing a diskette). This will open up a new window so you can choose which format to save the data.\n\n  6. Scroll down to the “Text Summary (TXT - simple tab delimited flatfile)” file and save that document as _ccnb1datsmall.txt_.\n\n__\n\nExercise 10.5\n\nRead the txt file _ccnb1datsmall.txt_ into R and make a plot of the graph\nusing one of the graph visualization methods covered in this chapter.\n\n__\n\nSolution\n\n__\n\n[![](imgs/ccnb1img.png)](imgs/ccnb1img.png \"Figure 10.32: This network was\ncreated with the STRING website by setting a 2 step neighborhood around the\nCCNB1 gene for co-expression levels \\\\geq 0.900.\")\n\nFigure 10.32: This network was created with the STRING website by setting a 2\nstep neighborhood around the CCNB1 gene for co-expression levels \\\\(\\geq\\\\)\n0.900.\n\n    \n    \n    dat = read.table(file.path(DATA,\"ccnb1datsmall.txt\"), header = TRUE, comment.char = \"\", stringsAsFactors = TRUE)\n    v = levels(unlist(dat[,1:2]))        # vertex names\n    n = length(v)                        # number of vertices\n    e = matrix(match(as.character(unlist(dat[,1:2])), v),ncol=2) # edge list\n    w = dat$coexpression                 # edge weights __\n\nM is our co-expression network adjacency matrix. Since the STRING data only\nsays if proteins i and j are co-expressed and doesn’t distinguish between\n(i,j) and (j,i) we want to make M symmetric (undirected) by considering the\nweight on (i,j) is the same as from (j,i). A is our co-expression graph\nadjacency matrix and we make \\\\(A_{ij} = 1\\\\) if they are coexpressed.\n\n    \n    \n    M = matrix(0, n, n)\n    M[e] = w\n    M = M + t(M)\n    dimnames(M) = list(v, v)\n    A = 1*(M > 0)__\n\nWe use default plotting parameters and generate the graph using the package\n**[igraph](https://cran.r-project.org/web/packages/igraph/)** starting with\n`e`, the vector of edges (an alternative is to use the adjacency matrix A).\n\n_Note:_ We use a seed to make the graph always look the same. Graph layout\noften contains an optimization with a random component that makes the picture\nlook different, although the graph itself is the same.\n\n    \n    \n    library(igraph)\n    net = network(e, directed=FALSE)\n    par(mar=rep(0,4))\n    plot(net, label=v)__\n\nYou could make a graph with\n**[ggraph](https://cran.r-project.org/web/packages/ggraph/)**.\n\n__\n\nExercise 10.6\n\nMake a heatmap showing the adjacency matrix of the graph created in Exercise\n10.5.\n\n__\n\nSolution\n\n__\n\nWe use defaults in making a heatmap except for changing the colors, you can\nexperiment and add additional parameters.\n\n    \n    \n    breaks  =  c(0, seq(0.9, 1, length=11))\n    cols  =  grey(1-c(0,seq(0.5,1,length=10)))\n    ccnb1ind  =  which(v == \"CCNB1\")\n    vcols  =  rep(\"white\",n)\n    vcols[ccnb1ind]  =  \"blue\"\n    vcols[which(M[,ccnb1ind]>0 | M[ccnb1ind,])]  =  \"red\"\n    par(mar = rep(0, 4))\n    heatmap(M, symm = TRUE, ColSideColors = vcols, RowSideColors = vcols,\n            col = cols, breaks = breaks,  frame = TRUE)\n    legend(\"topleft\", c(\"Neighbors(CCNB1)\", \"CCNB1\"),\n           fill = c(\"red\",\"blue\"),\n           bty = \"n\", inset = 0, xpd = TRUE,  border = FALSE)__\n\n[![](10-chap_files/figure-html/fig-heatmapCCNB1-1.png)](10-chap_files/figure-\nhtml/fig-heatmapCCNB1-1.png \"Figure 10.33: This represents the adjacency of\nthe CCNB1 network – 2 step neighborhood with co-expression levels \\\\geq 0.900,\ngenerated from R \\(darker is closer to 1, we ignore values < 0.9\\).\")\n\nFigure 10.33: This represents the adjacency of the CCNB1 network – 2 step\nneighborhood with co-expression levels \\\\(\\geq\\\\) 0.900, generated from R\n(darker is closer to 1, we ignore values < 0.9).\n\n__\n\nExercise 10.7\n\nThe visualization shows the strongest interactions in the two step\nneighborhood of CCNB1. Both the plotted graph and the heatmap image show the\nsame data: there seems to be a cluster of proteins which are all similar to\nCCNB1 and there is also another cluster in the other proteins. Many of the\nproteins in the CCNB1 cluster are coexpressed at the same time as each other.  \nWhy might this be the case?  \nConversely, proteins which are coexpressed with a protein that is coexpressed\nwith CCNB1 (two steps away) do not tend to be coexpressed with each other.  \nIs it easier for you to see this in one of the figures (the plot or the\nheatmap) than the other?\n\n__\n\nExercise 10.8\n\nCompare the use of **[ape](https://cran.r-project.org/web/packages/ape/)** and\n**[phangorn](https://cran.r-project.org/web/packages/phangorn/)** in the\nanalysis of HIV GAG data. Compute the Jukes Cantor distances between the\nsequences using both packages and compare them to the Hamming distances.\n\n    \n    \n    library(\"ape\")\n    library(\"phangorn\")\n    GAG = read.dna(file.path(DATA, \"DNA_GAG_20.txt\"))__\n\n__\n\nExercise 10.9\n\nPerform the Friedman–Rafksy type test with a “two-nearest” neighbor-graph\nusing the Bray-Curtis dissimilarity.\n\n__\n\nSolution\n\n__\n\n    \n    \n    gt = graph_perm_test(ps1, \"family_relationship\", distance = \"bray\", \n                         grouping = \"host_subject_id\", type = \"knn\", knn = 2)\n    gt$pval __\n    \n    \n    [1] 0.004\n    \n    \n    plot_test_network(gt)\n    permdf = data.frame(perm=gt$perm)\n    obs = gt$observed\n    ymax = max(gt$perm)\n    ggplot(permdf, aes(x = perm)) + geom_histogram(bins = 20) +\n      geom_segment(aes(x = obs, y = 0, xend = obs, yend = ymax/10), color = \"red\") +\n      geom_point(aes(x = obs, y = ymax/10), color = \"red\") + xlab(\"Number of pure edges\")__\n\n[![](10-chap_files/figure-html/fig-knn-2-plot-1.png)](10-chap_files/figure-\nhtml/fig-knn-2-plot-1.png \"Figure 10.34 \\(a\\): \\\\text{}\")\n\n(a) \\\\(\\text{}\\\\)\n\n[![](10-chap_files/figure-html/fig-knn-2-plot-2.png)](10-chap_files/figure-\nhtml/fig-knn-2-plot-2.png \"Figure 10.34 \\(b\\): \\\\text{}\")\n\n(b) \\\\(\\text{}\\\\)\n\nFigure 10.34: The graph (a) and permutation histogram (b) obtained from a two\nnearest-neighbor graph with Jaccard similarity.\n\nBeisser, Daniela, Gunnar W Klau, Thomas Dandekar, Tobias Müller, and Marcus T\nDittrich. 2010. “BioNet: An R-Package for the Functional Analysis of\nBiological Networks.” _Bioinformatics_ 26 (8): 1129–30.\n\nBenjamini, Yoav, and Marina Bogomolov. 2014. “Selective Inference on Multiple\nFamilies of Hypotheses.” _Journal of the Royal Statistical Society: Series B_\n76 (1): 297–318.\n\nBenjamini, Yoav, and Daniel Yekutieli. 2003. “Hierarchical FDR Testing of\nTrees of Hypotheses.” Technical report, Department of Statistics; Operations\nResearch, Tel Aviv University.\n\nBhattacharya, Bhaswar B. 2015. “Power of Graph-Based Two-Sample Tests.” _arXiv\nPreprint arXiv:1508.07530_.\n\nBouckaert, Remco, Joseph Heled, Denise Kühnert, Tim Vaughan, Chieh-Hsi Wu,\nDong Xie, Marc A Suchard, Andrew Rambaut, and Alexei J Drummond. 2014. “BEAST\n2: A Software Platform for Bayesian Evolutionary Analysis.” _PLoS\nComputational Biology_ 10 (4): e1003537.\n\nCallahan, Benjamin J, Paul J McMurdie, and Susan P Holmes. 2017. “Exact\nSequence Variants Should Replace Operational Taxonomic Units in Marker Gene\nData Analysis.” _ISME Journal_ , 1–5.\n\nChakerian, John, and Susan Holmes. 2012. “Computational Tools for Evaluating\nPhylogenetic and Hierarchical Clustering Trees.” _Journal of Computational and\nGraphical Statistics_ 21 (3): 581–99.\n\nCole, J. R., Q. Wang, E. Cardenas, J. Fish, B. Chai, R. J. Farris, A. S.\nKulam-Syed-Mohideen, et al. 2009. “The Ribosomal Database Project: Improved\nAlignments and New Tools for rRNA Analysis.” _Nucleic Acids Research_ 37\n(Supplement 1): D141–45.\n\nDiGiulio, Daniel B., Benjamin J. Callahan, Paul J. McMurdie, Elizabeth K.\nCostello, Deirdre J. Lyelle, Anna Robaczewska, Christine L. Sun, et al. 2015.\n“Temporal and Spatial Variation of the Human Microbiota During Pregnancy.”\n_PNAS_.\n\nFelsenstein, Joseph. 2004. _Inferring Phylogenies_. Boston: Sinauer.\n\nFriedman, Jerome H, and Lawrence C Rafsky. 1979. “Multivariate Generalizations\nof the Wald-Wolfowitz and Smirnov Two-Sample Tests.” _The Annals of\nStatistics_ , 697–717.\n\nFukuyama, Julia, Paul J McMurdie, Les Dethlefsen, David A Relman, and Susan\nHolmes. 2012. “Comparisons of Distance Methods for Combining Covariates and\nAbundances in Microbiome Studies.” In _Pac Symp Biocomput_. World Scientific.\n\nHolmes, Susan. 1999. “Phylogenetic Trees: An Overview.” In _Statistics and\nGenetics_ , 81–118. IMA 112. New York: Springer.\n\n———. 2003a. “Bootstrapping Phylogenetic Trees: Theory and Methods.”\n_Statistical Science_ 18 (2): 241–55.\n\n———. 2003b. “Statistics for phylogenetic trees.” _Theoretical Population\nBiology_ 63 (1): 17–32.\n\nIdeker, Trey, Owen Ozier, Benno Schwikowski, and Andrew F Siegel. 2002.\n“Discovering Regulatory and Signalling Circuits in Molecular Interaction\nNetworks.” _Bioinformatics_ 18 Suppl 1 (January): S233–40.\n<http://bioinformatics.oxfordjournals.org/cgi/reprint/18/suppl\\_1/S233>.\n\nLi, Wen-Hsiung. 1997. _Molecular Evolution._ Sinauer Associates Incorporated.\n\nLi, Wen-Hsiung, and Dan Graur. 1991. _Fundamentals of Molecular Evolution_.\nVol. 48. Sinauer Associates Sunderland, MA.\n\nLiberzon, Arthur, Aravind Subramanian, Reid Pinchback, Helga Thorvaldsdóttir,\nPablo Tamayo, and Jill P Mesirov. 2011. “Molecular Signatures Database\n(MSigDB) 3.0.” _Bioinformatics_ 27 (12): 1739–40.\n\nLove, Michael I, Wolfgang Huber, and Simon Anders. 2014. “Moderated Estimation\nof Fold Change and Dispersion for RNA-seq Data with DESeq2.” _Gnome Biology_\n15 (12): 1–21.\n\nMcMurdie, Paul J, and Susan Holmes. 2014. “Waste Not, Want Not: Why Rarefying\nMicrobiome Data Is Inadmissible.” _PLoS Computational Biology_ 10 (4):\ne1003531.\n\n———. 2015. “Shiny-Phyloseq: Web Application for Interactive Microbiome\nAnalysis with Provenance Tracking.” _Bioinformatics_ 31 (2): 282–83.\n\nMossel, Elchanan. 2003. “On the Impossibility of Reconstructing Ancestral Data\nand Phylogenies.” _Journal of Computational Biology_ 10 (5): 669–76.\n\nNacu, Serban, Rebecca Critchley-Thorne, Peter Lee, and Susan Holmes. 2007.\n“Gene Expression Network Analysis and Applications to Immunology.”\n_Bioinformatics_ 23 (7, 7): 850–58.\n<https://doi.org/10.1093/bioinformatics/btm019>.\n\nNolan, Daniel J, Michael Ginsberg, Edo Israely, Brisa Palikuqi, Michael G\nPoulos, Daylon James, Bi-Sen Ding, et al. 2013. “Molecular Signatures of\nTissue-Specific Microvascular Endothelial Cell Heterogeneity in Organ\nMaintenance and Regeneration.” _Developmental Cell_ 26 (2): 204–19.\n\nParadis, Emmanuel. 2011. _Analysis of Phylogenetics and Evolution with r_.\nSpringer Science & Business Media.\n\nPounds, Stan, and Stephan W Morris. 2003. “Estimating the Occurrence of False\nPositives and False Negatives in Microarray Studies by Approximating and\nPartitioning the Empirical Distribution of p-Values.” _Bioinformatics_ 19\n(10): 1236–42.\n\nPurdom, Elizabeth. 2010. “Analysis of a Data Matrix and a Graph: Metagenomic\nData and the Phylogenetic Tree.” _Annals of Applied Statistics_ , July.\n\nRhee, Soo-Yon, Matthew J Gonzales, Rami Kantor, Bradley J Betts, Jaideep\nRavela, and Robert W Shafer. 2003. “Human Immunodeficiency Virus Reverse\nTranscriptase and Protease Sequence Database.” _Nucleic Acids Research_ 31\n(1): 298–303.\n\nRobins, Garry, Tom Snijders, Peng Wang, Mark Handcock, and Philippa Pattison.\n2007. “Recent Developments in Exponential Random Graph (p*) Models for Social\nNetworks.” _Social Networks_ 29 (2): 192–215.\n\nRonquist, Fredrik, Maxim Teslenko, Paul van der Mark, Daniel L Ayres, Aaron\nDarling, Sebastian Höhna, Bret Larget, Liang Liu, Marc A Suchard, and John P\nHuelsenbeck. 2012. “MrBayes 3.2: Efficient Bayesian Phylogenetic Inference and\nModel Choice Across a Large Model Space.” _Systematic Biology_ 61 (3): 539–42.\n\nSankaran, Kris, and Susan Holmes. 2014. “structSSI: Simultaneous and Selective\nInference for Grouped or Hierarchically Structured Data.” _Journal of\nStatistical Software_ 59 (1): 1–21.\n\nSchilling, Mark F. 1986. “Multivariate Two-Sample Tests Based on Nearest\nNeighbors.” _Journal of the American Statistical Association_ 81 (395):\n799–806.\n\nSchölkopf, Bernhard, Koji Tsuda, and Jean-Philippe Vert. 2004. _Kernel Methods\nin Computational Biology_. MIT press.\n\nWang, Q., G. M. Garrity, J. M. Tiedje, and J. R. Cole. 2007. “Naive Bayesian\nClassifier for Rapid Assignment of rRNA Sequences into the New Bacterial\nTaxonomy.” _Applied and Environmental Microbiology_ 73 (16): 5261.\n\nWertheim, Joel O, and Michael Worobey. 2009. “Dating the Age of the SIV\nLineages That Gave Rise to HIV-1 and HIV-2.” _PLoS Computational Biology_ 5\n(5): e1000377.\n\nWright, Erik S. 2015. “DECIPHER: Harnessing Local Sequence Context to Improve\nProtein Multiple Sequence Alignment.” _BMC Bioinformatics_ 16 (1): 1.\n\nYu, Hongxiang, Diana L Simons, Ilana Segall, Valeria Carcamo-Cavazos, Erich J\nSchwartz, Ning Yan, Neta S Zuckerman, et al. 2012. “PRC2/EED-EZH2 Complex Is\nup-Regulated in Breast Cancer Lymph Node Metastasis Compared to Primary Tumor\nand Correlates with Tumor Proliferation in Situ.” _PloS One_ 7 (12): e51239.\n\nPage built at 01:33 on 2025-09-01 using R version 4.5.1 (2025-06-13)\n\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["msmb.css"],"toc":true,"output-file":"10-chap.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.32","theme":"cosmo"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}